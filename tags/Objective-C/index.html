<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: Objective-C - MarkCao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MarkCao&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MarkCao&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MarkCao"><meta property="og:url" content="http://naivertc.top/"><meta property="og:site_name" content="MarkCao"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://naivertc.top/img/og_image.png"><meta property="article:author" content="Mark Cao"><meta property="article:tag" content="WebRTC, C++, iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naivertc.top"},"headline":"MarkCao","image":["http://naivertc.top/img/og_image.png"],"author":{"@type":"Person","name":"Mark Cao"},"publisher":{"@type":"Organization","name":"MarkCao","logo":{"@type":"ImageObject","url":"http://naivertc.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="MarkCao" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Objective-C</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-10-07T15:06:07.000Z" title="10/7/2017, 11:06:07 PM">2017-10-07</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">an hour read (About 8632 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/10/07/Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Effective Objective-C 2.0读书笔记</a></h1><div class="content"><h3 id="第1章-熟悉Objective-C"><a href="#第1章-熟悉Objective-C" class="headerlink" title="第1章 熟悉Objective-C"></a>第1章 熟悉Objective-C</h3><h4 id="1-了解Objective-C语言的起源"><a href="#1-了解Objective-C语言的起源" class="headerlink" title="1: 了解Objective-C语言的起源"></a>1: 了解Objective-C语言的起源</h4><ul>
<li>Objective-C语言是由Smalltalk演化而来，后者是消息型语言的鼻祖。</li>
<li>消息机构的语言，不论是否多态，其运行时所执行的代码都由运行环境来决定；而使用函数调用的语言则由编译器决定，但调用函数是多态的，则是在运行时通过查询“虚方法表（virtual table）”决定具体执行函数。</li>
<li>如果只需要保存int、flot、double、char等非对象类型，通常使用CGRect这种结构体，因为结构体可以使用栈空间，而不用分配和释放堆空间，避免额外开销。</li>
</ul>
<h4 id="2-在类的头文件中尽量少引用其他头文件"><a href="#2-在类的头文件中尽量少引用其他头文件" class="headerlink" title="2: 在类的头文件中尽量少引用其他头文件"></a>2: 在类的头文件中尽量少引用其他头文件</h4><ul>
<li>除非确实有必要，否则不要引入头文件，尽量使用向前声明，这样不但可以缩短编译时间和降低类之间的耦合。</li>
<li>如果无法使用向前声明，比如要声明某个类遵循一项协议。尽量把所遵循的协议移至实现文件中的匿名分类。如果必须在头文件引入协议头文件，则把协议单独放在一个头文件中。</li>
</ul>
<h4 id="3-多用字面量语法，少用与之对等的方法"><a href="#3-多用字面量语法，少用与之对等的方法" class="headerlink" title="3: 多用字面量语法，少用与之对等的方法"></a>3: 多用字面量语法，少用与之对等的方法</h4><ul>
<li>使用字面量语法创建字符串、数值、数组、字典更为简单扼要。</li>
<li>使用取下标操作访问数组下标或者字典中的键对应的元素。</li>
<li>使用字面量语言更为安全，遇到nil对象会抛出异常。</li>
<li>字面量语法的限制：除了字符串以外，所创建出来的对象必须属于Foundation框架才行。</li>
</ul>
<h4 id="4-多用类型常量，少用-define预处理指令"><a href="#4-多用类型常量，少用-define预处理指令" class="headerlink" title="4: 多用类型常量，少用#define预处理指令"></a>4: 多用类型常量，少用#define预处理指令</h4><ul>
<li>若常量局限于某个实现文件之内，则前面加字面k，若常量在类之外，则通常以类名为前缀。</li>
<li>static修饰符意味着变量仅在定义此变量的编译单元中可见，在Objective-C的语境下，编译单元通常指每个类的实现文件，即以.m为后缀名。</li>
<li>常量必须使用const修饰符声明，常量定义从右至左解读，下面例子中定义了一个常量指针，const修饰的是指针，指向NSString对象。<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果一个变量同时声明为static和const,那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值。</li>
<li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中，因此通常与之相关的类名做前缀加以区分。</li>
</ul>
<h4 id="5：用枚举表示状态、选项、状态码"><a href="#5：用枚举表示状态、选项、状态码" class="headerlink" title="5：用枚举表示状态、选项、状态码"></a>5：用枚举表示状态、选项、状态码</h4><ul>
<li>C++11标准修订了枚举的某些特性，其中包括可以指定何种“底层数据类型”来保存枚举类型的变量。这样做的好处是可以向前声明枚举变量了，如果编译器不清楚底层数据类型就不知道分配空间大小。</li>
<li>如果枚举类型是多个选项且同时使用，那么久将各选项值定义为2的幂，以便按位或操作进行组合。</li>
<li>用NS_ENUM与NS_OPTION宏来定义枚举类型，并指明其底层数据类型，这样确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的switch语句中不要实现default分析，这样加入新的枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li>
</ul>
<h3 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h3><h4 id="第6条：-理解“属性”这一概念"><a href="#第6条：-理解“属性”这一概念" class="headerlink" title="第6条： 理解“属性”这一概念"></a>第6条： 理解“属性”这一概念</h4><ul>
<li>使用@property语法编译器会自动创建一套存取方法，因此访问属性实质上就是调用存取函数，走消息派发流程。</li>
<li>@synthesize语言可以指定属性实例变量的名字，默认的属性名前加下划线。</li>
<li>@dynamic关键字可以阻止属性创建实例变量和存取方式，编译器即使在编译过程中没有发现该属性的存取方法也不会保存，而是相信这些方法在运行期能够找到。</li>
<li>原子性只能确保每次都能获取属性的有效值，即确保属性修改完成再被其他线程访问，但是不能确保线程安全。</li>
<li>处于性能考虑，iOS程序所有属性都是nonatomic，Mac OS X程序使用atomic属性通常不会有性能瓶颈。</li>
<li>对应一个属性定义的变量来说，直接访问实例变量会绕开指定的属性特质和消息派发流程。</li>
</ul>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>使用“点语法”（本质上使用实例变量存取方法）与直接访问实例变量的区别：<ul>
<li>直接访问实例变量不经过Objective-C的消息派发流程，因此速度比点语法快。</li>
<li>直接访问实例变量不会调用属性配置的存取方法，从而绕过了属性指定的相关特质。</li>
<li>直接访问实例变量不会触发“键值观测KVO”通知，因为键值观测是建立在存取方法之上的。</li>
</ul>
</li>
<li>在初始化方法和dealloc中尽量直接访问实例变量，因为子类可能覆写父类属性的存取方法，从而无法输出预期。</li>
<li>在对象内部读取数据时，应该直接通过实例变量来读，除惰性初始化技术之外。而写入数据时则应通过属性来写。</li>
</ul>
<h4 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h4><ul>
<li>检测对象的等同性，必须提供“isEqual:”和hash方法。相等的对象hash值必须相同，但是has值相同的对象未必相等。</li>
<li>计算hash值时应考虑减少碰撞。因为collection检索哈希表时会用对象的哈希值作为索引。hash方法的高效与低碰撞率可以使collection减少开销。</li>
<li>等同性判定的执行深度根据具体的对象决定，不一定将整个对象进行判定，有时候只需要判定代表对象唯一性的值即可。</li>
<li>在容器中放入可变类对象时，确保对象加入后就不再改变哈希值，否则容易造成未知行为。</li>
</ul>
<h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>
<li>类簇模式可以把实现细节隐藏在一套简单的公共接口后面。</li>
<li>系统框架中经常使用类簇，比如NSArray、NSNumber等。</li>
<li>从类簇的公共抽象基类中继承子类时，遵循几条规则：<ul>
<li>子类应该继承自类簇中的抽象基类。</li>
<li>子类应该定义自己的数据存储方式。</li>
<li>子类应当覆写超类文档中指明需要覆写的方法。</li>
</ul>
</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul>
<li>使用关联对象可以将两个对象以属性的方式关联起来，并指定类似于@property的内存管理语义和存储策略。</li>
<li>设置关联对象的键值是个“不透明指针”，若想令两个键值匹配到同一个值，二者必须是完全相同的指针才行。鉴于此，设置关联对象值时通常使用静态全局变量做键值。</li>
<li>由于关联对象容易引入难于排查的bug，所以不要轻易使用。</li>
</ul>
<h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><ul>
<li>objc_msgSend通过在运行期搜索接收者类的方法列表实现“动态绑定”，以选择子为key值搜索函数指针。</li>
<li>函数原型与objc_msgSend函数很像，在objc_msgSend函数内部搜索到选择子对应的函数并在函数最后return语句调用，利用“尾调用优化”进行优化。</li>
</ul>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><ul>
<li>消息转发分两大阶段：动态方法解析和完整的消息转发机制（分两阶段）</li>
<li>动态方法解析：实例对象收到无法解析的消息会触发类方法：+（BOOL）resolveInstanceMethod:(SEL)selector，如果是类对象对应的类方法为：+（BOOL）resolveClassMethod:(SEL)selector。在这个方法中可以通过class_addMethod动态插入方法，所添加的方法是用纯C函数（IMP指针）。</li>
<li>完整的消息转发机制第一阶段：调用函数-(id)forwardingTargetForSelector:(SEL)selector，看是否能把消息转发其他对象处理。通过此方案可以用“组合”来模拟”多重继承“的某些特性。</li>
<li>完整的消息转发机制第二阶段：- (void)forwardInvocation:(NSInvocation *)invocation;此阶段可以在转发消息前修改消息内容。若本类不处理，则需调用父类同名方法。</li>
</ul>
<p>###第4章 协议与分类</p>
<h4 id="23：通过委托与数据源协议进行对象间通信"><a href="#23：通过委托与数据源协议进行对象间通信" class="headerlink" title="23：通过委托与数据源协议进行对象间通信"></a>23：通过委托与数据源协议进行对象间通信</h4><ul>
<li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</li>
<li>当某对象需要从另外一个对象中获得数据时，可以使用委托模式【数据源协议】。</li>
<li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li>
</ul>
<h4 id="24：将类的实现代码分散到便于管理的数个分类之中"><a href="#24：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24：将类的实现代码分散到便于管理的数个分类之中"></a>24：将类的实现代码分散到便于管理的数个分类之中</h4><ul>
<li>使用分类机制将类的实现代码划分成易于管理的小块</li>
<li>将应该视为“私有”的方法归入名叫private的分类中，以隐藏实现细节。</li>
</ul>
<h4 id="25：总是为第三方类的分类名称加前缀"><a href="#25：总是为第三方类的分类名称加前缀" class="headerlink" title="25：总是为第三方类的分类名称加前缀"></a>25：总是为第三方类的分类名称加前缀</h4><ul>
<li>分类机制通常用于向无源代码的既有类中增加新功能，且分类中的方法会覆盖既有类的同名方法，后一个分类会覆盖前一个分类的同名方法。</li>
<li>为了减少同名函数覆盖的概率，以命名空间来区分各个分类的名称与其中所定义的方法，在Objective-C中实现命名空间的方法就是给分类名和函数名添加专用的前缀。</li>
</ul>
<h4 id="26：勿在分类中声明属性"><a href="#26：勿在分类中声明属性" class="headerlink" title="26：勿在分类中声明属性"></a>26：勿在分类中声明属性</h4><ul>
<li>属性是封装数据的方式，尽管可以通过关联对象的方式合成实例变量，但是建议最好全部在主接口中实现，分类的作用在于扩展类的功能，而非封装数据</li>
<li>除了“class-continuation分类【匿名分类】”之外可以定义属性，其他分类最好只定义方法</li>
</ul>
<h4 id="27：使用“class-continuation分类”隐藏实现细节"><a href="#27：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="27：使用“class-continuation分类”隐藏实现细节"></a>27：使用“class-continuation分类”隐藏实现细节</h4><ul>
<li>匿名分类可以定义方法和实例变量，原因在于“稳固的ABI”机制（详见第6条）</li>
<li>在实现块中添加匿名分类可隐藏实现细节，即私有变量和方法。</li>
<li>编译objective-C++时，在匿名分类中定义c++相关的变量，从而避免了因为在头文件中声明C++变量，进而导致凡是引用该类的其他类都必须改为Objective-C++类。</li>
<li>利用匿名分类扩展头文件中声明为“只读”的属性为“可读写”状态</li>
<li>利用匿名分类隐藏该类遵循的协议。</li>
</ul>
<h4 id="28：通过协议提供匿名对象"><a href="#28：通过协议提供匿名对象" class="headerlink" title="28：通过协议提供匿名对象"></a>28：通过协议提供匿名对象</h4><ul>
<li>使用协议可将具体的对象类型谈化成遵循某种协议的id类型，协议中规定了对象需实现的方法</li>
<li>如果对象类型不重要，重要的是对象是否实现了某些方法，此时可用“匿名对象”来实现这一概念，与Python的“鸭子类型”有点相似。</li>
</ul>
<p>###第5章 内存管理</p>
<h4 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h4><ul>
<li>悬挂指针：对象在release之后，内存被放回“可用内存池”，但是不一定保证马上被回收，此时指针属于悬挂指针，容易导致crash。</li>
<li>为了避免不经意间使用了悬挂指针，在调用完release之后清空指针</li>
<li>autorelease能延长对象生命周期，使其在跨越方法调用边界后依然跨越存活一段时间，释放操作会在清空最外层自动释放池时执行，即在当前线程进入下一次事件循环时释放。</li>
<li>通常采用“弱引用”来避免循环引用发生，从而避免内存泄漏</li>
</ul>
<h4 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h4><ul>
<li>Clang的静态分析器（static analyzer）不但可以指明程序中引用计数出现问题的地方，还能根据需要预先加入适当的retain和release操作以避免这些问题。自动引用计（ARC）数的思路也是源于此。</li>
<li>ARC在执行retain、release和autorelease等操作时，不是通过普通的Objective-C消息派送机制，而是直接调用其对应的C语言版本，这样效率更高。</li>
<li>ARC通过命名约定将内存管理标准化，方法名以下列词语开头，其返回的对象归调用者所有：<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy<br>否则，返回对象会自动释放，即相当于执行autorelease操作.</li>
</ul>
</li>
<li>在编译期和运行期，ARC都把能够相互抵消的retain、release、autorelease操作约简。</li>
<li>运行期，为了优化代码，在方法返回自动释放的对象时，调用objc_autoreleaseReturnValue,此函数会检视当前函数调用的代码是否需要对返回对象执行retain操作，如果是则设置一个全局标志位。而不执行autorelease操作；与只对应的是在调用代码如果要保留对象，则不执行retain操作，而是调用objc_retainAutoreleasedRetuenValue.此函数检测之前设置的全局标志位，如果已经置位，则不执行retain操作。</li>
<li>ARC环境优化方式具体实现由编译器决定，比如将全局标志位存储在STL(Thread Local Storage:线程局部存储，以key-value的形式读写)中，STL只适用于调用和被调用方都是ARC模式的情况，使用__builtin_return_address可以在被调用函数中获得调用函数的栈空间，进而可以推算出调用方后续操作是否调用了objc_retainAutoreleasedReturnValue，如果调用则是ARC环境，反之使用没优化的老逻辑。</li>
<li>变量的内存管理的边界问题，在设置变量值时，需要先保留新值，释放旧值，最后设置实例变量，确保即便是新值与旧值是同一对象也不能引发错误。在ARC情况下，无需考虑这种“边界情况”</li>
<li>ARC下清理实例变量是借用Objective-C++的析构函数实现的，不需要重载dealloc，如果存在CoreFoundation等非Objective-C对象时，只需在dealloc函数中执行CFRetain/CFRelease等释放操作，而不需要调用超类的dealloc方法。</li>
</ul>
<h4 id="第31条：合理使用dealloc方法"><a href="#第31条：合理使用dealloc方法" class="headerlink" title="第31条：合理使用dealloc方法"></a>第31条：合理使用dealloc方法</h4><ul>
<li>在dealloc中只释放对其他对象的引用，解除监听和取消订阅的KVO等，不要做其他事情</li>
<li>不要在dealloc中释放开销大或系统内稀缺资源，如文件描述符、套接字以及大块内存等，因为这些资源可能被其他对象持有，不宜保留过长时间，而是实现一个专门用于清理的函数，如close等</li>
<li>出于优化效率的目的，系统不能保证每一个对象的dealloc都会执行</li>
<li>不应在dealloc中调用执行异步任务的方法或只能在正常状态下执行的方法，因为dealloc所在的线程会执行final release。</li>
</ul>
<h4 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h4><ul>
<li>MRC环境下，在@try中创建的对象应在@finaly中释放而非@try中，以避免因抛出异常导致内存泄漏</li>
<li>ARC环境下，出于对运行期的性能考虑默认情况下是不会处理异常捕获过程中出现的内存泄漏情况。</li>
<li>ARC环境下，可以通过-fobjc-arc-exceptions这个编译标志开启安全处理异常功能，默认情况是关闭的，但是出于Objectve-C++模式下会自动打开。</li>
</ul>
<h4 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h4><ul>
<li>虽然垃圾回收机制可以检测并回收保留环，但是Mac OS X 10.8之后以及iOS平台不支持这个功能</li>
<li>MRC环境下，使用unsafe_unretained（表明属性不安全且不归实例所拥有）或者weak属性来避免保留环，且效果等同</li>
<li>ARC环境下，weak属性在修饰对象被回收后自动清空，更为安全，避免访问悬挂指针。</li>
</ul>
<h4 id="第34条：以“自动释放池块”降低内存峰值"><a href="#第34条：以“自动释放池块”降低内存峰值" class="headerlink" title="第34条：以“自动释放池块”降低内存峰值"></a>第34条：以“自动释放池块”降低内存峰值</h4><ul>
<li>GCD或主线程都默认自带自动释放池。</li>
<li>自动释放池是以栈的形式存在的，对象收到autorelease消息后，会被放入最近的自动释放池的栈顶。</li>
<li>合理运用自动释放池，用以降低应用程序的内存峰值，如for循环中。</li>
<li>ARC环境下的@autoreleasepool比MRC环境下NSAutoreleasepool更为轻便与安全。</li>
</ul>
<h4 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h4><ul>
<li>向已回收的对象发送消息是不安全与不稳当的，如果内存已经被复用且复用的对象不能响应此消息则会crash，如果复用对象能够响应消息也许输出不能达到预期，如果内存部分存活则可能消息可能依然有效。</li>
<li>“僵尸对象”是调试内存管理问题最佳方式。</li>
<li>僵尸类是从名为_NSZombie_的模板类复制而来，通过创建一个名为_NSZombie_原类名的新类，再将已回收对象的指针指向新类，原对象的类变了，但是内存结构不变，便于调试。示例代码：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line"><span class="keyword">if</span> (!zombieCls) {</span><br><span class="line">	<span class="keyword">class</span> baseZomeCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</span><br><span class="line">	zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Perform normal destruction of the object being deallocated</span></span><br><span class="line">objc_destructInstance(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//Set the class of the object being deallocated to the zombie class</span></span><br><span class="line">objc_setClass(<span class="keyword">self</span>, zombieCls);</span><br></pre></td></tr></tbody></table></figure>
<p>代码的关键在于：对象的内存没有释放，因此这块内存不可被其他对象复用，虽然会造成内存泄漏，但是出于调试的目的可以忽略。</p>
<ul>
<li>僵尸类的作用是通过消息转发机制体现，因为僵尸类没有实现任何方法，和Object一样是根类，只有一个实例变量isa。在消息转发机制通过类名检测到当前对象是一个僵尸对象时会进行特殊处理：打印原类的相关信息，然后终止程序。示例代码：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="comment">//If so, this is a zombie</span></span><br><span class="line"><span class="keyword">if</span> (string_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) {</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd));</span><br><span class="line">	</span><br><span class="line">	Log(<span class="string">"*** - [%s %s]: message sent to deallocated instance %p"</span> , originalClsName, selectorName, <span class="keyword">self</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h4><ul>
<li>retainCount返回的保留计数只是某个给定时间点上的值，并未考虑到对象加入自动释放池的情况，因此不能反映真实的保留计数。</li>
<li>有时系统出于优化的目的，retainCount可能永远都不返还0，在保留计数为1的时候就被回收了。</li>
</ul>
<p>###第6章 块与大中枢派发</p>
<p>####第37条 理解“块”这一概念</p>
<ul>
<li>块在定义与使用方面与函数类似，但是块本身是一个对象，有引用计数。</li>
<li>在块中直接访问实例变量，虽没有显性使用self，但是self变量还是会被块捕获。</li>
<li>块的内存结构中，最重要的是invoke函数指针，指向块的实现代码，第一个void *参数指代块，用于访问块对象所捕获的变量。此外descriptor变量指向结构体指针，每个块里都包含此结构体，其中声明了块对象的总大小和copy与dispose两个辅助函数的指针。</li>
<li>根据内存位置分为全局块、栈块和堆块。</li>
<li>栈块只在定义氛围有效，下述代码存在一个比较隐蔽的错误，存在危险：块的内存都分配在if及else范围内，在离开相应范围后如果编译器覆写了分配给块的内存则会导致crash，否则正常运行。</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">	block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); };</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">	block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//解决方式：将块拷贝到堆中，成为堆块</span></span><br><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">	block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">	block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="6">
<li>在全局范围声明的块及为全局块，其所使用的内存区域也在编译器全部确定。</li>
</ol>
<h4 id="第38条-为常用的块类型创建typedef"><a href="#第38条-为常用的块类型创建typedef" class="headerlink" title="第38条 为常用的块类型创建typedef"></a>第38条 为常用的块类型创建typedef</h4><ul>
<li>以typedef重新定义块类型，可令块变量用起来更简单</li>
<li>定义新类型时应遵循现有的命名习惯，勿使其名称与别的类型相冲突。</li>
<li>可以为同一个块签名定义多个类型的别名，便于理解类型的用途。</li>
</ul>
<h4 id="第39条-用handler块降低代码分散程度"><a href="#第39条-用handler块降低代码分散程度" class="headerlink" title="第39条 用handler块降低代码分散程度"></a>第39条 用handler块降低代码分散程度</h4><ul>
<li>异步任务执行完成之后，可使用委托协议或者内联块。相比于委托代理，块更为简洁和聚合。</li>
<li>建议使用同一个块来处理成功与失败的情况。</li>
<li>设计API时如果用的了handler块，可以增加一个参数，使调用者可通过此参数来决定块执行的队列。</li>
</ul>
<h4 id="第40条-用块引用其所属对象时不要出现保留环"><a href="#第40条-用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条 用块引用其所属对象时不要出现保留环"></a>第40条 用块引用其所属对象时不要出现保留环</h4><ul>
<li>如果块所捕获的对象直接或者间接地保留了块本身，那么得注意是否存在保留环的问题。</li>
<li>一定要找个适当的时机解除保留环，而不能把责任推给API调用者。</li>
<li>网络下载器可在任务启动时将自己加入全局的容器对象中，在任务结束后移除，从而保证自己在任务执行期间存活的同时不需要API调用方引用，大部分网络通信库都是采用这办法，如Twitter框架的TWRequest对象。</li>
</ul>
<h4 id="第41条-多用派发队列，少用同步锁"><a href="#第41条-多用派发队列，少用同步锁" class="headerlink" title="第41条 多用派发队列，少用同步锁"></a>第41条 多用派发队列，少用同步锁</h4><ul>
<li>同步块@synchronized(obj)会根据给定对象自动创建一个锁，锁在代码块执行完成释放。由于给定对象相同，那么意味着它们使用的同一个锁，代码块需按顺序执行。如果在两个或多个没有逻辑关联的代码块给同一个对象加锁，会影响执行效率。</li>
<li>滥用@synchronized(self)很危险，因为所有同步块都会彼此抢夺同一个锁。示例：使用@synchronized实现属性的原子性（atomic）：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">return</span> _someString;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		_someString = someString;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果有很多属性都是类似写法，那么每个属性的同步块都要等其他同步块执行完成才能执行。理想情况应该是属性各自独立地同步。</p>
<ul>
<li>使用GCD实现属性原子性：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">		localSomeString = _someString;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{  </span><br><span class="line">		_someString = someString;</span><br><span class="line">	});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>GCD版本优化：设置方法不需要返回值，所以并不一定非得同步；获取方法可以并发执行，且设置方法与获取方法之间不能并执行。</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//异步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">		localSomeString = _someString;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//异步队列+异步派发（同步派发可能效率更高，原因在于异步派发需要拷贝块，如果拷贝时间超过代码执行时间，则得不偿失。异步派发适合较为复杂的任务）+栅栏块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="comment">//栅栏块会单独执行，执行前会等待当前所有并发块执行完成，避免出现读写竞赛</span></span><br><span class="line">	dispatch_barrier_async(_syncQueue, ^{  </span><br><span class="line">		_someString = someString;</span><br><span class="line">	});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h4 id="第42条-多用GCD，少用performSelector系列方法"><a href="#第42条-多用GCD，少用performSelector系列方法" class="headerlink" title="第42条 多用GCD，少用performSelector系列方法"></a>第42条 多用GCD，少用performSelector系列方法</h4><ul>
<li>performSelector系列方法在内存管理方面容易有疏忽，由于无法确认将要执行的选择子是什么，因而ARC编译器无法插入适当的内存管理方法。</li>
<li>performSelector系列方法所能处理的选择子有局限性，选择子的参数个数与类型以及返回类型都受到限制。</li>
</ul>
<h4 id="第43条-掌握GCD及操作队列的使用时机"><a href="#第43条-掌握GCD及操作队列的使用时机" class="headerlink" title="第43条 掌握GCD及操作队列的使用时机"></a>第43条 掌握GCD及操作队列的使用时机</h4><ul>
<li>对于只需要执行一次的代码来说，GCD的dispatch_once是首选，但是执行后台任务则可以考虑NSOperationQueue。</li>
<li>在iOS4与Mac OSX 10.6开始，操作队列在底层是用GCD来实现的。</li>
<li>GCD是纯C的API，任务使用轻量级数据结构块来表示；操作队列则是Objective-C的对象，采用更为重量级的NSOperation对象执行任务。</li>
<li>使用操作队列的优势：<ul>
<li>可取消还未启动的任务</li>
<li>可指定操作间的依赖关系</li>
<li>可通过键值观测机制监控NSOperation对象的属性</li>
<li>可指定操作的优先级，而GCD只能指定队列的优先级</li>
<li>可重用NSOperation对象</li>
</ul>
</li>
<li>是否使用底层实现方案还是高层API，可通过实际性能测试来确定。</li>
</ul>
<h4 id="第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条 通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第44条 通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul>
<li>一系列的任务可归入一个dispatch group中，开发者可以在所有任务完成后获得通知</li>
<li>利用dispatch group并发地执行多项任务。</li>
<li>dispatch_apply是持续阻塞的，直到所有任务都执行完成。</li>
</ul>
<h4 id="第45条-使用dispatch-once来执行只需要运行一次的线程安全代码"><a href="#第45条-使用dispatch-once来执行只需要运行一次的线程安全代码" class="headerlink" title="第45条 使用dispatch_once来执行只需要运行一次的线程安全代码"></a>第45条 使用dispatch_once来执行只需要运行一次的线程安全代码</h4><ul>
<li>dispatch_once采用“原子访问”来判断块中的代码是否已经执行过，而非使用重量级的同步机制，相比于@sychronized更为高效，如果想了解@synchronized的实现机制可以看看<a target="_blank" rel="noopener" href="http://icebergcwp.com/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html">这篇博客</a>。</li>
<li>标记dispatch_once_t应该声明为static，确保每次调用都复用同一个变量。</li>
</ul>
<h4 id="第46条-不要使用dispatch-get-current-queue"><a href="#第46条-不要使用dispatch-get-current-queue" class="headerlink" title="第46条 不要使用dispatch_get_current_queue"></a>第46条 不要使用dispatch_get_current_queue</h4><ul>
<li>dispatch_get_current_queue已被废弃，只应做调试使用</li>
<li>派发队列是按层级来组织的，子队列是包含于父队列的，所以无法单用某个队列对象来描述“当前队列”这一概念</li>
<li>dispatch_get_current_queue用于解决由不可重入代码所引发的死锁，可以使用“队列特定数据”来解决：dispatch_queue_set_specific(dispatch_queue_t queue,const void *key, void *context, dispatch_function_t destructor);</li>
</ul>
<h3 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h3><ul>
<li>标准根类NSObject属于Foundation框架，而非语言本身。如果不适应Foundation框架，则需要自己实现根类</li>
</ul>
<h4 id="第47条-熟悉系统框架"><a href="#第47条-熟悉系统框架" class="headerlink" title="第47条 熟悉系统框架"></a>第47条 熟悉系统框架</h4><ul>
<li>在众多框架中，Foundation和CoreFoundation这两个框架最为重要，提供了许多核心功能</li>
<li>Objective-C编程经常会使用纯C实现的框架，比如CoreFoundation，里面用到底层C语言级API，这样可以绕过运行时系统，提升速度，但是需要手动管理内存。</li>
</ul>
<h4 id="第48条-多用块枚举，少用for循环"><a href="#第48条-多用块枚举，少用for循环" class="headerlink" title="第48条 多用块枚举，少用for循环"></a>第48条 多用块枚举，少用for循环</h4><ul>
<li>遍历collection有四种方式。最基础的是for循环，其次是NSEnumerator遍历和NSFastEnumeration协议下的快速遍历，最快、最先进的方式是“块枚举发”</li>
<li>“块枚举法”本身能够通过GCD来并发执行遍历，无须另行代码，其他遍历方式则不能做到这一点</li>
<li>如果提前知道遍历collection中的对象，应修改块签名，指出对象的具体对象。</li>
</ul>
<h4 id="第49条-对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条 对自定义其内存管理语义的collection使用无缝桥接"></a>第49条 对自定义其内存管理语义的collection使用无缝桥接</h4><ul>
<li>Foundation框架中的collection类都有与之对应的CoreFoundation框架版的C语言API</li>
<li>桥接符号__bridge表示ARC保留对Objective对象的所有权，而__bridge__retain则刚好相反，需要使用CFRelease释放内存。</li>
<li>使用CoreFoundation框架可以创建出Foundation框架所不具备的功能，比如NSDictionary的键值内存管理语义是“copy”，即键值必须支持Copying协议，使用CoreFoundaition创建一个键值内存管理语义为“Retain”的CFDictionary。</li>
</ul>
<h4 id="第50条-构建缓存时选用NSCache而非NSDictionary"><a href="#第50条-构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第50条 构建缓存时选用NSCache而非NSDictionary"></a>第50条 构建缓存时选用NSCache而非NSDictionary</h4><ul>
<li>实现缓存时应选NSCache而非NSDictionary对象。NSCache提供了优雅的自动删减功能，而且线程安全。此外，它与字典不同，不会拷贝键值，而是retain一次。</li>
<li>可以给Cache对象设置上限：缓存对象总个数和缓存总大小，这些设置定义了缓存删减其中对象的时机。但是这些设置仅对Cache起指导作用，并非一定在系统资源紧张时删减Cache中的某个对象，因此不能通过设置上限来迫使Cache优先删减某个对象。</li>
<li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据功能，也就是说当NSPurgeableData对象所占内存被系统丢弃时，对象也会从缓存中移除。</li>
<li>缓存的设计初衷是为了提高响应速度，只有那些“重新计算起来费劲”的数据才值得放入缓存，比如网络获取或者磁盘读取的数据。</li>
</ul>
<h4 id="第51条-精简-initialize与-load的实现代码"><a href="#第51条-精简-initialize与-load的实现代码" class="headerlink" title="第51条 精简+initialize与+load的实现代码"></a>第51条 精简+initialize与+load的实现代码</h4><ul>
<li>在加载过程中，如果类实现了+load方法，那么系统会通过函数指针调用+load。调用顺序是父类-&gt;子类-&gt;分类。因为程序加载时是使用函数指针调用而非消息机制，所以分类中的+load不会覆盖子类中的+load方法。         </li>
<li>程序启动时，运行期处于“脆弱状态（fragile state）”，如果+load方法中使用了其他非系统库（系统库的类在这之前已经加载好了）的类，那么这些类的+load方法也在此时被调用。如果子类没有实现+load方法，那么各级超类是否实现此方法都不被系统调用。</li>
<li>+load方法务必实现的精简一些，因为整个程序在+load方法时都会阻塞。其真正的用途在于调试程序。</li>
<li>+initialize方法会在程序首次调用该类之前调用，只调用一次，如果某个类未被使用，那么其+initialize方法一直不会被调用。</li>
<li>+initialize方法被调用时，运行期系统已经处于正常状态，理论上可以在其中调用任何类的任意公开方法，且是线程安全的。</li>
<li>+initialize方法与其他消息一样，如果子类未实现它而其超类实现了，那么会子类也会调用一次超类的实现方法。 </li>
<li>无法再编译器设定的全局变量，可以放在+initilize方法中初始化。</li>
</ul>
<h4 id="第52条-别忘了NSTimer会保留其目标对象"><a href="#第52条-别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条 别忘了NSTimer会保留其目标对象"></a>第52条 别忘了NSTimer会保留其目标对象</h4><ul>
<li>NSTimer对象会保留其目标，知道计时器调用invalidate方法后失效为止。另外，一次性的计数器在触发任务后就会立即失效。</li>
<li>反复执行任务的计时器，很容易引入保留环，可通过扩充NSTimer功能，用块来打破保留环。代码如下：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats;</span><br><span class="line">+ </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats {</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimerInterval:interval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(eoc_blockInvoke:) userInfo:[block <span class="keyword">copy</span>] repeats:repeats];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eco_blockInvoke:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line">	<span class="keyword">void</span>(^block)() = timer.userInfo;</span><br><span class="line">	<span class="keyword">if</span> (block) {</span><br><span class="line">		block();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```                    </span><br><span class="line">这个方法仍然存在保留环，计时器现在的target是<span class="built_in">NSTimer</span>类对象，但是因为类对象无需回收，所以不用担心。</span><br><span class="line"></span><br><span class="line">* 上述方法本身不能解决问题，但是提供了解决问题的工具。使用分类中的eoc_scheduledTimerWithTimeInterval来创建计时器：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">void</span>)startPolling {</span><br><span class="line">	__<span class="keyword">weak</span> type(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">	_pollTimer = [<span class="built_in">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class="number">1.0</span> block:^{ </span><br><span class="line">	EOCClass *strongSelf = weakSelf;</span><br><span class="line">	[strongSelf p_doPoll]; </span><br><span class="line">	} repeats:<span class="literal">YES</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-06-11T14:28:07.000Z" title="6/11/2017, 10:28:07 PM">2017-06-11</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">28 minutes read (About 4143 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/11/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">剖析@synchronizd底层实现原理</a></h1><div class="content"><p>@synchronizd是Objective-C中的一个语法糖，用于给某个对象加锁，因为使用起来简单方便，所以使用频率很高。然而，滥用@synchronizd很容易导致代码效率低下。本篇博客旨在结合@synchronizd底层实现源码并剖析其实现原理，这样可以更好的让我们在适合的情景使用@synchronizd。</p>
<p>@synchronizd本质上是一个编译器标识符，在Objective-C层面看不其任何信息。因此可以通过clang -rewrite-objc指令来获得@synchronizd的C++实现代码。示例代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"Iceberg"</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) {</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello,world! =&gt; %@"</span> , obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>{</span><br><span class="line">    </span><br><span class="line">    NSString *obj = (NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_0;</span><br><span class="line">    </span><br><span class="line">    {</span><br><span class="line">        id _rethrow = <span class="number">0</span>;</span><br><span class="line">        id _sync_obj = (id)obj;</span><br><span class="line">        <span class="built_in">objc_sync_enter</span>(_sync_obj);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">	            <span class="keyword">struct</span> <span class="title class_">_SYNC_EXIT</span> {</span><br><span class="line">	                _SYNC_EXIT(id arg) : <span class="built_in">sync_exit</span>(arg) {}</span><br><span class="line">	                ~_SYNC_EXIT() {</span><br><span class="line">	                    <span class="built_in">objc_sync_exit</span>(sync_exit);</span><br><span class="line">	                }</span><br><span class="line">	                id sync_exit;</span><br><span class="line">	            } _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_1 , obj);</span><br><span class="line">                </span><br><span class="line">            } <span class="built_in">catch</span> (id e) {</span><br><span class="line">                _rethrow = e;</span><br><span class="line">            }</span><br><span class="line">        </span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_FIN</span> {</span><br><span class="line">                _FIN(id reth) : <span class="built_in">rethrow</span>(reth) {}</span><br><span class="line">                ~_FIN() {</span><br><span class="line">                    <span class="keyword">if</span> (rethrow)</span><br><span class="line">                        <span class="built_in">objc_exception_throw</span>(rethrow);</span><br><span class="line">                }</span><br><span class="line">                id rethrow;</span><br><span class="line">            } _fin_force_rethow(_rethrow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过分析C++代码可以看到@sychronized的实现主要依赖于两个函数：objc_sync_enter和objc_sync_exit。此外还有try{}catch{}语句用于捕捉@sychronized{}语法块中代码执行过程中出现的异常。</p>
<p>我们发现objc_sync_enter函数是在try语句之前调用，参数为需要加锁的对象。因为C++中没有try{}catch{}finally{}语句，所以不能在finally{}调用objc_sync_exit函数。因此objc_sync_exit是在_SYNC_EXIT结构体中的析构函数中调用，参数同样是当前加锁的对象。这个设计很巧妙，原因在_SYNC_EXIT结构体类型的_sync_exit是一个局部变量，生命周期为try{}语句块，其中包含了@sychronized{}代码需要执行的代码，在代码完成后，_sync_exit局部变量出栈释放，随即调用其析构函数，进而调用objc_sync_exit函数。即使try{}语句块中的代码执行过程中出现异常，跳转到catch{}语句，局部变量_sync_exit同样会被释放，完美的模拟了finally的功能。</p>
<p>接下来，在<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm">苹果公开的源代码文件objc-sync.mm</a>中找到objc_sync_enter和objc_sync_exit这两个函数的实现，一窥其中的奥秘。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncData</span> {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SyncData</span>* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">//当前加锁的对象</span></span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">//使用对object加锁的线程个数</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex; <span class="comment">//递归互斥锁</span></span><br><span class="line">} SyncData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockCount;  <span class="comment">//表示当前线程对object对象加锁次数</span></span><br><span class="line">} SyncCacheItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncCache</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocated;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> used;</span><br><span class="line">    SyncCacheItem list[<span class="number">0</span>];</span><br><span class="line">} SyncCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SyncList</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SyncList</span>() : <span class="built_in">data</span>(nil) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码是一些相关的数据结构，下面分别进行介绍：</p>
<p>SyncData结构体中有四个成员变量，其中object指针变量指向当前加锁对象，threadCount表示对object加锁的线程个数，mutex是一个递归互斥锁，意味着可以对object进行多次加锁，其具体作用后面会提到。</p>
<p>SyncCacheItem结构体中有两个成员变量，其中data是SyncData结构体类型的指针，lockCount表示当前线程对当前结构体对象加锁次数，其实就是对加锁对象object的加锁次数。我们可以看到SyncCacheItem与SyncData是一对一关系，SyncCacheItem只是对SyncData进行了再次封装以便于缓存，具体使用见后文。</p>
<p>SyncCache结构体中有三个成员变量，其中维护了一个SyncCacheItem类型的数组，allocated和used则分别表示当前分配的SyncCacheItem数组中的总个数和已经使用的个数。这个结构体与线程是一对一的关系，用于存储当前线程已加锁对象对应的SyncCacheItem结构体，因为一个线程可以对同一个对象多次加锁，所以通过引入缓存SyncCache可以提高效率，具体使用见后文。</p>
<p>SyncList结构体中有两个成员变量和一个构造函数，其中data是SyncData结构体类型的指针，lock是一个自旋锁。</p>
<p>sDataLists是一个全局StripedMap哈希列表，其中value为SyncList对象，key为加锁对象object指针进行hash后的值。StripedMap是一个C++模板类，其实现代码如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> { CacheLineSize = <span class="number">64</span> };</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_EMBEDDED</span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">8</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">64</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> {</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) { </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() {</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">assert</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，由于自己对C++模板类不熟悉，所以只能看个大概。其中有两个值得注意的地方，其中StripeCount表示哈希数组的长度，如果是嵌入式系统值为8，否则值为64，也就意味着哈希数组最大长度为64；函数indexForPointer为散列函数，算法不难，但是很巧妙，值得学习。</p>
<p>下面开始分析相关的函数实现，首先找到@sychronized直接调用的两个函数：objc_sync_enter和objc_sync_exit，代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, ACQUIRE);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) {</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">objc_sync_nil</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) {</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.<span class="built_in">tryUnlock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!okay) {</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不难发现，上述代码都调用了id2data函数来获取一个与obj对应的SyncData对象，然后使用该对象中的递归互斥锁分别进行加锁与解锁。至此@sychronized的大致实现过程已经很清晰了，本质上是为一个对象分配一把递归互斥锁，可以也是为什么可以反复使用@sychronized对同一个对象进行加锁的原因。那么@sychronized是如果管理这把互斥锁，以及是如何处理多个线程对同一个对象进行多次加锁的情况？很明显，一切奥秘都藏在id2data函数中，其代码如下所示：</p>
<ul>
<li>注：为了描述方便，下面将id2data函数的形参object描述为同步对象obejct。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//从全局哈希表sDataLists中获取object对应的SyncList对象</span></span><br><span class="line">	<span class="comment">//lockp指针指向SyncList对象中自旋锁</span></span><br><span class="line">	<span class="comment">//listp指向一条SyncData链表，因为C++ STL中的哈希表处理地址冲突的方法是链地址法</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lockp = &amp;<span class="built_in">LOCK_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData **listp = &amp;<span class="built_in">LIST_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class="line">	<span class="comment">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class="line">	<span class="comment">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="comment">//用于标识当前线程的是否已使用fastCache</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    <span class="comment">//直接调用tls_get_direct函数获取SyncData对象</span></span><br><span class="line">    SyncData *data = (SyncData *)<span class="built_in">tls_get_direct</span>(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) {</span><br><span class="line">    	 <span class="comment">//标识fastCache已被使用</span></span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line">		 <span class="comment">//比较fastCache中的SyncData对象中的object与当前同步对象object是否为同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) {</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">   			  <span class="comment">//fastCache中的对象恰好是当前同步对象object，则后续处理直接使用fastCache中SyncData对象</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            <span class="comment">//获取当前线程对应当前SyncData对象已经加锁的次数</span></span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)<span class="built_in">tls_get_direct</span>(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data fastcache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">			  <span class="comment">//判断当前操作的加锁还是解锁</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: {</span><br><span class="line">                <span class="comment">//加锁一次</span></span><br><span class="line">                lockCount++;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                <span class="comment">//解锁一次</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="comment">//已加锁次数为0，表示当前线程对当前同步对象object达到锁平衡，因此不需要再持有当前同步对象。</span></span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    <span class="comment">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class="line">                    <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="comment">//此函数为原子操作函数，用于对32位的threadCount整形变量执行减一操作，且确保线程安全。因为可能存在同一时间多个线程对一个threadCount进行加减操作，避免出现多线程竞争。不同于lockCount，threadCount是多个线程共享的一个变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能。而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁。</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">//这是第二章缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class="line">    <span class="comment">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class="line">    SyncCache *cache = <span class="built_in">fetch_cache</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) {</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) {</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="comment">//当前同步对象object已存在的SyncCache中</span></span><br><span class="line">            <span class="comment">//获取对应的SyncData对象</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//后续操作同fastCache一样，参考fastCache的注释</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">			  </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class="line">    <span class="comment">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class="line">    lockp-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) {</span><br><span class="line">        	  <span class="comment">//哈希表中存在对应的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) {</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                <span class="comment">//此函数为原子操作函数，确保线程安全，用于对32位的threadCount整形变量执行加一操作，表示占用当前同步对象的线程数加1。</span></span><br><span class="line">                <span class="built_in">OSAtomicIncrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//用于标记一个空闲的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="comment">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="comment">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) {</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="comment">//关联当前同步对象</span></span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            <span class="comment">//重置占用线程为1</span></span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到这一步说明需要新建一个SyncData对象</span></span><br><span class="line">    result = (SyncData*)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(SyncData), <span class="number">1</span>);</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建递归互斥锁</span></span><br><span class="line">    <span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="built_in">recursive_mutex_t</span>();</span><br><span class="line">    <span class="comment">//以“入栈”的方式加入当前同步对象object对应的SyncData链表</span></span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line"> 	 <span class="comment">//对全局哈希表的操作结束，解锁</span></span><br><span class="line">    lockp-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="comment">//只有ACQUIRE才需要新建SyncData对象</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) {</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//fastCache缓存模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) {</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            <span class="comment">//直接缓存新建的SyncData对象</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            <span class="comment">//设置加锁次数为1</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		 <span class="comment">//SyncCache缓存模式，则直接加入SyncCacheItem数组中</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = <span class="built_in">fetch_cache</span>(YES);</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上述代码的注释，id2data函数的功能已经大致清晰。id2data函数主要是用于管理同步对象object与线程之间的关联。不论是ACQUIRE、RELEASE还是CHECK操作，都会先从当前线程的缓存中去获取对应的SyncData对象。如果当前线程的缓存区中不存在，那么再从全局的哈希数组中查找，查看其它线程是否已经占用过当前同步对象object。如果还是没有，那么就新建一个与之对应的SyncData对象，分别加入全局哈希表和当前线程缓存中。</p>
<p>至此，@synchronized的实现原理已经剖析结束，其有一个最大的特点是：不论是多个线性同一时间内对一个对象进行多次同步还是一个线程对同一个对象同步多次，一个对象只分配一把递归互斥锁。也就意味着对同一个对象而言，当执行某一次同步操作时，其他线程或同一线程的其他同步操作都会被阻塞，不言而喻，这种加锁方式的效率是很低的。</p>
<p>下面代码展示了@synchronized经典的使用案例之一：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject1:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember1 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject2:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember2 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject3:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember3 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码，调用其中一个设置函数时，另外两个成员变量的设置函数在同一时间被调用都会被阻塞。这里@synchronized同步的代码很简单，所以不会效率差别不大。如果是同步的代码需要执行较长的时间，且被多个线程并发调用，那么效率变得很低。如果不清楚@synchronized的实现原理，可能很难排查出来导致效率低下的问题所在。我建议使用GCD取代@synchronized实现同步功能，GCD不仅是线程安全，且其由底层实现，效率会好很多。我们发生@synchronized的底层实现有捕获异常的功能，因此适合在需要确保发生错误时代码不会死锁，而是抛出异常时使用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-02-12T14:28:07.000Z" title="2/12/2017, 10:28:07 PM">2017-02-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Cocoa/">Cocoa</a></span><span class="level-item">8 minutes read (About 1160 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/12/%E8%A7%A3%E9%99%A4NSTimer%E6%BD%9C%E5%9C%A8%E7%9A%84%E2%80%9C%E4%BF%9D%E7%95%99%E7%8E%AF%E2%80%9D%E9%97%AE%E9%A2%98/">解除NSTimer潜在的“保留环”问题</a></h1><div class="content"><p>NSTimer是Foundation框架中的一个使用频率很高的类，然而其调用过程中很容易引入潜在的“保留环“问题。可能是因为NSTimer的提供的API足够便利与顺手，以至于这个问题不容易被察觉到。这篇博客旨在阐述这个问题并提供解决方法。</p>
<p>以下的NSTimer提供的三个常用的创建或者初始化的API：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)t selector:(SEL)s userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)ui repeats:(<span class="built_in">BOOL</span>)rep <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这三个API有一个共同的点，即都需要提供一个target参数。这个target参数会被创建的NSTimer实例对象强引用一次，直到NSTimer实例对象调用invalidate方法后失效才释放。API文档原文如下：</p>
<blockquote>
<p>target: The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. </p>
</blockquote>
<p>多数情况，我们都会将创建后NSTimer实例对象保存为当前类的实例变量，然后NSTimer的target参数设置为self指针。我写代码的习惯就是这样的。实例代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>{</span><br><span class="line">    <span class="built_in">NSTimer</span> *mTimer;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init {</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) {</span><br><span class="line">      	<span class="comment">//此处参数repeats = YES;</span></span><br><span class="line">        mTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFiredFun) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        [mTimer setFireDate:[<span class="built_in">NSDate</span> distantPast]];</span><br><span class="line">     </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc {</span><br><span class="line">    [mTimer invalidate];</span><br><span class="line">    mTimer = <span class="literal">nil</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerFiredFun{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span> , __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc , <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    </span><br><span class="line">    MyObject *myObjcet = [MyObject new];</span><br><span class="line">    <span class="comment">//self只是一个空消息，避免编译器发出myObjcet未使用的警告</span></span><br><span class="line">    [myObjcet <span class="keyword">self</span>];</span><br><span class="line">  	<span class="comment">//NSTimer依赖于RunLoop而存活，手动激活RunLoop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码就是典型的计时器使用情景之一。如果计时器只是一次执行而非反复触发，那么计时器会在执行后自动失效，也就不会有“保留环”的问题。但是如果是设置反复触发的计时器类型，那么NSTimer对象会强引用MyObject对象，而当前类也一直持有NSTimer对象，因此，如果NSTimer不调用invalidate设置无效，MyObject对象不会背释放，其dealloc函数也一直被调用，然而NSTimer的invalidate恰好是MyObject对象的dealloc函数中调用。这样两个对象都不会释放。</p>
<p>出现“保留环”的根本原因在于NSTimer对象在创建的API隐性地强引用一次target，因此，解除“保留环”的关键在于避开NSTimer对象对self指针的强引用。以下是提供的一种解决方案：</p>
<p><strong>NSTimer+BlockSupported分类</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ICETimerScheduleBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">"NSTimer+BlockSupported.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo {</span><br><span class="line">    <span class="comment">//Timer会对target强引用，但是此处target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:ti target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(ice_timerFiredFun:) userInfo:block repeats:yesOrNo];</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)ice_timerFiredFun:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line">    ICETimerScheduleBlock block = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span> (block) {</span><br><span class="line">        block();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用方式</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">mTimer = [<span class="built_in">NSTimer</span> zd_scheduledTimerWithTimeInterval:<span class="number">1.0</span>f block:^{</span><br><span class="line">    <span class="comment">//添加一次局部强引用，确保即使在block执行过程中外部的self被释放了也能顺利完成。局部变量strongSelf的生命周期只限于当前block，不会一直持有self，所以不影响外部self对象的引用计数平衡。</span></span><br><span class="line">    <span class="comment">//如果局部强引用，weakSelf可能会在block执行过程中因为外部self释放而被设置为nil。</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf timerFiredFun];</span><br><span class="line">} repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>上述解决方案使用了NSTimer+BlockSupported分类对NSTimer原生函数进行了二次封装，将调用方需要的执行的函数转移到block中执行，再结合__weak指针解除NSTimer对self的强引用。NSTimer原生API调用照样会对target强引用，但是此时的target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</p>
<p>这种类型的“保留环”问题很隐蔽，因此很有分析与记录价值，与君共享。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/icebergcwp1990/ICBTimerWithoutRetainCycle">GitHub Demo</a></p>
<p><em>注：这个解决方案参考了Effective Objective-C 2.0一书中第52条，有兴趣的同学可以自行查阅。</em></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-10-15T04:16:07.000Z" title="10/15/2016, 12:16:07 PM">2016-10-15</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a></span><span class="level-item">2 minutes read (About 298 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/10/15/Objective-C%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/">Objective-C中布尔类型</a></h1><div class="content"><p> Objective-C中的BOOL类型在iWatch和64位iOS上的原始类型为bool，而在其它情况下是signed char。</p>
<p>用@encode去看看BOOL的类型串：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 64位iOS系统："B"</span></span><br><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 32位iOS系统，32/64位OS X："c"</span></span><br></pre></td></tr></tbody></table></figure>

<p>众所周知，在C\C++语言中bool类型中的两个常量false为0，true为1，且非0值都被认为true。Objective-C是建立在C++基础的面相对象的语言，因此bool的定义应该也是如此。</p>
<p>下面对两种情况分别讨论：</p>
<p><strong>typeof BOOL bool</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：This is YES。说明变量被赋值为1，而非数字7。</p>
<p><strong>typeof BOOL signed char</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：This is NO。说明变量被赋值为数字7。</p>
<p>综上所述，在Objective-C中进行布尔比较时，不建议直接将布尔变量和YES或者true做比较，即：if( a == YES )。但是可以和NO或者false做比较，即：if( a != NO )，也可以写成if( a )或者if( !a )的形式。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-04-01T15:50:07.000Z" title="4/1/2015, 11:50:07 PM">2015-04-01</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">15 minutes read (About 2266 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/04/01/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0+load%E5%92%8C+initialize/">两个特殊函数+load和+initialize</a></h1><div class="content"><p>记得还在上一家公司任职的时候，在研发部的探讨会会上就“+load的加载过程”这一议题有过激烈的讨论，大家各执一词，争得面红耳赤。最终是部门老大专门做了一期讲解，才平息了这场争执。但是那时候的讲解并未涉及到源代码分析，而是基于测试代码做的分析，故我并没有完全理解。</p>
<p>在苹果开发文档中提及到：+load是在类或者分类被添加到runtime的时候被调用，而+initialize则是在类的用实例方法或者类方法第一次被调用之前调用。</p>
<p>上面的说明只是说明了这两个函数调用时机，但是并没有涉及父类、子类和分类之间的调用顺序和相互影响，于是试着结合<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">apple公司的开源代码</a>objc4-532.2试着分析这两个函数的加载过程，以加深理解。</p>
<h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>首先在objc-os.mm文件中找到函数_objc_load_image_objc_load_image：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class="line">{</span><br><span class="line">    prepare_load_methods(hinfo);</span><br><span class="line">    call_load_methods();</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<p>根据参数判断，这个函数应该是在加载镜像文件的时候由系统直接调用，且里面就两行代码，分别是对+load函数的预处理与加载</p>
<p>接着在objc-runtime-new.mm文件找查看prepare_load_methods的函数实现：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> prepare_load_methods(header_info *hi)</span><br><span class="line">{</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">	<span class="comment">//获取头文件中所有的类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="comment">//先处理类中的+load方法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="comment">//处理类与父类中的+load函数    schedule_class_load(remapClass(classlist[i]));</span></span><br><span class="line">    }</span><br><span class="line">	 <span class="comment">//再处理分类中的+load方法</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    	 <span class="comment">//初始化分类</span></span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(isRealized(cls-&gt;isa));</span><br><span class="line">        <span class="comment">//将可加载的（存在+load函数）分类归类</span></span><br><span class="line">        add_category_to_loadable_list((Category)cat);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(isRealized(cls));  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//递归调用，优先处理父类</span></span><br><span class="line">    schedule_class_load(getSuperclass(cls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也就意味着父类中的+load方法先被加入列表</span></span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, <span class="number">0</span>); </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>由上述函数可以推断出：父类的+load方法先于子类被加入待处理列表，分类与类中的+load方法是区分对待的。</p>
<p>接着，在objc-loadmethod.mm文件中查看call_class_loads函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> more_categories;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_assert_locked(&amp;loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先调用类中的+load方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) {</span><br><span class="line">        	<span class="comment">//先入先出处理+load函数列表</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        }</span><br><span class="line">			</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">//再调用分类中的+load函数</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    } <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = <span class="literal">NULL</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="comment">//先入先出的遍历顺序，调用父类函数先于子类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">//获得+load的函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">   		  <span class="comment">//注意：是通过函数指针直接调用，而非使用objc_msgSend，因此不会走runtime调用过程。</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) _free_internal(classes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  _class_isLoadable(cls)) {</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             _class_getName(cls), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//直接通过函数指针进行调用，而非通过objc_msgSend调用</span></span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中，先调用了类的+load函数列表，再处理分类中的+load函数，且都是直接通过函数指针调用。又因为父类的+load函数先于子类加入列表，因此+load函数的调用顺序是：父类-&gt;子类-&gt;分类</p>
<p>在上一篇博客<a target="_blank" rel="noopener" href="http://icebergcwp.com/2015/03/25/Objective-C%20Category%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Objective-C Category 深入浅出系列之实现原理</a>中结合源代码分析了Category的实现原理。其中有一个重要的知识点就是分类Category中函数会覆盖主类中同名的函数。然而这种情况发生的前提是函数必须是通过runtime机制（使用objc_msgSend发送消息）调用，因为这样才会通过遍历类的方法列表去获得方法对应的实现。</p>
<h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p>既然+initialize函数是在类的实例方法或者类方法第一次被调用之前触发，而类的实例方法或者类方法正常的调用方式是通过objc_msgSend函数。那么+initialize很有可能是在objc_msgSend函数中进行判断和触发，于是，在objc-msg-x86_64.s文件找到了objc_msgSend的汇编实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line">	</span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">	.private_extern __objc_tagged_isa_table</span><br><span class="line">__objc_tagged_isa_table:</span><br><span class="line">	.fill 16, 8, 0</span><br><span class="line"></span><br><span class="line">	ENTRY	_objc_msgSend</span><br><span class="line">	DW_START _objc_msgSend</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		// r11 = self-&gt;isa</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend  // r11=method, eq set (nonstret fwd)</span><br><span class="line">	jmp	*method_imp(%r11)	// goto *imp</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport	NORMAL</span><br><span class="line"></span><br><span class="line">// cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">	DW_MISS _objc_msgSend</span><br><span class="line">	GetIsa	NORMAL			// r11 = self-&gt;isa</span><br><span class="line">	MethodTableLookup %a1, %a2, _objc_msgSend	// r11 = IMP</span><br><span class="line">	cmp	%r11, %r11		// set eq (nonstret) for forwarding</span><br><span class="line">	jmp	*%r11			// goto *imp</span><br><span class="line"></span><br><span class="line">	DW_END 		_objc_msgSend, 1, 1</span><br><span class="line">	END_ENTRY	_objc_msgSend</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	DW_START _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	SaveRegisters _objc_msgSend_fixup</span><br><span class="line">	</span><br><span class="line">	// Dereference obj/isa/cache to crash before _objc_fixupMessageRef</span><br><span class="line">	movq	8(%a2), %a6		// selector</span><br><span class="line">	GetIsa	NORMAL			// r11 = isa = *receiver</span><br><span class="line">	movq	cache(%r11), %a5	// cache = *isa</span><br><span class="line">	movq	mask(%a5), %a4		// *cache</span><br><span class="line"></span><br><span class="line">	// a1 = receiver</span><br><span class="line">	// a2 = address of message ref</span><br><span class="line">	movq	%a2, %a3</span><br><span class="line">	xorl	%a2d, %a2d</span><br><span class="line">	// __objc_fixupMessageRef(receiver, 0, ref)</span><br><span class="line">	call	__objc_fixupMessageRef</span><br><span class="line">	movq	%rax, %r11</span><br><span class="line"></span><br><span class="line">	RestoreRegisters _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	// imp is in r11</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	cmp	%r11, %r11		// set nonstret (eq) for forwarding</span><br><span class="line">	jmp 	*%r11</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line">	</span><br><span class="line">	DW_END 		_objc_msgSend_fixup, 0, 1</span><br><span class="line">	END_ENTRY 	_objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>汇编基本就是大一水平，很有限。初略发现在调用指令_objc_msgSend之前，先调用了_objc_fixupMessageRef函数。</p>
<p>接着在objc-runtime-new.mm文件中找到_objc_fixupMessageRef函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXTERN IMP </span><br><span class="line">_objc_fixupMessageRef(<span class="keyword">id</span> obj, <span class="keyword">struct</span> objc_super2 *supr, message_ref_t *msg)</span><br><span class="line">{</span><br><span class="line">    IMP imp;</span><br><span class="line">    class_t *isa;</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    msg-&gt;sel = sel_registerName((<span class="keyword">const</span> <span class="keyword">char</span> *)msg-&gt;sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(msg-&gt;sel)) {</span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        msg-&gt;imp = (IMP)&amp;vtable_ignored;</span><br><span class="line">        imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_VTABLE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;imp == (IMP)&amp;objc_msgSend_fixup  &amp;&amp;  </span><br><span class="line">        (vtableIndex = vtable_getIndex(msg-&gt;sel)) &gt;= <span class="number">0</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// vtable dispatch</span></span><br><span class="line">        msg-&gt;imp = vtableTrampolines[vtableIndex];</span><br><span class="line">        imp = isa-&gt;vtable[vtableIndex];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ordinary dispatch</span></span><br><span class="line">        <span class="comment">//常规的消息派发，遍历类的函数列表</span></span><br><span class="line">        imp = lookUpMethod((Class)isa, msg-&gt;sel, <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, obj);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中调用了lookUpMethod函数，其中调用了prepareForMethodLookup函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IMP prepareForMethodLookup(Class cls, SEL sel, <span class="built_in">BOOL</span> init, <span class="keyword">id</span> obj)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRealized(newcls(cls))) {</span><br><span class="line">        rwlock_write(&amp;runtimeLock);</span><br><span class="line">        realizeClass(newcls(cls));</span><br><span class="line">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用_class_initialize对类进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init  &amp;&amp;  !_class_isInitialized(cls)) {</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, obj));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在objc-initialize.mm函数中，找到_class_initialize函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">{</span><br><span class="line">    assert(!_class_isMetaClass(cls));</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">BOOL</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">//递归，保证父类先于子类初始化</span></span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) {</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: calling +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//通过objc_msgSend调用+initialize函数</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: finished +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Done initializing. </span></span><br><span class="line">        <span class="comment">// If the superclass is also done initializing, then update </span></span><br><span class="line">        <span class="comment">//   the info bits and notify waiting threads.</span></span><br><span class="line">        <span class="comment">// If not, update them later. (This can happen if this +initialize </span></span><br><span class="line">        <span class="comment">//   was itself triggered from inside a superclass +initialize.)</span></span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>通过上述函数可知两点：一是父类的+initialize函数先于子类调用，二是+initialize不同于+load函数的采用函数指针调用，而是通过objc_msgSend函数调用，如果分类实现了+initialize函数，那么类（包括子类和父类）的+initialize函数就会被覆盖。</p>
<p>因此，+initialize的调用顺序是父类-&gt;子类，且分类的实现覆盖类的实现，因此分类中的+initialize可能会被多次调用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，对于+load和+initialize的调用规则和方式有了进一步的认识。在日后的编程过程中也可以根据二者的特点，更好的使用它们的功能。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Mark Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mark Cao</p><p class="is-size-6 is-block">程序的世界让我着迷</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ChangSha</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/industriousonesoft" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/industriousonesoft"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-06-27T13:34:07.000Z">2019-06-27</time></p><p class="title"><a href="/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/">初识汇编-知识点摘记</a></p><p class="categories"><a href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-12-01T03:33:07.000Z">2018-12-01</time></p><p class="title"><a href="/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/">《三体》系列第一部读后感之生存还是死亡？</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E8%AF%84/">书评</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-14T14:37:07.000Z">2018-11-14</time></p><p class="title"><a href="/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/">需求第三定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-13T14:13:07.000Z">2018-11-13</time></p><p class="title"><a href="/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/">需求第二定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-11T01:18:07.000Z">2018-11-11</time></p><p class="title"><a href="/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/">需求第一定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/Objective-C/"><span class="level-start"><span class="level-item">Objective-C</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/"><span class="level-start"><span class="level-item">专业</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/OSX/"><span class="level-start"><span class="level-item">OSX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/%E7%BF%BB%E8%AF%91/"><span class="level-start"><span class="level-item">翻译</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E8%AF%84/"><span class="level-start"><span class="level-item">书评</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BD%B1%E8%AF%84/"><span class="level-start"><span class="level-item">影评</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">汇编</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">December 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">August 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">May 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">August 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">June 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">May 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">November 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">October 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/09/"><span class="level-start"><span class="level-item">September 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/08/"><span class="level-start"><span class="level-item">August 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">May 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">April 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/03/"><span class="level-start"><span class="level-item">March 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">February 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">January 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARC/"><span class="tag">ARC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Category/"><span class="tag">Category</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cocoa/"><span class="tag">Cocoa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coffee/"><span class="tag">Coffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaSctript/"><span class="tag">JavaSctript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KVO/"><span class="tag">KVO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OSX/"><span class="tag">OSX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Objective-C/"><span class="tag">Objective-C</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PlistBuddy/"><span class="tag">PlistBuddy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RunLoop/"><span class="tag">RunLoop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%89%E4%BD%93/"><span class="tag">三体</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"><span class="tag">人物传记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"><span class="tag">人类简史</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%B1/"><span class="tag">爱</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div></div></div></div></div></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a><p class="is-size-7"><span>&copy; 2022 Mark Cao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-center",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>