<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MarkCao</title>
  
  
  <link href="http://naivertc.top/atom.xml" rel="self"/>
  
  <link href="http://naivertc.top/"/>
  <updated>2022-03-16T15:40:43.069Z</updated>
  <id>http://naivertc.top/</id>
  
  <author>
    <name>Mark Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识汇编-知识点摘记</title>
    <link href="http://naivertc.top/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
    <id>http://naivertc.top/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/</id>
    <published>2019-06-27T13:34:07.000Z</published>
    <updated>2022-03-16T15:40:43.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="汇编语言的由来"><a href="#汇编语言的由来" class="headerlink" title="汇编语言的由来"></a>汇编语言的由来</h4><ul><li>汇编语言是基于机器语言（由0或1组成）而产生的一种助记符</li><li>汇编语言介于机器语言和高级语言之间</li><li>汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令</li><li>汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言</li><li>高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。</li></ul><span id="more"></span><h4 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h4><p><strong>优点</strong></p><ul><li>汇编语言可直接访问或控制硬件：存储器、CPU，能最大限度的发挥硬件功能</li><li>目标代码少，占位内存少，执行速度快</li><li>不同厂商的CPU都有对应的机器指令集和汇编指令集合</li><li>大小写不敏感</li></ul><p><strong>缺点</strong></p><ul><li>不易于编写、维护、调试</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>CPU由寄存器、运算器和控制器组成，其中最主要部件是寄存器，通过改变寄存器的内容来实现对CPU的控制</li><li>不同的CPU，寄存器个数和结构存在差异</li></ul><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul><li>arm64寄存器有31个64位的通用寄存器x0-x30，这些寄存器通常用来存放一般数据</li><li>w0-w28是32位寄存器，是x0-x28寄存器的低32位，即64位的CPU是兼容32位的</li><li>CPU会先将内存中的数据存储到通用寄存器中，然后在对通用寄存器中的数据进行运算，原因在于寄存器的执行速度比内存快</li><li>arm64架构下，函数参数都是保存在x0-x7（32位下即w0-w7）这8个寄存器，超过8个参数入栈</li><li>函数返回值是存放在x0寄存器中</li><li>函数的局部变量都是保存在栈中</li></ul><h5 id="PC寄存器：program-counter-register"><a href="#PC寄存器：program-counter-register" class="headerlink" title="PC寄存器：program counter register"></a>PC寄存器：program counter register</h5><ul><li>指令指针寄存器，指向CPU当前要执行的指令地址</li><li>内存中指令和数据无区别，都是二进制数据。CPU将PC寄存器指向的内存单元的内容看作指令</li></ul><h5 id="sp与fp寄存器"><a href="#sp与fp寄存器" class="headerlink" title="sp与fp寄存器"></a>sp与fp寄存器</h5><ul><li>sp寄存器会在任意时刻保存栈顶地址</li><li>fp寄存器即为x29寄存器，有时也用于保存栈低的地址</li></ul><h5 id="lr寄存器"><a href="#lr寄存器" class="headerlink" title="lr寄存器"></a>lr寄存器</h5><ul><li>lr寄存器就是0x30通用寄存器</li><li>0x30寄存器存放函数返回地址，执行ret指令时会读取这个寄存器的值，实现函数返回</li></ul><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><h5 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h5><blockquote><p>arm64架构中取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp；ldp/stp是ldr/str的衍生，可同时读写两个寄存器，而ldr/str只能读写一个</p></blockquote><ul><li>str指令：store register指令，将数据从寄存器中读出，写入内存</li><li>ldr指令：load register指令，将数据从内存读出，存入寄存器</li></ul><p>eg：利用栈将x0和x1寄存器中的值互换</p><blockquote><p>arm64架构中，栈是16字节内存对齐的，即一次读写至少是16（0x10）个字节</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub sp,sp,#0x10 ;栈顶指针下移0x10个字节，两个64位的寄存器共16个字节</span><br><span class="line">stp x0,x1,[sp,0x10] ;寄存器x0,x1先后的值入栈</span><br><span class="line">ldp x1,x0,[sp,0x10] ;出栈，先后写入x0,x1寄存器</span><br><span class="line">add sp,sp,0x10 ;栈还原，stp、ldp指令不会改变sp指针位置，且都是由高地址向低地址读写</span><br></pre></td></tr></tbody></table></figure><h5 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h5><ul><li>CPU执行的指令是由PC寄存器决定的，因此可以通过修改PC寄存器的内容来控制CPU的指令执行</li><li>传送指令用于操作通用寄存器，比如mov指令；此外是转移指令，用于修改PC的值，最简单的就是bl指令</li><li>bl指令跳转前将当前指令的下一条指令存放到lr(0x30)寄存器：链接寄存器</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;汇编语言的由来&quot;&gt;&lt;a href=&quot;#汇编语言的由来&quot; class=&quot;headerlink&quot; title=&quot;汇编语言的由来&quot;&gt;&lt;/a&gt;汇编语言的由来&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;汇编语言是基于机器语言（由0或1组成）而产生的一种助记符&lt;/li&gt;
&lt;li&gt;汇编语言介于机器语言和高级语言之间&lt;/li&gt;
&lt;li&gt;汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令&lt;/li&gt;
&lt;li&gt;汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言&lt;/li&gt;
&lt;li&gt;高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="汇编" scheme="http://naivertc.top/categories/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>《三体》系列第一部读后感之生存还是死亡？</title>
    <link href="http://naivertc.top/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/"/>
    <id>http://naivertc.top/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/</id>
    <published>2018-12-01T03:33:07.000Z</published>
    <updated>2022-03-14T15:52:49.761Z</updated>
    
    <content type="html"><![CDATA[<p>《三体》是我看的第一本科幻小说，与很多在学生时期就接触了这本书的朋友比起来，即将三十而立的我觉得有点相见恨晚。书中涉及了天文学、物理学、计算机学等众多专业知识。在阅读这本书的过程中，总会时不时地感叹作者想象力之丰富，知识之渊博。与作者刘欣慈一样同为程序员的我读起来多了一丝亲切感。过去的自己对科幻小说存在一些误解，认为科幻小说无非只是天马行空的想象罢了，这类超现实的小说只适合用来消遣，并没有太多实用性。现在我为自己愚蠢的想法道歉：一本好的小说一定都蕴含着一个深刻的内核，或是对生命的思考，或是对人性的剖析等等。而小说的功能则是通过虚构一个故事或世界让读者更好的理解作者要表达的想法，并引导读者产生共鸣。《三体》这本书在我看来，它提出的是对人类的究极拷问：生存还是死亡？</p><p>这本书采用的是倒叙和插叙的叙述方式，让读者在阅读的过程中不断地处于产生疑惑和解答悬念的循环中，也使整个阅读过程都充满紧张和刺激的感觉，直到最后一刻谜底揭开之时不自觉地陷入深思并自我审视：当自己面临同样的困境会如何抉择？是选择生存还是死亡？</p><p>在给出自己的答案之前，我觉得很有必要按照时间顺序将整个故事的来龙去脉理一遍，这样可以更好地理解作者想要表达的想法。</p><h5 id="起源：文化大革命"><a href="#起源：文化大革命" class="headerlink" title="起源：文化大革命"></a>起源：文化大革命</h5><p>这本书的主角无疑是叶文洁，整本书都是围绕着叶文洁坎坷悲催的成长历程展开，她的遭遇让她看清了人性的丑恶，对人类文明也逐渐失去了信心，而这一切的源头毫无疑问是文化大革命。文革大致可以分为三个阵营：坚守真理的知识分子，疯狂无知的红卫兵以及为求自保的利己主义者。而叶文洁的一家四口恰巧分属这三个阵营，也为这个不幸的家庭埋下了悲惨结局的注脚。</p><p>叶文洁的父亲叶文泰，属于坚守真理的知识分子代表。在文革时期，作为物理学界的泰斗的他成为了众矢之的。但是，面对持续的残酷打击，他自始至终地捍卫着自己内心由知识和理性构筑的思想大厦，直到生命的最后一刻也不曾有一丝妥协。他内心其实早已看透：“在中国，任何超脱飞扬的思想都会怦然坠地，因为现实的引力太沉重了”，更何况是在这个疯狂的年代，坚守真理需要付出的是生命的代价。而作为红卫兵的叶文洁，站在台下红卫兵的队伍中目睹了父亲整个的批斗过程，除了强忍悲痛与泪水之外显得无能为力。那时候的她还是学生，同其他的红卫兵一样没有科学信仰，缺乏分辨是非的能力，并且对至高无上的权利都有着天生的崇拜。但她又不同于妹妹那样完全失去理智，六亲不认。这是因为她内心真正崇拜的人是自己的父亲，也意味着她和父亲有着同样的科学信仰。只是她那时候太年轻，很轻易地就被文革浪潮吞没，同时被吞没的还有个人的信仰。那时候的她本能地选择活下去，而加入红卫兵就是最好的选择。和叶文洁做出同样选择的还有父亲的两个研究生，我相信他们内心是崇尚科学的，这也让他们在批斗自己老师的时候尚且表露出一丝人性。但是他们内心又惧怕成为革命对象，为了生存只能将自己隐藏在红卫兵的外衣之下。但是当她在大兴安岭接受劳动改造时，面对他人的栽赃陷害以及上层对父亲的二次批斗，她选择了和父亲一样的斗争方式：以死捍卫自己的尊严和信仰。而与叶文洁及其父亲形成鲜明对比的是同为物理学教授的母亲，她则是一位精致的利己主义者，她既不像叶文泰那样甘愿为科学献身，也不像红卫兵那样愚昧无知，她所做的一切都是为了让自己活着，并且活得更好。早在文革初期她就嗅出了知识界的政治风向，做出很多超前的举动，试图告诉学生：所有的科学成果都是广大劳动人民的智慧结晶，而那些资本阶级的学术权威不过是窃取了这些智慧，试图得了文革主流的认可，从而使自己能在这场自己为革命对象的斗争中生存下来。为了达到这个目的，她不惜一切代价：在文革时期上台协助红卫兵批斗自己的丈夫；在文革后期眼光独到地嫁给了一位尚未平反的教育部高干，在文革结束后不久便再次回到上层阶层；为了与过去的历史旧账撇清关系而不惜与女儿决裂。为自己活着无可厚非，但是将自己的幸福建立在他人的痛苦之上就是可耻的。</p><p>文革结束后，叶文洁找到了当年将自己父亲批斗致死的三个红卫兵，试图让她们为当年的罪行忏悔，哪怕是人性的一点点复归。然而得到的答复是：“她们也是受害者，文革剥夺了她们的青春和未来，历史已经将她们遗忘，她们内心只有怨狠没有忏悔”。那一刻起，叶文洁对于人类文明彻底失去了信心，期待宇宙间更高的文明来引导人类文明已然成为了她坚定不移的信念。</p><h5 id="经过：寻找更高级的文明"><a href="#经过：寻找更高级的文明" class="headerlink" title="经过：寻找更高级的文明"></a>经过：寻找更高级的文明</h5><p>叶文洁因为自己大一的一篇名为《太阳辐射层内可能存在能量界面和其反射特性》的论文将她从文革二次迫害中拯救出来，进入了神秘的红岸基地。毫无疑问，红岸基地的出现不仅拯救了叶文洁的性命，也让早已心如死灰的叶文洁重新燃起了对生的欲望，因为在这里有了探索外星文明的可能性。</p><p>在红岸基地，因为特殊身份和遭遇叶文洁被隐形地的隔离与疏远，而工作成为了她生活的全部。只有全身心地投入工作才能暂时忘记过去的痛苦，加上叶文洁夯实的学术研究功底，为后续叶文洁成为第一个发现“太阳是一个电波放大器”这一理论的人增加了可能性。苏联天体物理学家卡达谢夫曾建议，可以根据宇宙中不同文明用于通讯的能量，来对它们分级。他将想象中的文明分为Ⅰ、Ⅱ、Ⅲ三种类型；Ⅰ型文明能够调集与地球整个输出功率相当的能量用于通讯。当时他的估计，地球的功率输出约为1015～16瓦。Ⅱ型文明能够把相当于一颗典型恒星的输出功率，1026瓦用于通讯。Ⅲ型文明用于通讯的功率达1036瓦，约等于整个星系的功率输出。红岸基地所能发射的最大功率虽然连Ⅰ文明都达不到，但是它可以满足穿越太阳对流层到达反射层的阈值，经过太阳放大后的功率可达到Ⅱ型文明能量级，意味着地球文明找到了探索更高文明的钥匙。在接触《三体》这本书之前，我就一直存在一个疑问：长期以来人类以自己的认知方式去探索其他文明真的可以建立联系吗？这就好比有一条寄生虫无法感知人类存在一样。因此，如果有一个文明以人类无法感知的方式进行交流，即便真的存在我们周围我们也是无从得知的。在与三体文明取得联系之后，叶文洁向三体星球发出了“求救”信，期望着更高的文明降临拯救人类。这几乎成为了她那时唯一的信仰，为了捍卫这一信仰不惜以雷志成和丈夫杨卫宁的性命为代价。</p><p>随着文革风波的平息，与文革同样疯狂的“红岸计划”也逐步停滞瓦解。因为与失去了与宇宙文明通讯的平台，重新回归正常生活的叶文洁本以将人类的命运寄托于自己的美好期望中，直到遇到了同样对人类文明失去信心的还有伊文斯。伊文斯是一位物种共产主义者，他的信仰是：地球上的所有物种生来平等。然而人类文明的首要规则是：“保证人类的生存和舒适的生活，其他都是第二位的”。与叶文洁不同的是伊文斯有更多的选择，以及继承了父亲巨额遗产，这让他可以根据自己的意愿去探索人性，证明自己的理论是否可行。可惜他的信仰与人类文明是背道而驰的，这注定了他在人类社会是一个失意者。叶文洁的出现为伊文斯指明了新的探索之路：借助更高的文明来引领地球文明。因此也有了第二红岸基地的诞生。</p><p>如果说叶文洁是搭建与三体文明交流桥梁的先驱者，那么伊文斯则是在地球传播三体文明的领军人。尽管在他们的共同的努力下，三体文明的已经将地球锁定为他们希望的生存之地并开始向地球文明靠近，但是他们对于三体文明的降临地球后的期许却截然不同，因而三体叛军中产生了不同的派别，主要分为三派：</p><p>降临派：这是三体叛军最本原最纯粹的一脉，主要由伊文斯物种共产主义的信奉者组成。他们对人类本性都已彻底绝望，这种绝望最初来源于现代文明导致的地球物种大灭绝。伊文斯的一句话已成为降临派的座右铭：我们不知道外星文明是什么样子，但知道人类。他们期望三体文明的彻底摧毁人类文明。</p><p>拯救派：拯救派的成员大多都是通过《三体》游戏认识三体文明，以高级知识分子居多，并对于三体文明有着宗教般的崇拜。但是对于人类文明的态度远没有降临派那样极端。他们的终极理想是拯救主，也就是三体文明。为了达到这一目的可以一定程度上牺牲人类世界。</p><p>幸存派：幸存派的成员都来自较低的社会阶层，他们期望自己和子孙成为三体文明和地球文明那场终极战争中的幸存者，他们认为现在就为三体服务更有利于实现这一目的。这一派的主张很符合中庸思想，因此也以中国人居多。</p><p>这三个派别相互制约和对立，在三体文明降临之前他们有着共同的大目标，共同为三体服务。但是一旦三体文明降临，他们便会了各自的利益各自为战。就像当年文革时期，在“革命军”这一大群体中也有着很多的派系，他们借以文革的名义谋求着各自的利益，而最后沦为牺牲品的只有年幼无知的红卫兵和坚守真理的人。历史总是惊人的相似，因为人性如此，人类文明如此。</p><h5 id="结果：三体文明降临"><a href="#结果：三体文明降临" class="headerlink" title="结果：三体文明降临"></a>结果：三体文明降临</h5><p>不同于地球得天独厚的的自然环境，可以让人类在登上食物链顶端之后不必再考虑如何生存下去，而是考虑如何生活地更好。人类的文明发展史从另一个角度来讲就是一部环境和资源的破坏史，为了短期的利益而忽视地球环境和人类未来至始至终贯穿人类史。每当出现能源危机时都有新的技术突破带领人类走出困境，这也让大部分人类可以更加肆意地追求物质上的享受，因为他们相信当人类出现危机时总会有新的技术出现将危机化解。曾几何时，三体世界也像地球一样，有民主自由的社会，有着丰富的文化遗产。然而在生存危机面前，文明则变成了最脆弱的环节，如同温室的花朵一般。如今三体人挣扎于自己的星球的三体困境中，为了生存而不断地寻求技术突破，包括寻找或者践踏其他星球的文明，甚至抹灭了三体人生而为人的尊严与自由，剥夺作为人的基本情感需求，没有财富没有地位没有爱情，也没有希望。三体世界里的人类大多数都像1379号监听员那样孤独的过完一生，要么工作至死，要么脱水封存。当他接受到来自地球的信息，得知宇宙的另一个角落存在一个星球，那里有着自己向往的生活。这对他而言这是人生中最有价值的时刻，然而第一时间想到的是对上级隐瞒消息，内心不忍地球文明被三体占有和摧毁。我想这不仅是因为对地球这颗美丽的星球心生怜悯，更多的是因为对三体世界的绝望。然而他却不知道此时地球上也有一群人像他一样对自己身处的世界和文明感到绝望，正期待着三体文明的降临。</p><p>为了阻止人类文明与科技的发展，三体高层研发出了智子，试图对人类进行降维攻击。说起智子工程不得不再次感叹作者天马行空的想象，将整个人类世界想象成一个CPU，智子以接近光速的速度在地球穿梭，这让处于低速层面的地球人类感觉到智子无处不在。</p><h5 id="抉择：生存还是死亡"><a href="#抉择：生存还是死亡" class="headerlink" title="抉择：生存还是死亡"></a>抉择：生存还是死亡</h5><p>面对更为高级文明的降临，地球人面临着前所未有的抉择：生存还是死亡？</p><p>相较于普通百姓，高级知识分子显得更为悲观，而这些高级知识分子中又以科学家最为悲观。因为他们更接近真相，更清楚事情的严重性。与此同时，他们作为三体文明首要的攻击对象，当理性和科学的大厦被击溃时，活着似乎显得毫无意义，这也是杨冬自杀的原因所在。</p><p>作为大多数存在的普通人，对于科学没有那么虔诚的信仰，出于生存的本能而选择自救。尽管在三体人看来地球人就像虫子一样卑贱。但是就像人类和蝗虫之间的战争一样，人类用尽各种方法试图消灭蝗虫，最终却不得不承认一个事实：虫子从未被真正意义上战胜过，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《三体》是我看的第一本科幻小说，与很多在学生时期就接触了这本书的朋友比起来，即将三十而立的我觉得有点相见恨晚。书中涉及了天文学、物理学、计算机学等众多专业知识。在阅读这本书的过程中，总会时不时地感叹作者想象力之丰富，知识之渊博。与作者刘欣慈一样同为程序员的我读起来多了一丝亲</summary>
      
    
    
    
    <category term="书评" scheme="http://naivertc.top/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="三体" scheme="http://naivertc.top/tags/%E4%B8%89%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>需求第三定律</title>
    <link href="http://naivertc.top/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/"/>
    <id>http://naivertc.top/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/</id>
    <published>2018-11-14T14:37:07.000Z</published>
    <updated>2022-03-14T15:55:17.065Z</updated>
    
    <content type="html"><![CDATA[<p>需求第三定律的含义：每当消费者必须支付一笔附近费时，高品质的产品相对低品质的产品就变得便宜了。这笔附加费越高，高品质产品相对就越便宜。因此，这个定律又叫“好东西运到远方去定律”。</p><p><strong>附加成本大，精选品才值得</strong></p><p>当人们不得不支付一笔巨大的附加费时，就只有精选品才值得人们去运送、去提供，才值得人们享受。</p><p><strong>附加成本上升并非好事</strong></p><p>当附加成本上升，精选品就显得便宜，那么是否附加成本越高越好？</p><p>以中国出口香烟为例，如果进口国家对香烟实施配额制，每包香烟多付5元的附加费。那么这时只有较贵的香烟才值得出口。这样出口的香烟种类就减少了，国外消费者的选择也相应的少了。因此，虽然出口商品的平均质量提高了，但是出口商品的品种少了。国外的消费者和出口国生产商都蒙受了损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求第三定律的含义：每当消费者必须支付一笔附近费时，高品质的产品相对低品质的产品就变得便宜了。这笔附加费越高，高品质产品相对就越便宜。因此，这个定律又叫“好东西运到远方去定律”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附加成本大，精选品才值得&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当人们</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>需求第二定律</title>
    <link href="http://naivertc.top/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/"/>
    <id>http://naivertc.top/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/</id>
    <published>2018-11-13T14:13:07.000Z</published>
    <updated>2022-03-14T15:55:23.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>理解了需求第二定律，就可以更懂人与人之间互相作用、互相博弈的规律</p></blockquote><p>需求第二定律的定义：需求对价格的弹性，和价格变化之后流逝的时间长度成正比。换言之，随着时间的推移，需求对价格的弹性会增加。</p><p><strong>需求对价格的弹性</strong></p><p>需求对价格的弹性，就是需求量随着价格变动而变动的程度。它等于需求量的变化比例除以价格的变化比例。<br>注：由于需求曲线是减函数，所以弹性永远都是负数。一般讲弹性都是指绝对值。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/1.png" width="300" hegiht="200"></div><p>奢侈品：弹性&gt;1.0，需求量的变化幅度大于价格的变化幅度的物品属于奢侈品<br>必需品：弹性&lt;1.0，需求量的变化幅度小于价格的变化幅度的物品属于必需品</p><p>弹性不等同于斜率，其他条件不变的前提下，需求函数的斜率为1。而弹性是渐变的。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/2.png" width="300" hegiht="200"></div><p>由于需求曲线中，价格是自变量，因此一件商品是奢侈品还是必需品完全取决于价格。</p><p><strong>寻找替代方案</strong></p><p>现实生活中是否存在一种商品，无论价格多高，它的需求量都是不变的。那么这种商品的需求曲线是一条垂直于需求量的直线。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/3.png" width="300" hegiht="200"></div><p>但是实际情况下是不存在的，人们一定会找到替代方案，整个人类历史就是一个不断寻找替代方案的历史。以食用盐为例，当盐的价格高到一定程度，人们就会想办法寻找替代方案，包括最终生病或死亡都属于替代方案。</p><p>正如需求第二定律所说，随着时间推移，需求对价格的弹性就越大，也就是寻找到的替代方案就越多，应变的空间也越来越大。</p><p><strong>商品的税负问题</strong></p><p>一件商品的税负由用买卖双方共同承担的，正确的答案由两句话组成：税负是双方共同承担的；双方各付多少，取决于需求者和供应者双方的相对弹性，谁的弹性低，谁对这份交易的需求更迫切，谁就付得多一点。</p><p><em>注：买家对应于需求曲线，而卖家对应于供应曲线。</em></p><p>情况一：在买卖双方对商品的弹性是一致的时候，各自均摊税负。如下图所示：</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/4.png" width="300" hegiht="200"></div><p>图中的平衡点N是需求曲线D与供应曲线S的相交点，表示在没有对商品征税的情况下，需求量和价格分别为q0、p0。对商品征税后，买家付出的价格从p0上涨到pd，卖家收到的价格从p0下降到ps，商品的需求量从q0下降到q1。面积A+B恰好等于税收。</p><p>情况二：买家的对交易更为迫切，对商品的弹性较低，即需求曲线的较为陡峭，而供应曲线相对平缓。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/5.png" width="300" hegiht="200"></div><p>由图可知，这种情况下，买家承担的税负更高。</p><p>情况三：卖的对交易更为迫切，对商品的弹性较低，即供应曲线的较为陡峭，而需求曲线相对平缓。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/6.png" width="300" hegiht="200"></div><p>由图可知，这种情况下，卖家承担的税负更高。</p><p>推广：</p><p>1、有人说房价太高，建议政府通过收取很高的房产交易税来压低房价，这种想法完全是错误的。重税只会增加买卖双方的负担，而且如果是买房者是刚需，则会承担大部分的税负。</p><p>2、不管是法律是否规定了雇主付养老保险还是雇员付养老保险，最后双方的分担都取决于雇主和雇员谁的弹性更大，谁的谈判能力就越高，承担的负担比例就相对小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;理解了需求第二定律，就可以更懂人与人之间互相作用、互相博弈的规律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需求第二定律的定义：需求对价格的弹性，和价格变化之后流逝的时间长度成正比。换言之，随着时间的推移，需求对价格的弹性会增加。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>需求第一定律</title>
    <link href="http://naivertc.top/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/"/>
    <id>http://naivertc.top/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/</id>
    <published>2018-11-11T01:18:07.000Z</published>
    <updated>2022-03-14T15:55:12.624Z</updated>
    
    <content type="html"><![CDATA[<p><em>注：本文属于《薛兆丰经济学讲义》第28讲的读书笔记</em></p><blockquote><p>人总是善于根据代价的高低而灵活应变–对人性深刻而基本的刻画</p></blockquote><p>需求第一定律的定义是：当其他情况不变时，只要价格提高，商品的需求量就会减少；价格降到一定程度，需求量就会增加。</p><p><strong>需求曲线</strong></p><p>基于其他条件不变的前提，需求曲线是一条斜率不变的减函数，随着价格（自变量）的增大，需求量（因变量）递减。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/1.png" width="300" hegiht="200"></div><p>当存在价格之外的其他任何因素发生变化时，整条需求曲线发生变动和转动，但是仍然是一个减函数。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/2.png" width="300" hegiht="200"></div><p>很多时候我们容易被一些社会想象误导，误以为需求曲线在某些情况下是增函数的。比如股市出现追涨杀跌，其实是因为股票的盈利能力变了。存在这种误解是忽视了需求定律中“其他条件不变”的前提。在人性不变得前提下，价格越高，需求将越低。此外，需求不等同与需求量，一个人对某个商品的需求是不会随着价格变动而出现变化的。</p><p><strong>供应曲线</strong></p><p>在需求曲线中，当价格上升到一定程度会出现负需求，也就是供给。换言之，需求和供给完全取决于市场价格。当价格足够高时，原本属于需求者的一部分会变成供给者。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/3.png" width="300" hegiht="200"></div><p><strong>交易剩余</strong></p><p>需求曲线上的任何一点都代表一个人对某个商品的在这个单位上的个人估值，即为了获得这个单位的服务愿意付出的最大代价。</p><p>但是，一个人对某个商品的估值与他最终得到这个商品所付出的代价之间往往存在着差距，这个差距就是“剩余”。同理，商品生产者也享受“剩余”，厂商对一个商品的估值与商品的市场价格之间的差距。因此这种剩余更合理的名称应该是“交易剩余”。</p><p><strong>思考题</strong></p><p>我们讲，凡是交易就有剩余，有剩余，买卖双方都皆大欢喜。但如果是这样的话，为什么世界上许多国家都有所谓的价格法，专门打击商人定价过高的行为呢？</p><p>我的理解：虽然存在交易，买卖双方就都能享受剩余。但是卖家和买家享受的剩余来源不同，或者说是相斥的。卖家享受的剩余=商品交易价格-卖家对商品的估值，因此商品的成交价格越高，卖家享受的剩余就越大。反观，买家享受的剩余=买家对商品的估值-商品的交易价格，即商品的成交价越高，买家享受的剩余就越小。根据需求曲线，价格越高，需求量越低。如果卖家对商品的定价过高，需求者可能会转变成供给者，整个市场会出现供大于求的现象。因此，为了保护消费者的权益以及维护市场供需平衡，需要通过法律手段来制衡商家定价过高的行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;注：本文属于《薛兆丰经济学讲义》第28讲的读书笔记&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人总是善于根据代价的高低而灵活应变–对人性深刻而基本的刻画&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需求第一定律的定义是：当其他情况不变时，只要价格提高，商品的需</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>失传的艺术-计算机科学</title>
    <link href="http://naivertc.top/2018/11/03/%E5%A4%B1%E4%BC%A0%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    <id>http://naivertc.top/2018/11/03/%E5%A4%B1%E4%BC%A0%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</id>
    <published>2018-11-03T13:57:07.000Z</published>
    <updated>2022-03-14T15:54:08.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Don’t learn to build doghouses and call yourself an architect. 不要明明是在搭建狗屋，却自称为建筑师。</p></blockquote><p>今天在阮一峰博客看到一篇名为<a href="http://rubyhacker.com/blog2/20150917.html">Computer science as a lost art</a>的英文博客，文章不长，内容也朴实随意，正如作者所言属于即兴发挥。文章阐述的观点让我自感惭愧，也让我意识到自己与真正的计算机从业者之间的差距，遂翻译以自勉。译文如下：</p><p>昨晚我的一位老友问我：“计算机科学是否已经成为了一门失传的艺术？”今早，我给出了即兴想到的答案：</p><p>嗯，这就是我的观点。我拥有计算机本硕学位即六年计算机科学求学历程，与此同时有着30年工作经验。换言之，我有些过时了，且与当下有点格格不入。</p><p>即使我不大愿意相信，但是确实有些事情实实在在的发生了。首先，如今电脑已经相当普及，你还能找到一个80岁以下却没有电脑或手机的人吗？其次，万维网（作为互联网最初的模样诞生于1989年）在1995左右便已经开始遍布于公众。随着电脑的使用领域变得越来越广，它也变得越来越重要。第三，那些我们用于创建软件应用的工具在功能上变得更复杂从而更便于使用，就像驾驶汽车这件事来说现在相对于1905年来说要简单的多。</p><p>我想要表达的是现在的电脑使用者比过去任何时候都要多。现在也有很多所谓的程序员没有上过一堂编程课。不过任何事情都要利弊。</p><p>这意味着一个人只需要很少的计算机知识便可以完成一个小项目，但也意味着这样的人很可能不会为了完成大项目而去学习更多的知识。</p><p>老实说，私底下我对于现在存在这样一大群不思进取的伪程序员这个事实感到很沮丧，我也很少对他人提及我的感受。在我看来，他们决定学习他们领域5%的知识是为了完成某个任务，或找点乐子，或谋生而已。</p><p>这些人使用编程工具创建一些日常所用的应用程序，殊不知编程工具本身也是软件。但是编程软件远非一般水平的人所能创建的。即便这些人每天都在使用编程语言，编辑器，编译器和操作系统，但是他们对于如何编写用于编程的软件，以及这些软件的运行原理没有丝毫的头绪。</p><p>20年后，一个赛车手可以把小孩放他的腿上，然后小孩会说：“哈，我也能驾驶这辆车，任何人都可以驾驶它。你只需要按下绿色按钮然后说‘送我去沃尔玛’即可。”这与我对如今学习编程这件事的看法有些类似。</p><p>回到计算机科学的话题。我的朋友有一个七岁的儿子自学了一款很棒的编程工具，然后编写了一款iPhone游戏。尽管，那是一款很简单的游戏。但是他完成了这件事情放在三十年多前差不多需要拥有计算机博士学位的人才能完成，而且还不是移动设备上的软件。</p><p>有时候我与一些人交流计算机知识时，他们的抱怨和疑惑说明他们已经到了自己的知识边界。有时候这让我很震惊，我认为：这些知识点应该是在你第一个学期的第一堂计算机科学课程里面就能学到的。随后我意识到，这些并没有真正意义上学习过计算机科学的课程。</p><p>当然，在我之前的上一代计算机前辈们也是以同样的眼光看待我们这一代人的。在1940年代，你几乎必须有一个电子工程学位才有可能接触到计算机。在上个世纪70年代末到80年代初，你只需主修一门计算机科学或工程就能接触到计算机，在90年代以后，你仅仅需要一张信用卡，或者你父母有一张信用卡。</p><p>我对于硬件很痴迷，顺便说一下，我离不开键盘。每当我拆开一台电脑试图捣腾点某个零件时，我总会把其他零件搞砸。严格意义上说我是一个软件男。因此，我曾经被他人嘲笑过，甚至一些年长的人也会因为我不会使用电焊笔而嘲笑我。</p><p>任何事情都基于你真正想做什么。如何你只是想开一家网店、制作购物车、网页表格、漂亮的图片以及社交媒体软件，那么你根本不需要计算机科学学位，甚至是与之相关联的学位。</p><p>如果你想创造一些尚未存在且很有趣的东西，或是你想在这个产业里面做出一点成绩，或是你仅仅想稍许改变一点这个世界，那么你必须有一个计算机学位。如果你想编写那些给低层次的程序员使用的软件和库，你也必须有一个计算机学位。</p><p>或者你从另外一个角度看待：如果你想搭建一个狗屋，只需要知道使用锤子和钉子，然后动手做即可。如果你想成为一名设计和建造摩天大厦的建筑师时，你首先需要一个建筑业的学位。再次恳请大家要有自知之明，不要明明是在搭建狗屋，却自称为建筑师。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Don’t learn to build doghouses and call yourself an architect. 不要明明是在搭建狗屋，却自称为建筑师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天在阮一峰博客看到一篇名为&lt;a hre</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>《中国哲学史》读后感</title>
    <link href="http://naivertc.top/2018/10/20/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E5%8F%B2-%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://naivertc.top/2018/10/20/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E5%8F%B2-%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2018-10-20T14:27:07.000Z</published>
    <updated>2022-03-14T15:53:09.074Z</updated>
    
    <content type="html"><![CDATA[<p>《中国哲学史》讲述了中国哲学的发展历史，打通了古今中外的相关知识，在有限的篇幅里融入了冯友兰先生对中国哲学的理解，是史与思的结晶，充满了人生的睿智与哲人的洞见。作者认为，哲学的功能在于提高人的心灵，超越现实世界，体验高于道德的价值。在学习哲学的过程中，人们没有智慧与不智慧之分，而哲学家们研究哲学的目的也从来不是为了提高智慧，仅仅是为了哲学本身。哲学既不是生存的工具或手段，也非我们生活的目的与理想，但它能使我们更清楚地认识到人生的意义。</p><p>在书中冯友兰先生着重于用浅显易懂的言语对哲学家本人思想的重新整理，梳理了中国哲学史上的几个重要的流派：儒家、墨家、道家、名家、阴阳家、法家，及各派在各个时期的发展、演变、更新。冯友兰自己认为，就《中国哲学史》的内容来讲有两点可以引以自豪的: 一是把先秦名家的辩者区分成两派;另一点是分辨出宋代程颢程颐兄弟思想的差异和各自特点。此二点均发前人所未发，为中国哲学史界普遍接受。</p><p>说到哲学，我们一般想到的都是西方的哲学，而并不知道中国也有哲学。其实中国哲学有三类，玄学，道学，义理之学，只是中国哲学并没有冠“哲学”之名。</p><p>中国哲学之所以缺少严谨的系统的体系，可能和中国人思想方式有关。每个民族都会在其文明发展的同时对人和世界的各种本体性问题发问，于是则产生了哲人。不同民族的哲人思考的终极问题往往相同，但思考的方法，思想的表述则大相径庭，是以各民族的哲学之面貌多有不同。区别于西方注重逻辑和思维缜密，中国的哲学更注重于现象而轻规律，逻辑的成分自然较少。如各个名家思想，常常是以其日常的“零碎语录”编辑而成的哲学，因而中国的哲学也就具有直观性、随意性及非专业性。</p><p>但事实上，在中国，哲学如宗教之于西方世界一样深深渗入社会，为常人所持。原因在于中国很多哲人并不以哲人自居，而是在日常行事中表达自己的思想，不求构筑体系，这是以有别于西方的。正如书中所言：“故哲学家之有所蔽，正因其有所见。惟其如此，所以大哲学家之思想，不但皆为整个的，而且各有其特别精神，特别面目”。而此书的作用，便是系统地讲解了中国哲学史从古至今的发展演变，让人充分了解中国的哲学发展。</p><p>一时代有一时代之时代精神，一时代之哲学即其时代精神之结晶也。全书分为两部子学时代和下篇经学时代。冯友兰先生从诸子百家中孔子说起。孔子之前只有鬼神，术数，没有一个鲜明的系统。孔子之后，儒家墨家，道家法家，阴阳家名家，无论是对事物的观察，处世之方，或者政治及社会主张，以及对理想之人格和社会的期望，都各自发展出系统的理论，并且身体力行，自成一派，发扬光大，这就是子学时代。而经学时代，则分为古文及今文。“经”即诸子之文，经学即是以旧瓶装新酒，用前人的经文来阐释自己的理论，生搬硬套自然无可避免。自董仲舒开创独尊儒术之时代始，历数两汉之古今文经学之争，魏晋南北朝之玄学佛学，唐朝之佛学以至宋明理学，最终以康有为等人为中古时代之结束。</p><p>冯友兰认为，中国哲学的精神之一，便是哲学背负着平衡入世与出世，现实与理想的矛盾。入世出世之对立，正如现实与理想主义的对立，而哲学的使命正是要在这两极对立中寻求它们的综合或许我们该在世俗中陶冶我们的性情。中国的哲学，以其所称的“直觉的概念” 出发，所以很多都是既入世又出世的道德。如今的我们似乎忘了原本的性情，在大流中随波逐流，每天除了工作挣钱，就是抱怨生活的不公平，很难静下心来读一本好书。在这样浮躁的状态下我们是不可能做到出世，我们应该明白现实与理想之间的差距是永远不可能消除的。人类一直在追求那能看到却不能到达的彼岸，那是人耐以生活的根本。由此而言，人们把生存看成是一种负担，一种难言的痛苦就可想而知了。</p><p>在中国哲学体系中，各时代的哲学家亦将此思想融入自己的生存之道之中。 儒家推崇“仁义”之道，也表现出神似欧陆浪漫主义诗哲追求的“暮春而游”之境，便是在其现实与抱负无法统一时，用哲学思想在两者之间寻求平衡，在世俗之中修养身心。对于我们而言，又何尝不是这样的情形。冯友兰说，哲学的功能不是为了增进对客观事物的认知，而是为了让人的心灵得到升华，超越现实世界，体验高于道德的价值。其实哲学并不是高高在上，高不可攀的学问，实际上它就深深的蕴涵在我们的日常生活当中，并且与我们的生活密切相关，密不可分。只不过我们缺少是让它们浮出水面，上升到哲学高度的理论思维而已。因此，我们更应该学习哲学，体验超乎现实的道德修养，吸取其精髓。在入世与出世之间修行品性，在喧闹的生活中创造自己的生活，在残酷的现实中建立自己强大的内心世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《中国哲学史》讲述了中国哲学的发展历史，打通了古今中外的相关知识，在有限的篇幅里融入了冯友兰先生对中国哲学的理解，是史与思的结晶，充满了人生的睿智与哲人的洞见。作者认为，哲学的功能在于提高人的心灵，超越现实世界，体验高于道德的价值。在学习哲学的过程中，人们没有智慧与不智慧之</summary>
      
    
    
    
    <category term="书评" scheme="http://naivertc.top/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>《1984》读后感之楚门的世界</title>
    <link href="http://naivertc.top/2018/10/05/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://naivertc.top/2018/10/05/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/</id>
    <published>2018-10-05T12:10:07.000Z</published>
    <updated>2022-03-14T15:54:33.383Z</updated>
    
    <content type="html"><![CDATA[<p>我是国庆假期的最后一天，睡了一会懒觉，九点起床。没有像昨天的那样惯性地选择去公司加班，而是约了二三好友去健身房完成了今日的训练，这应该是我多年来第一次选择上午去健身。这种感觉让我想起温斯顿在某一天下班后没有径直回家，而是在一种自己也弄不明白的驱动力下走向了无产者居住的街道。现在看来，温斯顿这个看似不经意的选择加速了他生命结束的进程，但与此同时也是遇见爱情的开始，也许他当时认为只是生命中普通的一天。</p><p>下午没有午睡而是在某巴克点了一杯无糖拿铁，选了一个安静的角落，拿出kindle并尝试着在把《1984》看完。这是一个美妙的下午，感觉自己很久没有像今天这样心无旁骛地阅读一本书，或许这是第一次。不负“众”望，我如愿以偿地的看完了这本书。期间甚至没有去一趟洗手间，也许是我太过认真，也许是因为洗手间的温度比大厅低5°的原因。看完后，我伸了一个懒腰，环视着周围的这个世界，脑海中闪过一丝疑虑：我当下所处的世界是否是客观真实的，亦或是它只是一个“楚门的世界”。</p><p>王小波杂文中常提到罗素先生的一句话：“须知参差多态，乃是幸福的本源”，这也是我对生活和这个世界的期许与认知。但也会有人觉得单一机械乃是幸福的本源。于我，定是前者。在接触《1984》之前，我坚信周围的世界是客观存在的，而非存在于我的主观意识中，更不愿意相信它是被有意创造出来的假象，并通过教育等多种的方式让我信以为真。但是，现在我会怀疑至少存在部分以前看似合理的真相其实是一种假象，我们也许就像电影《楚门的世界》中的男主角那样，从一出生便生活在已经设计好的剧本里面，而不自知。也许“过去”并不客观的存在，它只存在于记录和人的记忆中。但凡是记录和记忆一致的东西，即是“过去”。我们从小接受的教育大多数都源于课本，视课本中的知识为金科玉律，认同课本中的价值观，认为课本中描述的历史就是历史本身的模样。那是否存在一种可能性，课本中的知识是出于某种政治或其他的目的而被有意编排的，为的是让我们变成被期望的样子，以达到统一思想的目的。书中说谁掌控了过去就掌控了未来，谁掌控了现在就掌控了过去，而教育应该是达成这个目的成本最低也是效果的手段之一，也许没有之一。目前来看，这种教育的非常成功的，我们周围已经培养出相对数量的无产者。这些人崇拜着老大哥，如今老大哥已然是党的化身。大多数时候他们会沉浸于各种综艺娱乐节目或是精心制作的爱国纪录片中安然度日，这就是所谓的奶头乐策略。但倘若出现对民族或国家的批评或诋毁，他们便会发出如同仇恨日那般的怒吼和反击，而非自省，但他们这些过激行为又似乎被上层默许的。在他们眼里非黑即白，似乎没有可用于商榷的中间地带。温斯顿一直将希望寄托于无产者，殊不知无产者本身已经没有了主观思想，他们安逸于目前的生活现状，他们认同资本主义是万恶之源，他们看到的国外局势永远是动荡不安的。即便日子过得艰苦也不会有所察觉或不满，因为没有对比，在他们目光所及之处皆如此，便也心安理得。纵观人类历史，任何一次革命的成功都必须有一只思想先进的先锋队，只有在他们的带领和引导之下群众才有可能觉悟，才有可能拿起武器反抗统治阶级。单纯依赖于愚蠢的无产者是不可能自我觉悟的，可惜温斯顿并没有意识到这一点。而温斯顿作为外围党成员中的觉悟者，本应属于先锋队中一员，但是他已丧失了人身和思想的自由。这也是为什么核心党只对外围党成员进行密切的监视，而放任无产者自生自灭。一直以来我不明白当年毛为什么要发动群众进行一场由下而上的文化大革命，而不是至上而下的整顿。现在我知道了答案，因为当年的先锋队已经变质了，而他们现在就是被革命的对象。文革的初衷是利于无产者的，其最终失败源于毛对权力和人性的过度自信，权利的泛滥和人性的扭曲导致局势失控，酿成了一出人间惨剧。当他意识到这一点的时候，已经油尽灯枯，无能为力。历朝历代得罪过既得利益集团的统治者都会背负骂名，不论是雍正还是毛，都是如此。因为他们得罪的就是书写和掌控历史的人，这也是为什么《毛选》最后一卷成为了禁书。想起书中有一个有意思的细节，通过奥勃良的家是可以知道核心党是享有特权的，他甚至可以关闭电幕。同样，在文革那个“闭关锁国”的时代，特权阶层也从未与外部世界隔绝。</p><p>温斯顿是孤独的，具体来说是思想孤独患者。他不得不小心翼翼地隐藏着自己内心反动的思想，但又极度渴望找到志同道合的同志。当他第一次见到奥勃良便坚信对方是他苦苦找寻的那个人，那个可以带给他希望的人，我当时也深以为然。然而，最后他才知道这一切都是幻想，不过是一场游戏一场梦而已。从最开始他就走进了奥勃良为他精心设计的圈套里，包括却林顿的店铺，与奥勃良的密会，以及那本精神领袖果尔德施坦因的书都是有意的安排。可怜的温斯顿一直认为自己隐藏的很好，没有留下蛛丝马迹，却不知道思想警察其实早已翻阅过他的日记，只是又被原封不动地放回原处，即便是日记本上那颗白色的灰尘都被小心地还原。以奥勃良为代表的思想警察耐心地用来七年时间自导自演这出戏，看着温斯顿做困兽之斗，不断地引诱着他表露自己内心的真实想法。如果非要说有一丝欣慰，那就是温斯顿比《楚门的世界》中的男主角幸运一点，因为至少他与裘莉亚之间的感情是真实存在的，且裘莉亚也是他唯一的战友，他们有过一段快乐的时光。不过温斯顿在这场斗争中注定是要失败的，因为他面对的不是某一个个体，而是一个经验丰富的集团，里面都是身经百战的老戏骨。毋容置疑，类似的戏码他们已经经历过一次又一次，也将一代又一代永远一而再再而三地演下去。人作为个体终究是要死去的，而集团是可以以思想和意志的形式永远存在的。一个统治集团只要能够指定它的接班人就是同一个统治集团。党所操心的不是维系血统相传而是维系党本身的永存。由谁掌握权力并不重要，只要等级结构保持不变。想到这一点，不由得心生寒颤，似乎确实是如此的。</p><p>《V字仇杀队》中的有一句台词：“面具下面不只是血肉之躯，而是一种思想，思想是不怕子弹”。此前我一直认为肉体消灭是对一个人最极端的处决，其实不然，思想改造才是。一个人失去了独立思考的能力，已于行尸走肉无异。温斯顿最开始也不明白为什么自己因为思想罪被捕之后没有立即被处以极刑，而是遭受不断地拷问和折磨。原因正如奥勃良所说，党是不会满足于消极的服从，甚至是最卑躬屈膝的服从都不要。他们不会对异端分子进行简单地肉体毁灭，而是进行改造思想和争取内心，使异端分子在内心真心诚意的屈服。让异端分子带着脱离正轨的思想死去，只会激发更多的异端分子，这是不能被容忍的。在强大的国家机器面前，温斯顿最终被改造成功，他出卖了裘莉亚，背叛了爱，也背叛了原来的自己。他尝试做过抵抗，但最终让他屈服的不是无尽地拷打带来的肉体上的痛楚，而是人的一种无法不服从的本能：对每一个人来说，都各有不能忍受的事情，连想都不能想的事情，这并不牵涉到勇敢与怯懦的问题。对温斯顿来说，老鼠是无法忍受的，对他会产生一种无法抗拒的压力。这也足以说明思想警察对于人性已经有很深刻的研究，从而有了让人闻风丧胆的101号房。想必裘莉亚也是在同样的情况下出卖了他，至少我相信是这样的。所以说，他们没有并出卖彼此，他们只是屈服于人的本能罢了。</p><p>最后，也是我个人觉得是最让感到绝望的一点：人类历史似乎始终都处于不断轮回的过程，那个人人自由平等的天堂永远不会到来，但却一直被作为革命最初的愿景。革命的目的其实是为了建立专政，夺取权利的目的就是为了权利，而所谓“取消私有制”实际上意味着把财产集中到比以前更少得多的一批人手中，不同的是，新主人是一个集团，而不是一批个人。而历史的不断重演，从某种意义上来说是在不断地帮助统治者丰富和优化巩固政权的手段，而无产者则永远是无产者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我是国庆假期的最后一天，睡了一会懒觉，九点起床。没有像昨天的那样惯性地选择去公司加班，而是约了二三好友去健身房完成了今日的训练，这应该是我多年来第一次选择上午去健身。这种感觉让我想起温斯顿在某一天下班后没有径直回家，而是在一种自己也弄不明白的驱动力下走向了无产者居住的街道。</summary>
      
    
    
    
    <category term="书评" scheme="http://naivertc.top/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>《永远的三丁目的夕阳》观后感</title>
    <link href="http://naivertc.top/2018/09/03/%E3%80%8A%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%89%E4%B8%81%E7%9B%AE%E7%9A%84%E5%A4%95%E9%98%B3%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://naivertc.top/2018/09/03/%E3%80%8A%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%89%E4%B8%81%E7%9B%AE%E7%9A%84%E5%A4%95%E9%98%B3%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</id>
    <published>2018-09-03T14:34:07.000Z</published>
    <updated>2022-03-14T15:52:43.132Z</updated>
    
    <content type="html"><![CDATA[<p>我想如果不是朋友的推荐，我不大可能会主动接触这部影片。其中一个比较直接原因在于影片的名称挺不起眼的，再者这类题材的电影已经不再是我的首选了。在第一次听到影名的时候感到有点困惑：三丁目是什么意思？为什么是永远的三丁目的夕阳？这里先回答第一个问题：丁目是日语词汇，类似汉语中胡同的意思，日本的地址通常是：区-丁目-番-号组成。因此，片名翻译过来就是：永远的第三胡同的夕阳。接下来是我对于第二个问题的答案。</p><h5 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h5><p>影片故事背景是昭和30年，即公元1956年（昭和元年为公元1926年），日本制定“电力五年计划”，进行以电力工业为中心的建设，并以石油取代煤炭发电。日本经济至此不仅完全从二次大战中复兴，而且进入积极建立独立经济的新阶段。1955至1957年，日本出现了第一次经济发展高潮。日本人把这个神话般的繁荣，称为神武景气(Jinmu boom)。</p><p>此时已是战后十多年，百废待兴，全日本上下一副蒸蒸日上的繁荣景象。与此同时，人们也开始慢慢地从战争的阴影中走出来，而东京旧城区夕日町三丁目就是这个时代背景下日本平民生活的缩影。那个时代的日本人不像现在那样拘谨阴郁，有着当今日本人少有的对未来的坚定信念，每个人的努力就如同电影里展现的东京塔的逐渐建成一样，是可以实实在在看到成果的。再加上那时如“夕日町三丁目”一般的平民街巷所充满的人情味，怎能不让如今被沉重且无望的工作以及冷漠的人际关系所压迫的日本人们为之向往呢？</p><h5 id="童年记忆"><a href="#童年记忆" class="headerlink" title="童年记忆"></a>童年记忆</h5><p>影片里面描述的很多细节和画面勾起了我童年的记忆，是那种温馨且快乐的记忆。我觉得铃木一家与我家有一定的重叠。我的父亲同样的是一个脾气暴躁的人，但是有时候也会有一些暖心的举动。就像铃木会特意为六子准备圣诞节回家的车票一样，我的父亲也曾用家里一个星期的伙食费为我买了一款最新上市的MP4播放器。虽然现在这个播放器已经被时代淘汰，但是我一直都留在身边，铭记这份温情。我的母亲也同一平的母亲一样，是一个温柔贤惠的家庭妇女。记得电影中有一个画面：一平不愿意午睡，张开嘴巴对着电风扇发出哇啊哇啊的声音，脑袋也随着风扇来回摇摆，被母亲发现后立刻假装睡着的场景。记得小时候我也常在午睡的时候对着家里的电风扇说话，因为这样会听到被旋转的扇叶反射回来的回声，有种千里传音的感觉。然后每次发现母亲过来时，立即摆出一副假装睡着打呼噜的样子。现在想想母亲那会应该早就看穿了我的演技，我却每次都为此洋洋得意。另外一个让我印象很深的画面是：铃木一家终于盼来三目丁区第一台电视机时，整个街道的居民都前来道贺围观看新鲜。大家都围坐在电视机旁七嘴八舌地议论着，当电视画面出现时全都目不转睛地盯着屏幕。整个屋子里时而安静、时而欢呼，一片其乐融融的景象。巧的是类似的情景也曾发生在我的家里。在我大概小学三年级的时候，我的父亲挣了一点小钱，于是给家里买了一台牡丹牌的彩色电视，那时候也算是村里的一件大事，以至于那会我在街坊邻居面前走路说话都比较嘚瑟。一般邻居们都会在吃过晚饭后陆陆续续来到我家，然后围坐在电视机旁有说有笑地看着电视，各抒己见地讨论着剧情。后来，随着生活水平地提高，越来越多的家里都配备了电视机，慢慢地晚饭后家里也开始变得清静。</p><h5 id="隐形婚戒"><a href="#隐形婚戒" class="headerlink" title="隐形婚戒"></a>隐形婚戒</h5><p>茶川这位以文学家自居的二流作家，在影片的前半部更多地是充当搞笑的配角，给人一种懦弱无能的感觉。然而，广美和淳之介出现彻底地改变了他的生活，也第一次让他有了家的感觉。看到茶川和广美的爱情，让我又理由相信那个是一个即便物质上贫穷匮乏，只要内心善良与真诚，同样有机会能够打动女孩子芳心的年代。当茶川战战兢兢地从口袋里面拿出用所有积蓄买来的盒子时，我以为盒子里至少会是一颗小的钻戒。然而，接下来的对话成为了整部影片最打动我的莫过于茶川向广美表白的镜头。茶川：“对不起，跟我结婚吧。我的钱虽然只够买个盒子，不过很快…盒子里的东西，我的稿费再多一点的话…”。广美：“给我戴上，那个…总有一天能买来的戒指”。虽然这段感情最终因为广美身不由己地离开而告一段落，但是当广美站在歌舞厅的天台，对着夕阳，伸出自己右手无名指，望着那枚隐形的戒指时，我觉得此生能拥有过这样一段爱情本身就是很幸福知足的事情。我们向往那个年代是因为我们内心都渴望得到一份真挚的爱情，是因为对方爱你这个人才选择和你在一起，合于性格，久于善良，忠于人品，亦或是是始于颜值，陷于才华。那个年代时间过得慢，人们对物质的需求也不高，一生也许真的只够爱一个人而已。现如今结婚的高门槛已经成为很多自由恋爱的年轻人以逾越的障碍，在现实面前而被迫选择结束的感情也已屡见不鲜。我想除了外界的因素之外，现在的爱情也许本身就缺乏一些真诚。我并不反对现在的婚姻价值观，作为女性通过自己的自然属性选择社会属性更优的男性，从物种进化的角度来说是完全符合自然法则的，可以让更好的基因得到更佳的资源配置。正因如此，那个更在意个人情感的年代才更让人怀念。</p><h5 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h5><p>最后说说我对这部影片的总体感受。东京铁塔作为日本标志性建筑，象征着日本经济腾飞和民族再次崛起。影片的首尾镜头与东京铁塔修建到竣工的时间节点动态呼应。而与之对应的是一种静态的永恒，即第三胡同的居民的淳朴善良，以及街坊邻居之间的真挚情感。这种美好的记忆就如同夕阳一般，很美，但已是近黄昏。不难想象随着城市化建设的推进，三丁目暖黄色基调的原貌必会成为过去，取而代之的定是冷灰色基调的现代建筑，留下的只有三丁目这个地名。电影的最后一个镜头是远方温暖绚丽的夕阳，夕阳下矗立着已经竣工的东京铁塔。铃木一家面向着夕阳，一平说：“明天，后天，就算50年后，夕阳也会一直这么美”。如今已是50多年后的今天，我想关于夕阳是否依旧那么美，大家心里都有自己的答案。虽然我并不认为这是导演的故意隐喻，这也许只是个巧合。当新的时代以一种高姿态来临，那个“大家诚诚恳恳，说一句，是一句”的社会已如夕阳的余晖般慢慢地消逝，如斯人的背影般渐行渐远。不过，这也正是这部影片触动我的地方，它带给我一种翻阅旧相册时的温暖和感动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我想如果不是朋友的推荐，我不大可能会主动接触这部影片。其中一个比较直接原因在于影片的名称挺不起眼的，再者这类题材的电影已经不再是我的首选了。在第一次听到影名的时候感到有点困惑：三丁目是什么意思？为什么是永远的三丁目的夕阳？这里先回答第一个问题：丁目是日语词汇，类似汉语中胡同</summary>
      
    
    
    
    <category term="影评" scheme="http://naivertc.top/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>还房贷最省钱的理财方法</title>
    <link href="http://naivertc.top/2018/08/21/%E8%BF%98%E6%88%BF%E8%B4%B7%E6%9C%80%E7%9C%81%E9%92%B1%E7%9A%84%E7%90%86%E8%B4%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://naivertc.top/2018/08/21/%E8%BF%98%E6%88%BF%E8%B4%B7%E6%9C%80%E7%9C%81%E9%92%B1%E7%9A%84%E7%90%86%E8%B4%A2%E6%96%B9%E6%B3%95/</id>
    <published>2018-08-21T13:39:07.000Z</published>
    <updated>2022-03-14T15:48:14.312Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了紫竹张先生的一篇名为<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDczNTk5MQ==&amp;mid=2651730253&amp;idx=1&amp;sn=f0d5cacc1d180fdb3407311affbb89f2&amp;chksm=80745e55b703d7430507e78469a2a3f4639ef30f8b43d3d6574d8328ae4869d6be49ea23088b&amp;mpshare=1&amp;scene=1&amp;srcid=0820Xnj0x8xfXItvqdGxpfLR&amp;key=fee773bf85a574f5c9b8985f5c4ee09210d769c87a720f5652cfec05e148fbf688c0964752d7765499411b591f4c39829f44009bd07580279982335beb674ad9481f3fa5b1cee2fc8a241c44bde6b8f9&amp;ascene=0&amp;uin=MjM2ODI5NjEyMA==">还贷款最省钱的理财方法</a>的文章，里面讲述的经济学知识与我们日常生活息息相关，却又是最容易被忽视和误解的部分。在一口气看了两遍感觉收获不小之后，觉得很有必要总结一下，作为备忘。</p><h5 id="最省钱的还贷方式"><a href="#最省钱的还贷方式" class="headerlink" title="最省钱的还贷方式"></a>最省钱的还贷方式</h5><p>在国内最常见的还贷方式有两种，分别是等额本金和等额本息：</p><ol><li><p>等额本金的月供是由每个月固定的还款本金数额加上当前未还款总额的利息组成。这种还款方式的特点是前期月供数额较大，后面随着未还总额的减少，利息也越来越少。</p></li><li><p>等额本息采用浮动本金还款，结合贷款年限计算出每个月还款的平均数。特点是每个月的还款金额几乎一样，前期月供中利息占的比重较大，后期的月供则主要是本金。</p></li></ol><p>结合上述两种还贷方式的特点容易产生一种误解，即大家会认为等额本息前期还的都是利息，有一种被银行剥削的感觉，因此倾向于提前还款，能还多少还多少。假如前面三五年没能提前还款，后面再提前还款就没有意义了，因为该交的利息都已经交了。这种观点表面上很有说服力，但仔细想想是完全错误的。</p><p>记住两个前提，一是等额本金和等额本息使用的利率都是一样的，二是银行房贷的利率较于其他大多数的贷款利率都低且贷款额度更大和年限更长。然后，我们分别从银行和个人的角度来分析。首先，从银行的角度来说，银行借出去多少钱就应该收多少利息，而收取利息的基数就是你尚未还清的贷款总额，也就是说你当前欠银行的钱越多就应该支付越多的利息。因此，从这个角度来说等额本金和等额本息对银行来说没有熟好熟劣的差别。等额本金因为前期还给银行的本金较多导致后期利息减少，但是银行可以用你还的这些本金继续贷款给其他人获取利息甚至是更高的利息。再者，从个人的角度来说，你欠银行多少钱就应该付多少利息。假设在经济能力允许且你口袋里的钱没办法获得一个高于贷款利率的收入，那么选择等额本金还贷从某个角度来说也算是一种理财方式。但是如果你手中的钱能够创造更高的收益，那么使用等额本金的方式就不一定是个好选择了。但是更多的人属于后者，在支付首付之后是储蓄大幅下降，所以会选择等额本息的方法以减缓经济压力。此外如果使用其他的贷款方式所需要支付的利息会更高。既然我们没有足够的钱来偿还贷款也就没有理由抱怨银行收取利息了。因此，在个人经济能力有限的前提下，选择等额本息对个人来说是最划算的。</p><p>此外，我们从银行贷款的利率只是名义上的利率，而非实际利率。原因在于中国未来都将处于不断通货膨胀的趋势，意味着人民币也不断在贬值。因此，你的实际利率等于名义上的履历扣除通货膨胀率，结果是实际利率值变成一个很低的值。接下来解释为什么说未来中国的通货膨胀会一直继续下去。</p><p>众所周知，过去的三十多年，中国通过改革开放实现从计划经济向市场化经济的转变，并且加入了WTO（世界贸易组织）。随着世界各国的经济全球化，中国的经济的决定权已经不在中国政府手上。当前全球经济根基的经济学理论源自于美国，该西方经济理论体系认为：</p><ol><li><p>适当的通货膨胀有助于经济发展，能够刺激生产和增加投资。人民倾向于花出手中的现金购买其他保值资产从而刺激了消费和生产，以及提供了更多的就业岗位。而通货紧缩则恰恰相反，人民倾向于存储现金以便提高未来的购买力。</p></li><li><p>当政府出现财政危机且需要增加财政收入时，一般会采取三种方式：一是增加税收；二是向公众借债；三是增加货币供应。前两种方式在政治上不得人心，所以一般都采取第三种方式。</p></li><li><p>政府不应该任由经济危机发生，政府有义务通过量化宽松（间接增印钞票）的方式来“熨平”经济波动，避免社会出现动荡，即便代价是通货膨胀。</p></li></ol><p>这种理论体系在西方大行其道，直接导致布雷顿森林货币体系的崩溃，美元和黄金脱钩，从此美元不断通货膨胀，全球货币也随之一路贬值，人民币自然不能独善其身。</p><p>有一个典型的通货膨胀的例子是：在1989年北京房价在1600-1900，当时的大学生工资是89元左右，每个月节衣缩食可以攒下50元。假设当时你倾其所有凑够首付，按月供60进行还贷款，等额本息三十年，到了2019年刚好还完。然而，当年你每个月要还的“巨款”60元，现在只能买一个披萨。</p><p>结合上述内容，最划算的贷款方式是使用等额本息的方式贷款最大金额，分三十年（最长还款年限）还款。此外，即便后面有了一定的储蓄也不要提前还款。原因在于流动资金具有一定的溢价效应。虽然某些现金类的理财产品收益率可能不如房地产投资，但是我们在投资房地产之余一定要配置一定比例的现金资产。因为固定资产的流动性很差，变现速度慢，而现金类产品能在你急性用钱的时候快速变现，以解燃眉之急。</p><p>最后一个建议是不要让你的公积金账户有闲置的资金。公积金有一个特性，除了还房贷之外很难提现，而且存款利率极低。如果你的公积金除了还房贷之外还有剩余，那么这些存款就是没有流动性的死款，存款越多亏的越多。结果就是名义上里面的钱是你的钱，实际上你却没有支配权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看了紫竹张先生的一篇名为&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNDczNTk5MQ==&amp;amp;mid=2651730253&amp;amp;idx=1&amp;amp;sn=f0d5cacc1d180fdb3407311affbb</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>科斯定律-从社会成本看问题</title>
    <link href="http://naivertc.top/2018/08/16/%E7%A7%91%E6%96%AF%E5%AE%9A%E5%BE%8B-%E4%BB%8E%E7%A4%BE%E4%BC%9A%E6%88%90%E6%9C%AC%E7%9C%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://naivertc.top/2018/08/16/%E7%A7%91%E6%96%AF%E5%AE%9A%E5%BE%8B-%E4%BB%8E%E7%A4%BE%E4%BC%9A%E6%88%90%E6%9C%AC%E7%9C%8B%E9%97%AE%E9%A2%98/</id>
    <published>2018-08-16T14:53:07.000Z</published>
    <updated>2022-03-14T15:49:17.712Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解到一个很棒的经济学概念：社会成本问题。这是之前从未接触到的概念，给了我一个全新的思考问题的角度，心中多少有点欣喜。奈何这个概念有点深奥难懂，所以试着写出自己的理解以加深理解。</p><p>社会成本问题在经济学中有着非常重要的政策含义。只有理解了社会成本问题，才能顺应社会和市场的基本运行规律，制定出因势利导的经济政策。</p><p>最早把社会问题成本讲清楚的是罗纳德·斯科。人们一直信奉的用来解决纷争的金科玉律是：“权利的刑事应以不伤害别人的权利为界”。而斯科认为所有的伤害都是相互的，对于纷争的双方，谁避免意外的成本最低，谁的责任就最大。在面对具体的案例时，人们容易不自觉地掺入个人的情感和主观判断，而只有斯科看到了纠纷背后与资源争夺相关的、客观的经济本质。</p><p>斯科把产权或侵权的案件都看作是人们对稀缺资源的平等争用。为了解决这些纷争，进而形成了科斯定律：在交易费用为零或足够低的情况下，不管资源最初的主人是谁，资源都同样会流到价值最高的用途上。</p><p>然而现实生活中交易费用很高，很多资源是没有办法落到使用价值更高的人手里。因此，我么有时要鼓励第三方-例如政府-在知道资源怎样使用最合理、在非常有把握的情况下，使用手中的权利对资源进行重新分配。而这就是所有的制度、风俗、习惯以及政府、法院存在的根源理由-对资源、责任、权利进行初始界定。我们可以把社会上通行的制度、习俗和道德规范，都看成为了减少重复商议的成本而逐渐固定下来的解决纠纷的办法。</p><p>经济学本质就是研究这个世界客观地运行规律，这恰恰是经济学最具有魅力的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近了解到一个很棒的经济学概念：社会成本问题。这是之前从未接触到的概念，给了我一个全新的思考问题的角度，心中多少有点欣喜。奈何这个概念有点深奥难懂，所以试着写出自己的理解以加深理解。&lt;/p&gt;
&lt;p&gt;社会成本问题在经济学中有着非常重要的政策含义。只有理解了社会成本问题，才能顺</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>经济学概念-租</title>
    <link href="http://naivertc.top/2018/08/11/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5-%E7%A7%9F/"/>
    <id>http://naivertc.top/2018/08/11/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5-%E7%A7%9F/</id>
    <published>2018-08-11T15:25:07.000Z</published>
    <updated>2022-03-14T15:49:06.793Z</updated>
    
    <content type="html"><![CDATA[<p>最近在《姚兆丰经济学讲义》看到一个“租”的概念。从经济学的角度进行了重新定义，看完之后云里雾里、似懂非懂，于是做点笔记以加深理解。</p><p>有一种资产，不以收费的变化而变化，这种资产带来的收入就是租。租就是相对资产的付费，这里说的资产是广义上的，包括土地、矿产、才能以及特权，只要能够带来收入的就是资产，而对资产付费就是租。</p><p>每个人都享受一定程度的租。比如我们在平时上班时抽出半个小时刷朋友圈，老板并不会因此开除你或少付工资，这样你就赚了半小时的租。而且这一部分的租是属于旱涝保收的。然而现实生活中，随着时间和竞争条件的变化，真正让你旱涝保收的租是绝对不存在而是相对的存在的。</p><p>基于成本是放弃的最大代价这一前提，如果你对目前的工作感到满意，觉得下一份工作的收入会比现在低很多，那你就是在享受当前工作带来的租；相反，如果你觉得你另外一份工作收入会高很多，那你选择留在当前岗位的成本就非常高。此外，即使你不换工作留在当前的岗位上，如果你每天不管努力工作还是得过且过，结果收入都一样，那你选择懒散度日的态度，就是在享受租；但如果努力或懈怠带来的收入会有明显差异，那么你选择懈怠就要付出很大的成本。</p><p>不妨记住一句话：人人都是资本家，因为当你认识到自己是资本家之后，会把注意力放到提升自己的租值上，而不是所谓的被剥削。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在《姚兆丰经济学讲义》看到一个“租”的概念。从经济学的角度进行了重新定义，看完之后云里雾里、似懂非懂，于是做点笔记以加深理解。&lt;/p&gt;
&lt;p&gt;有一种资产，不以收费的变化而变化，这种资产带来的收入就是租。租就是相对资产的付费，这里说的资产是广义上的，包括土地、矿产、才能以</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>OSX开发之Safari App Extension初探</title>
    <link href="http://naivertc.top/2018/08/06/OSX%E5%BC%80%E5%8F%91%E4%B9%8BSafari%20App%20Extension%E5%88%9D%E6%8E%A2/"/>
    <id>http://naivertc.top/2018/08/06/OSX%E5%BC%80%E5%8F%91%E4%B9%8BSafari%20App%20Extension%E5%88%9D%E6%8E%A2/</id>
    <published>2018-08-06T15:04:07.000Z</published>
    <updated>2018-08-19T09:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Safari-App-Extension简介"><a href="#Safari-App-Extension简介" class="headerlink" title="Safari App Extension简介"></a>Safari App Extension简介</h4><h5 id="什么是Safari-App-Extension"><a href="#什么是Safari-App-Extension" class="headerlink" title="什么是Safari App Extension"></a>什么是Safari App Extension</h5><p>Safari App Extension，即Safari浏览器应用拓展。它是苹果新推出的一种Safari扩展开发技术，最低支持Safari10.0，主要由三个部分组成分别是：</p><ul><li><p>Safari App Axtension: 扩展app本身，使用JS、CSS等前端脚本语言。主要功能是包括两方面：</p><ol><li>在插件运行之前注入js和css代码到当前的Safari浏览器页面，进而实现对页面的增删改查等功能</li><li>调用Safari提供的JS API接口与Containing app进行交互通信。</li></ol></li><li><p>Containing App: 扩展app的容器，属于Native App。主要功能包括四方面：</p><ol><li>配置和加载扩展app</li><li>与扩展app进行通信</li><li>提供可在Safari工具栏显示的原生界面</li><li>与Host App进行交互通信和共享数据</li></ol></li><li><p>Host App: 主程序，也属于Native App。主要功能包括三方面：</p><ol><li>加载Containing App</li><li>与Containing app通信交互</li><li>发布Safari App Extension到Apple App Store</li></ol></li></ul><p>结合上述的分析，Safari App Extension可使用两种组合的形式发布产品。一种是三个部分的App同时存在；另外一种是Host App只是作为发布工具，仅在第一次打开并完成扩展app安装之后就不再需要，因为安装好的扩展可在Safari-&gt;偏好设置-&gt;扩展中找到。</p><h5 id="与-Safari-Extension-的异同"><a href="#与-Safari-Extension-的异同" class="headerlink" title="与 Safari Extension 的异同"></a>与 Safari Extension 的异同</h5><p>Safari App Extension和Safari Extension的名称很相似，以至于在最开始研究的时候，我错以为二者是同一个东西，结果瞎忙活的一天才发现自己南辕北辙。不过，二者确实存在一些相似的地方。<a href="https://developer.apple.com/documentation/safariservices/safari_app_extensions/converting_a_legacy_safari_extension_to_a_safari_app_extension?language=objc">苹果的这篇官方文档</a>具体介绍了如何将Safari Extension转换为Safari App Extension。简单来说，二者共同点在于js和css代码是完全可以复用的，不同的地方是Safari Extension的配置、开发以及发布平台都是基于Safari浏览器，而Safari App Extension则是基于Xcode，且产品发布平台是Apple App Store。</p><h4 id="创建一个Safari-App-Extension"><a href="#创建一个Safari-App-Extension" class="headerlink" title="创建一个Safari App Extension"></a>创建一个Safari App Extension</h4><ol><li><p>创建</p><p> 因为Safari App Extension是以插件（plugin）的形式存在于Host App中的，因此需要首先创建一个Host App，也就是普通的Mac OSX的应用程序。然后再添加一个Safari App Extension的Target即可。</p></li><li><p>配置info.plist</p><p> Safari App Extension在被加载之前，Safari浏览器会通过读取info.plist文件以获得扩展的一些基本信息。</p><p> <strong>NSExtension</strong>，包括：</p><ul><li><p>NSExtensionPointIdentifier：定值，必须是com.apple.Safari.extension，表示Safari扩展</p></li><li><p>NSExtensionPrincipalClass：扩展的核心类名，默认是SafariExtensionHandler类，里面一些部分实现了NSExtensionRequestHandling和SFSafariExtensionHandling协议，作为与Safari扩展通信和交互的接口。</p></li><li><p>SFSafariContentScript：用于指定注入的js脚本，以数组的形式表示，在扩展加载之前注入Safari浏览器当前的tab页。缺省值是只有一个文件script.js，也可以注入多个js文件，注入顺序依据数组中的顺序。</p></li><li><p>SFSafariToolbarItem：用于配置Safari扩展在工具栏中按钮的类型、图片以及tooltip等。按钮类型包括comman、popover等。</p></li><li><p>SFSafariWebsiteAccess：包括Allowed Domains和Level两个属性，分别表示允许访问的网站域名列表和网页访问权限。其中Level可以是Some和All，分别表示部分访问和无限制访问。</p></li></ul><p> <strong>NSHumanReadableDescription</strong></p><p> 顾名思义，用于向用户阐述扩展基本功能的文字描述。在Safari浏览器的扩展管理器中选择某个插件就会显示对于的描述。 </p></li><li><p>运行 </p><p> 这里有一个坑，如果是Xcode中运行Host App并不会加载包含于其中的Safari App Extension，解决办法是编辑Safari App Extension的scheme，指定可执行文件为Host App，再编译运行即可。此外，如果是双击的方式打开某个已经编译好的Host App也会自动加载其中的扩展插件。然后在Safari-&gt;Preference-&gt;Extensions中可看到对应的扩展。值得注意的是，如果扩展插件不是从Apple App Store中下载的，那么是不能正常加载的，即便App在本地已经打包签名也一样。解决方法是勾选Safari Menu-&gt;Develop-&gt;Allow Unsigend Extensions即可。</p></li><li><p>调试 </p><p> Safari App Extension调试有两个值得注意的地方，第一，因为扩展插件是依附于Host App运行的，因为Xcode默认激活的是Host App进程，因此想要设置断点调试扩展插件，需要手动激活扩展进程。步骤是：在通过Xcode编译运行扩展进程之后，进入Safari Menu-&gt;Debug-&gt;Attach to process，选择对应的扩展进程。第二，在扩展插件中添加的NSLog调试信息不能在Xcode的终端输出，只能在电脑的控制台中查看。但是，lldb可以正常使用和输出。<a href="https://medium.com/@euginedubinin/ios-debugging-application-extension-without-a-host-app-89abf35a36af">更多细节参考这篇博客</a></p></li></ol><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>一个关于Safari App Extensions的Demo:<a href="https://github.com/icebergcwp1990/SafariAppExtensionDemo">GitHub Demo</a></p><p>苹果2016年WWDC关于Safari App Extensions的介绍：<a href="https://developer.apple.com/videos/play/wwdc2016/214/">Extending your App with Safari App Extensions WWDC 2016</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Safari-App-Extension简介&quot;&gt;&lt;a href=&quot;#Safari-App-Extension简介&quot; class=&quot;headerlink&quot; title=&quot;Safari App Extension简介&quot;&gt;&lt;/a&gt;Safari App Extension</summary>
      
    
    
    
    <category term="专业" scheme="http://naivertc.top/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="OSX" scheme="http://naivertc.top/categories/%E4%B8%93%E4%B8%9A/OSX/"/>
    
    
    <category term="OSX" scheme="http://naivertc.top/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>经济学中的成本</title>
    <link href="http://naivertc.top/2018/08/02/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://naivertc.top/2018/08/02/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%88%90%E6%9C%AC/</id>
    <published>2018-08-02T14:48:07.000Z</published>
    <updated>2022-03-14T15:49:12.338Z</updated>
    
    <content type="html"><![CDATA[<p>最近在《薛兆丰经济学讲义》一书中看了“成本”这一概念在经济学中的定义，这与我过去的理解截然不同。</p><p>书中专门有一章是讲成本的概念，可见成长在经济学中占有非常重要的地位。书中说如果我们对成本的概念有了深刻的理解，就可以说对经济学了解了一半。</p><p>我以前对于成本的理解是做某件事情需要付出的代价，包括物质、金钱和劳动力等。然而，书中对成本的定义是：成本是放弃了的最大代价。换言之，如果做一件事情没什么可放弃的，也就不存在成本。比如，如果你选择做事情A的，那么就不能做事情B、C、D、E…。那么你做事情A的成本就是你所放弃的其他选项中价值最高的那个。</p><p>与成本容易混淆的一个概念是沉没成本。沉没成本是指那些已经发生但是不可收回的支出。比如你买票去看一场电影，但是看了10分钟之后你觉得这个电影不好看，最合适和做法就是马上离开电影院。此时，买电影票的钱已经沉没了，不可再放弃，也就不再是成本了。但是很少有人会在这种情况下果断地离开电影院。</p><p>既然成本的定义是“所有放弃了的选项中价值最高的那个”，但问题是所有放弃的选项并没有实现，我们又如何知道自己放弃东西的价值呢？答案是，这个价值只能靠想象。这正是成本深奥的原因所在。这个想象空间吸引了众多经济学家在成本的概念上下大功夫。他们充分挖掘了想象空间，分析公共品使用的成本、制度变迁的成本、社会成本、竞争本身带来的成本，将我们对世界的理解拓宽到前所未有的领域。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在《薛兆丰经济学讲义》一书中看了“成本”这一概念在经济学中的定义，这与我过去的理解截然不同。&lt;/p&gt;
&lt;p&gt;书中专门有一章是讲成本的概念，可见成长在经济学中占有非常重要的地位。书中说如果我们对成本的概念有了深刻的理解，就可以说对经济学了解了一半。&lt;/p&gt;
&lt;p&gt;我以前对</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>经济学的基础：稀缺</title>
    <link href="http://naivertc.top/2018/07/25/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%A8%80%E7%BC%BA/"/>
    <id>http://naivertc.top/2018/07/25/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%A8%80%E7%BC%BA/</id>
    <published>2018-07-25T14:28:07.000Z</published>
    <updated>2022-03-14T15:49:01.345Z</updated>
    
    <content type="html"><![CDATA[<p><strong>稀缺与歧视</strong></p><p>稀缺是人类一直面对的问题，也是客观存在的事实。稀缺的含义非常之广，不仅指矿产、森林和能源等有形资产的匮乏，还有空气、美貌、天资、意志力和时空等无形资产稀少。</p><p>此外还有很多不易觉察到的稀缺资源，比如说地理位置的稀缺，如北上广这些一线城市的地理位置是稀缺的。另外信任也是稀缺的，不是可以随便建立起来的。同学之所以重要，是因为同学决定了你将来社交的圈子、工作层次。许多人读书的首要目的就是为了与同学建立信任这一项长期投资。</p><p>稀缺之所以一直客观存在，主要由两个原因：一是我们想要的东西别人也想要；二是人的需求在不断变化和升级，人的欲望是无止境的。</p><p>因为资源的稀缺，人们就不得不对资源的用途进行选择，而一旦做出选择就意味着存在区别对待，而区别对待就是歧视。（我觉得歧视在此处应该是中性词）</p><p>稀缺、选择、区别对待和歧视这四个概念，其实是一体的，只要有一个就意味着同时有其他三个。因为稀缺是客观存在的，因此歧视也是客观存在的。</p><p>既然不能逃避歧视，那么久只能直面歧视。有时候我们抱着平等主义的思想，试着消除歧视，结果却是产生了新的歧视，这也被称之为逆向歧视。</p><p>所以说，歧视不是问题，如何歧视才是问题。</p><p><strong>中年人的魅力</strong></p><p>今天听了梁实秋先生的文章《中年人的魅力就在如此》，里面的观点我个人比较赞同。虽然尚未进入中年，但是中年的困境的没办法逃避的，遂记录自勉：</p><ol><li><p>某个时期，某个社会，即使所有的青年人和老年人都中魔了，只要中年人不荒唐，事情就怀不到哪里去。</p></li><li><p>到了该自立的年岁还不知道精神上的自立，这是中国很多中年人的共同悲剧。</p></li><li><p>中年人最容易犯的毛病，是把一切希望寄托于自己的老年。</p></li><li><p>如今天天节衣缩食、不苟言笑、忍气吞声，都是在争取一个有尊严、有资材、有自由的老年。</p></li><li><p>我们无数次看到，一个窝囊的中年抵达不到一个欢乐的老年。这正像江河，一个浑浊的上游不可能带来一个清澈的下游。</p></li><li><p>习惯了郁闷的，只能延续郁闷；习惯了卑琐的，只能保持卑琐。而且，由于暮色苍茫间的体力不支，有朋散失，郁闷只能更加郁闷，卑琐只能更加卑琐。</p></li><li><p>中年人失去方寸的主要特征是忘记了自己的年龄，一会儿要别人像对待青年那样关爱自己，一会儿又要别人对待老人那样尊重自己。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;稀缺与歧视&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;稀缺是人类一直面对的问题，也是客观存在的事实。稀缺的含义非常之广，不仅指矿产、森林和能源等有形资产的匮乏，还有空气、美貌、天资、意志力和时空等无形资产稀少。&lt;/p&gt;
&lt;p&gt;此外还有很多不易觉察到的稀缺资源，比如说地</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>英语发音规则总结</title>
    <link href="http://naivertc.top/2018/07/24/%E8%8B%B1%E8%AF%AD%E5%8F%91%E9%9F%B3%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
    <id>http://naivertc.top/2018/07/24/%E8%8B%B1%E8%AF%AD%E5%8F%91%E9%9F%B3%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</id>
    <published>2018-07-24T15:05:07.000Z</published>
    <updated>2019-05-14T15:51:00.134Z</updated>
    
    <content type="html"><![CDATA[<p><em>语句最常用的功能就是口语表达，一切的规则都是为了轻松且简单的表达！</em></p><p>最近在学习ESLPod的“Introducation to the United States”系列，在跟读的时候感觉挺吃力，一方面是因为对音标熟练程度不够，另一方面就是对英语发音规则缺乏认知。秉着主动学习的态度，通过在网路上查阅资料，对英语发音规则有如下总结。</p><p><em>英语发音规则的建立在对音标熟练且准确掌握的基础之上！</em></p><p>英语发音规则除了连读还包括浊化、爆破、同化、异化、缩读和略读等。大致包括七大技巧，它们分别是：</p><p><em>注：音标用-连接的地方表示要连读</em></p><p><strong>第一大技巧 连读的两大规律</strong></p><ol><li><p>词尾辅音+词首元音<br> eg: Time is up =&gt; [taim-iz-ʌp]</p></li><li><p>词尾元音+词首元音</p><p> (1). 在遇到前一个词是以[ei][ai][ɔi][i:][i][e]这几个元音结尾的情况，加[j]连读</p><p> eg: Hurry up =&gt; [hʌri-j-ʌp]</p><p> (2). 在遇到前一个词是以[aʊ][u:][ʊ]这个几个元音结尾时，加[w]连读</p><p> eg: How often do you swim =&gt; [haʊ-w-ɔfən]</p></li></ol><p><strong>第二大技巧 浊化的两大规律</strong></p><p>所谓浊化就是把清辅音读成浊辅音</p><p>清辅音：[p][t][k][f][s][θ]</p><p>浊辅音：[b][d][g][v][z][ð]</p><ol><li><p>元音+清辅音+元音</p><p> eg: letter =&gt; [‘lɛdɚ]  water =&gt; [ˈwɔdɚ] , stay out of this matter =&gt; [stei-y-aʊ-dv-ðis mædɚ]</p></li><li><p>元音+T+L</p><p> eg: battle =&gt; [bædl] cattle =&gt; [kædl]</p></li><li><p>Flat T的浊化</p><p> 3.1 在元音[ɚ]的前后</p><p> eg: artist =&gt; [ardst]  thirty =&gt; [θɚdi]</p><p> 3.2 两个tt并存时</p><p> eg: batter =&gt; [bædɚ]</p><p> 3.3 t在[əl]之前</p><p> eg: hospital =&gt; [hɑspɪdl]</p><p> 3.4 一般情况下，t在n和e之间，则t通常不发音。</p><p> eg: printer =&gt; [prɪn’ɚ]  center =&gt; [cen’er]<br>  winter =&gt; [win’er]   presented =&gt; [presen’ed]</p></li></ol><p><strong>第三大技巧 爆破的四大规律</strong></p><ol><li><p>爆破音略读：当前一个单词的词尾是爆破音（[p][t][k][b][d][g]）且后一个单词的词首也是爆破音，则省略前一个单词的词尾。</p><p> eg: take care =&gt; [tei-kɛr]</p></li><li><p>不完全爆破：所谓不完全爆破就是对于需要爆破的音，我们仅仅摆出对于的口型而不发出声音。</p><p> (1). 词尾爆破音+摩擦音（[f][s][θ][v][z][ð][r][j][w][ʃ][ɛ]）</p><p> eg: I’m almost there =&gt; [im ɔlmos(t) ðɛr]</p><p> (2). 词尾爆破音+破擦音[tʃ][dʒ][ts][dz][tr][dr]</p><p> eg: That joke =&gt; [ðæ(t) dʒok]</p></li><li><p>鼻音爆破省略：同一意群内，爆破音在鼻音[m][n][ŋ]前，爆破音省略以停顿代替</p><p>eg: Good night =&gt; [gʊ(d) nait]</p></li><li><p>舌边音爆破省略：爆破音+舌边音[l]</p><p> eg: It’s deadly =&gt; [it z dɛ(d)li] , Old lady =&gt; [ol(d) ledi]</p></li></ol><p><strong>第四大技巧 同化的二大规律</strong></p><ol><li><p>相互同化</p><p> (1). /t/+/j/-&gt;/tʃ/</p><p> eg: I got you =&gt; [i gɑ tʃ u]</p><p> (2): /d/+/j/-&gt;/dʒ/</p><p> eg: Did you =&gt; [Di dʒ u]</p><p> (3) /s/+/j/-&gt;/ʃ/</p><p> eg: God bless you =&gt; [Gɑ blɛ ʃ u]</p><p> (4) /z/+/j/-&gt;/ʒ/ </p><p> eg: How is your boyfriend =&gt; [Haʊ iz ʒ ʊr]</p></li><li><p>顺向同化：主要同于词尾加s和ed的情况，这两个音都存在清辅音和浊辅音两种发音，具体发音与该音的前一个音标的清|浊一致。</p><p> (1). 名词的复数</p><p> eg: friends =&gt; [frɛndz] , books =&gt; [bʊks]</p><p> (2). 第三人称单数</p><p> eg: works =&gt; [wɜːks]</p><p> (3). 过去式或过去分词</p><p> eg: looked -&gt; [lʊkt]</p></li></ol><p><strong>第五大技巧 异化：所谓异化就是当清辅音夹在/s/和元音之间时，清辅音发生浊化</strong></p><ol><li><p>sp+元音</p><p> eg: speak =&gt; [sbi:k]</p></li><li><p>sk+元音</p><p> eg: school =&gt; [sgʊl]</p></li><li><p>st+元音</p><p> eg: start =&gt; [sdɑrt]</p></li><li><p>str+元音</p><p> eg: strange =&gt; [sdrendʒ]</p></li></ol><p><strong>第六大技巧 缩读：缩读规律性不强，不能一一列举</strong></p><ol><li><p>常见缩读</p><p> (1). want to =&gt; [wanna]</p><p> (2). be going to =&gt; [be gonna]</p><p> (3). got to =&gt; [gotta]</p><p> (4). because =&gt; [‘cause]</p><p> (5). out of =&gt; [outta]</p><p> (6). you =&gt; [ya]</p><p> (7). what is the =&gt; [what’sa]</p><p> (8). sure =&gt; [sher]</p><p> (9). what are you =&gt; [wachya/wacha]</p><p> (10). ing =&gt; [in’]</p></li><li><p>情态动词完成时和过去将来时的不规则缩读</p><p> (1). could have =&gt; could’a</p><p> (2). must have =&gt; must’a</p><p> (3). should have =&gt; should’a</p><p> (4). would have =&gt; would’a</p></li><li><p>of的不规则缩读 (本质上是由于语速+f的弱读+上下文导致)</p><p> (1). kind of =&gt; kinda</p><p> (2). a lot of =&gt; a lotta</p><p> (3). lots of =&gt; lotsa</p><p> (4). sort of =&gt; sorta</p><p> (5). bunch of =&gt; buncha</p><p> (6). because of =&gt; becausa</p></li></ol><p><strong>第七大技巧 略读</strong></p><ol><li><p>词尾爆破音略读</p><p> eg: very goo(d) , nerver give u(p)</p></li><li><p>意群结尾的爆破音</p><p> eg: I thin(k) you shouldn(t) punish him too har(d)</p><p> 注：I + think是一个意群，经过think后面紧接you，但是you属于宾语从句，不是一个意群。 </p></li><li><p>同类音：[s]/[θ] , [s]/[ʃ], [z]/[ð]，谁在前面谁先死</p><p> eg: Thi(s) shop i(s) so romantic </p></li><li><p>t音的消失： 当[t]在[n]和元音之间（原因可能是[t]的音弱读像边音l因此可以直接略读）</p><p> eg: Internet =&gt; [In(t)ɚnɛt]</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;语句最常用的功能就是口语表达，一切的规则都是为了轻松且简单的表达！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最近在学习ESLPod的“Introducation to the United States”系列，在跟读的时候感觉挺吃力，一方面是因为对音标熟练程度不够，另一方面就是对英</summary>
      
    
    
    
    <category term="英语" scheme="http://naivertc.top/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>关于英语学习的困惑</title>
    <link href="http://naivertc.top/2018/07/19/%E5%85%B3%E4%BA%8E%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>http://naivertc.top/2018/07/19/%E5%85%B3%E4%BA%8E%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%B0%E6%83%91/</id>
    <published>2018-07-19T14:49:07.000Z</published>
    <updated>2022-03-14T15:50:43.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近的英语学习计划执行的很糟糕，脑海里似乎对目前自己使用的学习方法没有足够的信心或者理论支撑。于是今天又看了一遍《把你的英语用起来》书中Dr.Krashen教授提出的最适合中国人学英文的理论，以下是相关笔记：</p><ol><li><p>input输入假说。Dr.Krashen认为英文学习的根本在于input输入，缺乏输入就不可能学好任何一门外语。</p></li><li><p>i+1理论，也叫可理解性输入假说。在一条是在上一条的基础上作进一步补充说明。进行输入练习时，一定要遵循i+1的原则。i代表目前的水平，1代表稍微高一点点的难度。随着自己水平的提高，需要主动的调整输入材料的难度，使之符合i+1。</p></li><li><p>narrow input假说。输入的材料类型和难度级别在一定时间内相对要狭窄。这样做有极大的好处，只输入自己感兴趣的材料，可以把熟悉的语言知识以不同的模式快速熟悉起来。</p></li><li><p>情绪机制。学习材料和环境应该是有趣的、轻松自如的，才能实现效果的最大化。</p></li><li><p>系统化量化。英文学习必须建立一个系统化、量化的流程，规定好整个学习周期的时间，彻底突破。</p></li></ol><p><strong>自勉</strong></p><p>笛卡尔曾经有一个比喻：在森林里迷路，如果不停地换方法，最后的结果很可能是走不下去。然而如果你认准一个方向坚定地走下去，最后一定能走出森林，哪怕你绕了一段远路，但胜利最终是属于你的。所以，如果只有方法没有坚持下去的勇气，一切都是空谈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的英语学习计划执行的很糟糕，脑海里似乎对目前自己使用的学习方法没有足够的信心或者理论支撑。于是今天又看了一遍《把你的英语用起来》书中Dr.Krashen教授提出的最适合中国人学英文的理论，以下是相关笔记：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;input输入假说。Dr.Kra</summary>
      
    
    
    
    <category term="闲言碎语" scheme="http://naivertc.top/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>《swift编程语言中文版》学习笔记</title>
    <link href="http://naivertc.top/2018/06/01/Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://naivertc.top/2018/06/01/Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2018-05-31T23:00:07.000Z</published>
    <updated>2022-03-14T15:57:17.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2-9-类和结构体"><a href="#2-9-类和结构体" class="headerlink" title="2.9 类和结构体"></a>2.9 类和结构体</h4><p>swift中类和结构体的关系比其他语言更加密切，二者主要的区别在于：</p><ul><li>类支持继承</li><li>类支持运行时检测类实例类型</li><li>类有deinit函数</li><li>类是引用类型而结构体是值类型</li></ul><p>swift中类或结构体允许直接修改其属性（存在子属性的一般也就是类或结构体）的子属性，而在Objective-C不行  </p><p>结构体有一个默认的成员逐一初始化器</p><p>在Swift中，整数、浮点数、布尔值、字符串、数组、字典都是值类型，并且是以结构体的形式存在的，结构体和枚举也都是值类型，意味着赋值或参数传递过程都是属于值拷贝，而类是引用类型</p><p>用于判定多个类引用是否指向同一个类实例的两个恒等运算符：等价于（===）和 不等价于（===）</p><p>swift中同样存在指针，比如引用类型，但是其声明方式同值类型一样</p><p>由于集合类型（数组和字典）都是以结构体实现的值类型，因此在赋值或传参过程中会发生拷贝，但是swift只会在有必要拷贝的情况下（比如拷贝后的数组长度发生变化等）才会执行拷贝，因此不必顾虑集合类型拷贝带来的性能问题。</p><p>字典类型的拷贝过程，如果键或值是值类型，则拷贝对应的值类型，如果是引用类型则拷贝的引用（其实就是指针）</p><p>数组类型只有在操作困难修改数组长度时才会发生，即使是修改数组内的元素值也不会发生拷贝，而是引用。</p><p>使用unshare函数可以确保数组的唯一性，但是并不意外这一定会发生拷贝，而是在有必要时才会拷贝。而copy函数属于强制拷贝数组。</p><p><del>可以使用恒等运算符来判定两个数组是否共用了相同的元素</del></p><p>数组只有在长度发生变化的操作中才会进行值拷贝，否则属于引用赋值</p><h4 id="2-10-属性"><a href="#2-10-属性" class="headerlink" title="2.10 属性"></a>2.10 属性</h4><p>属性分为存储属性和计算属性，前者用于存储常或变量作为实例的一部分，只能用于类或结构体中，而后者用于计算一个值，可以理解成一种运算，可用于类、结构体和枚举中。</p><p><strong>存储属性</strong></p><p>当值类型的实例赋值给一个常量时，值类型的所有属性都会变成常量，即使是变量属性也不能再修改，而当引用类型的实例赋值给一个常量时，仍可以修改实例的变量属性。</p><p>@lazy关键字用于声明延长存储属性：在第一次被调用时才会计算初始值的属性，类似懒加载。用前提包括必须是存储属性且是变量属性。因为常量属性在构造之前必须要有初始值，因此不能声明为延迟存储属性。</p><p><strong>计算属性</strong></p><p>计算属性必须声明为（var）变量属性，因为它的值是不固定的。计算属性不直接存储值，而是提供一对getter和setter用来获取和访问其他属性或者变量的值。</p><p>如果计算属性的setter没有定义表示新值的参数名，则可以使用默认名称newValue。</p><p>一个计算属性如果只有getter没有setter那就是只读类型，</p><p><strong>属性监视器</strong></p><p>作用类似于OC的KVO，可以为延迟存储属性之外的属性添加属性监视器，也可以通过重载的方式为父类的属性添加属性监视器。</p><p>两种监视器：willSet和didSet，前者的参数是新属性值，缺省参数名为newValue。后者的参数是旧属性值，缺省值参数名为oldValue。监视器在属性初始化时不会被触发。</p><p><strong>全局变量和局部变量</strong></p><p>计算属性和属性监视器同样适用于全局和局部变量。全局的常量或变量默认就是延迟计算的且不需要标记@lazy关键字。</p><p><strong>类型属性</strong></p><p>存储属性和计算属性通常用于特定类型的实例，但是属性也可以直接用于类型本身，称之为类型属性</p><p>类型属性类似于OC中声明在超类中的属性（swift没有超类的概念）。类型属性可以被所有实例访问。</p><p>用关键字static定义值类型的类型属性，用class定义类的类型属性。</p><p>值类型可以定义存储型和计算型的类型属性，而类只能定义计算型的类型属性。存储类型的类型属性必须在声明时指定默认值，因为类型本身没有构造器（只有为实例提供的初始化构造器）。</p><p><em>为什么类不能定义存储型的类型属性？很可能与类是引用类型有关系？</em></p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> {</span><br><span class="line"><span class="comment">//static关键字</span></span><br><span class="line"><span class="comment">//存储型</span><span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">"Some value."</span></span><br><span class="line"><span class="comment">//计算型</span><span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> {<span class="comment">//return a int value </span></span><br><span class="line">}}</span><br><span class="line"><span class="comment">//枚举类型</span><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> {</span><br><span class="line"><span class="comment">//存储型</span><span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">"Some value."</span></span><br><span class="line"><span class="comment">//计算型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> {<span class="comment">//return a int value </span>}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//类类型</span><span class="keyword">class</span> <span class="title class_">SomeClass</span> {</span><br><span class="line"><span class="comment">//class关键字</span></span><br><span class="line"><span class="comment">//只能定义计算型属性</span><span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">computedTypeProperty</span>: <span class="title class_">Int</span> {<span class="comment">//return a int value </span>}}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-11-方法"><a href="#2-11-方法" class="headerlink" title="2.11 方法"></a>2.11 方法</h4><p>方法是与某些特定类型相关联的函数，方法分：实例方法和类型方法</p><p><strong>实例方法</strong></p><p>方法和函数的局部名称和外部名称的默认行为的区别：</p><p>方法的第一个参数的外部参数可以省略，等价于在参数前加下划线（_），第二个及后面的参数名称可以同时作为局部和外部参数名称，等价于在参数前加#号。</p><p><strong>self属性</strong></p><p>self属性不需要显式调用，主要使用场景在于区分方法参数与实例属性，方法参数享有优先权，因此需要self指定实例属性消除歧义。</p><p><strong>mutating关键字</strong></p><p>类中的成员为引用类型，所以修改实例及其属性的值不会改变类型；而结构体和枚举中成员均为值类型，修改变量的值就是相当于修改变量的类型。Swift中默认不允许修改类型，因此需要前置mutaing关键字来表示该函数中能够修改类型。</p><p>值类型中的一般的实例方法不能修改其实例属性，而使用mutating关键字声明实例方法可以修改属性，并且修改的状态保留在原始结构中。在此方法中还可以给self重新赋值一个全新的实例，并替换原有实例。</p><p>枚举的mutating方法可以把self设置为枚举类型中不同的成员。</p><p><strong>类型方法</strong></p><p>类型方法的声明与类型属性声明类似，类的类型方法加关键字class，结构体和枚举的类型方法加static。</p><p>在本类或结构体的范围内，类型方法可以相互调用，也可以直接调用类型属性，不需要显式类型名称做为前缀。</p><h4 id="2-12-附属脚本"><a href="#2-12-附属脚本" class="headerlink" title="2.12 附属脚本"></a>2.12 附属脚本</h4><p>附属脚本本质上提供了一种访问对象、集合或序列的快捷方式，可以定义在类、结构体和枚举中。使用时配合”[]”语法糖直接对多个属性同时访问或赋值</p><p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同进行重载，而且索引值得个数可以是多个。</p><p>定义附属脚本使用subscript关键字，没有函数名，或者说subcript就是默认函数名称。附属脚本对于索引入参的数量和类型没有限制，返回值可以是任何类型，但是<em>不能使用in-out参数和对参数设置默认值。</em></p><p>附属脚本在定义上与实例方法类似，区别在于使用时附属脚本不需要指定函数名，而是根据参数自动匹配对应的脚本函数。</p><p>附属脚本与计算型属性类似，可以设定读写或者只读属性。区别在于附属脚本不是具体的属性，并且可以自定义参数和返回值类型和个数。而计算性属性的参数和返回值在定义时已经指定，可以理解为是对某一个具体属性的附属脚本，但是调用方式却没有附属脚本那么便捷，而是类似实例方法调用。</p><h4 id="2-13-继承"><a href="#2-13-继承" class="headerlink" title="2.13 继承"></a>2.13 继承</h4><p>在swift中，继承是区分“类”和其他类型的一个基本特征。子类可以调用和访问超类的方法、属性和附属脚本，并且可以重载这些方法。</p><p>不继承与其它类的类，称之为基类。不同于OC有一个共同的基类NSObject</p><p>在swift中，初始化器默认是不继承的。</p><p><strong>重写</strong></p><p>子类可以重写类方法、实例方法和附属脚本，使用关键字override标明</p><p>子类可以通过重写的方式将超类的存储型属性以计算型属性存在，但是该属性在超类还是存储型属性。</p><p>使用关键字final来防止重写</p><h4 id="2-14-构造过程"><a href="#2-14-构造过程" class="headerlink" title="2.14 构造过程"></a>2.14 构造过程</h4><p>与OC的构造器不同，Swift的构造器无返回值，主要任务是确保新实例在第一次使用之前完成正确的初始化。</p><p>在构造器中给存储型属性赋值时不会触发任何属性观测器</p><p>不同的构造器通过参数的不同进行区分，如果没有定义外部参数名，Swift会自动生成一个与内部参数名相同的外部名，等价于在内部名前添加#号。也可以使用下划线(_)来覆盖默认行为。</p><p><strong>默认构造器</strong></p><p>只有在所有成员变量都有默认值得时候，才能省略构造器，或者说Swift提供了一个默认的构造器。结构体的默认构造器是逐一成员构造器。</p><p><strong>值类型的构造代理</strong></p><p>构造器可以通过调用其他构造器完成部分构造过程，此过程称之为构造代理，且构造器代理的实现规则和形式在值类型和类类型有所不同。</p><p>值类型不支持继承，构造器代理任务只能给本身提供的其他构造器。而类类型可以调用超类的构造器完成构造代理。</p><p>值类型中一旦自定义了构造器后将无法访问到默认构造器，结构体则无法访问逐一成员构造器。如果定制的构造器是定义在扩张中，则不会覆盖默认构造器。</p><p><strong>类的继承和构造过程</strong></p><p>指定构造器是类中最主要的构造器：初始化类中所有的属性，并且根据父类链往上调用父类的构造器来实现父类初始化。每一个类至少拥有一个指定构造器，可继承自父类。</p><p>便利构造器则通过调用指定构造器实现，并给部分参数提供默认值。</p><p><strong>构造器的继承与重载</strong></p><p>与OC不同，一般情况下，Swift不会默认继承父类构造器，即此时创建子类时不能调用父类的构造器。可通过重载的方式继承与父类相同的构造器，且不需要使用override关键字。</p><p>两种特殊情况下，自动继承父类构造器：</p><ul><li>子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器和便利构造器。</li><li>子类提供了所有父类指定的构造器实现，将自动继承所有父类的便利构造器。</li></ul><p><strong>使用闭包或全局函数设置属性的默认值</strong></p><p>如果某个存储型属性的默认值需要特别的定制，使用闭包或全局函数为其提供定制的默认值。赋值时执行闭包或调用函数，将返回值赋给该属性。</p><p>使用闭包初始化属性时，不能在闭包中访问其它的属性，即便属性有默认值也不允许。同时，不能使用隐式的self属性或调用其它的实例方法。</p><h4 id="2-15-反初始化"><a href="#2-15-反初始化" class="headerlink" title="2.15 反初始化"></a>2.15 反初始化</h4><p>反初始化函数使用关键字deint来标识，只适用于类类型，在实例释放前一步自动调用。</p><p>反初始化函数调用链与初始化函数调用链相反，先完成子类的资源释放再执行父类的反初始化函数。与OC类似。</p><h4 id="2-16-自动引用计数-ARC"><a href="#2-16-自动引用计数-ARC" class="headerlink" title="2.16 自动引用计数(ARC)"></a>2.16 自动引用计数(ARC)</h4><p>引用计数只用于类类型的实例，值类型不是以引用的方式存储和传递的。</p><p><strong>循环引用</strong></p><p>使用weak引用或者无主引用来解除循环引用，弱引用可以为nil，所以必须是可选类型的，指向的实例释放后ARC自动将weak指针置空。无主(unowned)引用默认始终有值，因此必须是非可选型。如果无主引用指向的实例已释放，再次通过无主引用访问该实例即为野指针错误，需要手动置空。</p><p>weak指针适用情况：当两个对象AB之间均非一对一关系，即A对B或者B对A都是一个可选值，允许是nil</p><p>unowned指针适用情况：当对象A必须引用对象B，而A之于B是一个可选项，允许为空</p><p>unowned + 隐式展开可选项：对象AB属于一对一关系，且A对象是B的初始化参数之一，设置B为隐式展开的可选属性，此时B对象为赋值之前默认值为nil，不影响A的初始化操作，从而A初始化后可以作为参数完成B的初始化。</p><p><em>下面代码思路正确，但是代码执行出错，隐式展开可选项似乎没起作用，待进一步研究！</em></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Country与City属于一对一关系，且City的初始化依赖于Country</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">class</span> Country {<span class="number">2.</span> let name: String<span class="number">3.</span> let capitalCity: City! <span class="comment">//隐式展开可选项</span><span class="number">4.</span> init(name: String, capitalName: String) {<span class="number">5.</span> <span class="keyword">self</span>.name = name<span class="number">6.</span> <span class="keyword">self</span>.capitalCity = City(name: capitalName, country: <span class="keyword">self</span>) <span class="number">7.</span> }<span class="number">8.</span> }<span class="number">9.</span><span class="number">10.</span><span class="keyword">class</span> City {<span class="number">11.</span> let name: String<span class="number">12.</span> unowned let country: Country <span class="comment">//unowned指针</span><span class="number">13.</span> init(name: String, country: Country) {<span class="number">14.</span> <span class="keyword">self</span>.name = name<span class="number">15.</span> <span class="keyword">self</span>.country = country </span><br><span class="line"><span class="number">16.</span> }<span class="number">17.</span> }</span><br></pre></td></tr></tbody></table></figure><p><strong>闭包产生的循环引用</strong></p><p>类似于OC中Block产生的循环引用。</p><p><em>Swift中的约束：只要闭包内使用self的成员，就必须通过self指针调用，而不能直接调用，可提醒存在强引用的风险</em></p><p>通过定义占有列表解除强循环引用，占有列表有关键字weak或unowned和实例的引用组成，包含在一个中括号中，有逗号隔开。eg: [(weak|unowned), self]</p><p>占有列表放置在闭包参数和返回类型之前。如果没有指定参数或返回类型则放在关键字in前面。</p><p>当闭包和占有实例总是互相引用并总是同时销毁时，使用unowned定义占有列表。当占有引用有可能为nil时，使用weak。</p><h4 id="2-17-自判断链接"><a href="#2-17-自判断链接" class="headerlink" title="2.17 自判断链接"></a>2.17 自判断链接</h4><p>Swift的自判断链和OC中的消息为空类似，但是Swift可用于任意类型（值类型和类类型），并且一定会有返回值，返回值一定是可选项类型。</p><p><strong>可使用自判断链代替强制拆包</strong><br>二者调用方式类似：自判断值后面使用？号，而强拆使用的是！号。当自判断值为空时，强拆会引发运行时错误，自判断链则会返回一个空值，表示自判断链调用失败。</p><p>自判断链适用于调用属性、实例方法和附属脚本（子脚本）中，三者的任意组合成自判断链。</p><h4 id="2-18-类型转换"><a href="#2-18-类型转换" class="headerlink" title="2.18 类型转换"></a>2.18 类型转换</h4><p>Swift中的is和as两个操作符分别用来做类型检测和类型转换。</p><p>假如向下转换可能出现失败的情况，使用as?返回一个可选值，转换失败返回nil。假如确定一定能转换成功则使用as，有点类似强制解包。</p><p>Swift为不确定类型提供了两种特殊类型别名：</p><ul><li>AnyObject可以代表任何class类型实例</li><li>Any可以表示除了方法类型之外的任何类型</li></ul><h4 id="2-2-扩展"><a href="#2-2-扩展" class="headerlink" title="2.2 扩展"></a>2.2 扩展</h4><p>扩展是向一个已有的类、结构体或枚举类型添加新功能。与OC中的分类类似，但是Swift的扩展不需要知道名称，<em>可以理解成OC中的匿名分类？</em>。</p><p>Swift中的扩展可以：</p><ul><li>添加计算型属性和计算静态属性</li><li>定义实例方法和类型方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使一个已有类似符合某个接口</li></ul><p>Swift中扩展和OC中分类一样，扩展中的功能在该类型的所有实例都是可用的。</p><p><em>注意：扩展可以添加新的计算型属性，但是不能添加存储属性，也不可以向已有属性添加属性观测器</em></p><h4 id="2-21-协议"><a href="#2-21-协议" class="headerlink" title="2.21 协议"></a>2.21 协议</h4><p>类、结构体和枚举均可实现多个协议，中间用逗号分隔。</p><p><strong>属性要求</strong></p><p>协议能够要求遵循者包含一些特定名称和类型的实例属性或类属性，同时可以指定类型的读写权限，但是具体属性最终实现可以是存储型或者计算型属性。</p><p><strong>方法要求</strong></p><p>协议方法的声明和普通方法声明相似，但是不需要方法内容。</p><p>class中实现协议中的mutating方法时，不用写mutating关键字，因为类为引用类型，可直接修改类的属性；用结构体和枚举实现协议中的mutating方法时，则必须写mutating。</p><p><strong>协议类型</strong></p><p>协议可当做一种满足一定要求的类型对待，可用于声明满足协议的变量。比如委托模式，声明一个满足委托协议的代理变量，然后通过代理变量调用委托协议中的方法。</p><p><strong>在扩展中添加协议成员</strong></p><p>通过扩展为已存在的类型遵循协议是，该类型的所有实例也会随之添加协议中的方法。</p><p>当一个类型实现了某个协议中的所有要求却没有声明相应的协议时，可以通过扩展来补充协议声明。</p><p><strong>集合中的协议类型</strong></p><p>协议类型可以用来声明集合，表示集合中的元素均为协议类型。</p><p><strong>协议的继承</strong></p><p>协议能够继承一到多个其他协议。语法和类的继承相似。</p><p><strong>协议合成</strong> </p><p>一个协议可又多个协议采用protocol&lt;SomeProtocol, AnotherProtocol, ThirdProtocol&gt;这样的格式进行组合。</p><p>协议合成不会生成一个新的协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。</p><p><strong>检验协议的一致性</strong></p><p>使用is检验协议的一致性，使用as将协议类型向下转换为其他的协议类型。</p><ul><li>is操作符用来检查实例是否遵循了某个协议</li><li>as?返回一个可选值，当实例遵循协议时，返回该协议类型，否则返回为nil。</li><li>as用以强制向下转换。</li></ul><p><strong>@objc</strong></p><p>@objc表示协议的可选的，用可以用来表示暴露给Objective-C的代码。此外，@objc型协议只对类有效，因此只能在类中检查协议的一致性。</p><p>在@objc声明的协议中，可以使用@optional关键字作为前缀定义可选的属性或者方法。</p><p>调用可选方法是，在函数名和参数直接加上?来检查该方法是否被实现，当其不可访问时，？之后的语句不会执行，并且返回nil。</p><h4 id="2-22-泛型"><a href="#2-22-泛型" class="headerlink" title="2.22 泛型"></a>2.22 泛型</h4><p>泛型是一种清晰和抽象的代码表达方式，可以根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型，从而避免了代码重复。</p><p>泛型是Swift强大特征之一，许多Swift标准库是通过泛型代码构建的。</p><p><strong>关联类型</strong></p><p>定义协议时，通过associatedtype声明一个关联类型，不用具体指定实际类型。直到实现协议时，才给出关联类型的实际类型。</p><p><strong>通过extension为已知类型添加协议的兼容性</strong></p><p>如果某个类型已经覆盖了某个协议所包含的要求，那么可以通过拓展将已知类型和协议建立关联。有点像JS中的鸭子类型。</p><h4 id="2-23-高级运算符"><a href="#2-23-高级运算符" class="headerlink" title="2.23 高级运算符"></a>2.23 高级运算符</h4>]]></content>
    
    
    <summary type="html">摘录在Swift学习过程中的一些重要知识点与疑问，以及记录个人的心得领悟</summary>
    
    
    
    <category term="iOS" scheme="http://naivertc.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://naivertc.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>《李光耀观天下》读书笔记</title>
    <link href="http://naivertc.top/2018/05/16/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://naivertc.top/2018/05/16/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2018-05-16T14:33:07.000Z</published>
    <updated>2022-03-14T15:54:21.695Z</updated>
    
    <content type="html"><![CDATA[<p>《李光耀观天下》这本书是以李光耀先生的自述性自传，全书向读者阐述自己对当今这个世界的观点与看法。面对复杂多变的世界形势，他总能保持中立客观，并且抓住事情的本质。其字里行间透露着一种谦虚与客观的态度，言语中蕴藏着深刻的学问与广阔的见识。</p><span id="more"></span><p>相对于这边书的中文译名《李光耀观天下》， 我更喜欢它的英文名称《One Man’s View of the World》。英文书名似乎给人一种更为谦虚与中立的感觉，也许只是我个人感觉罢了。</p><p>读完此书之后，由于自己世界观的不健全，只对于书中关于的一些比较熟悉的国家的分析与见解印象比较认同，主要的亚洲国家，比如中日韩朝等。而对于其他国家的，特别是中东地区的阿拉伯国家，因为缺乏对这些国家的了解，只能处于一种认知与被动接受的角度去看待相关的分析。换言之，这本书带给我是一个新的看待世界的视角，从而进一步完善我的世界观。</p><p>书中除了最后四章，前面起章都是以国家为基本单位，阐述了李光耀先生对每个国家现状的分析以及未来发展的预测。最后四章分别分析了全球经济、能源与气候、个人生活以及与联邦德国总理赫尔穆特·施密特先生的对话。由于自己目前能力有限，没能站在一个更高中的角度提炼并串联每一个章节的中心思想，所以只能是按照书中原有的组织结构依次总结自己关于每个章节的心得体会。</p><h4 id="中国：一个强大的中央"><a href="#中国：一个强大的中央" class="headerlink" title="中国：一个强大的中央"></a>中国：一个强大的中央</h4><p>中国有着悠久的历史，历朝历代都是通过一个强大的中央政权来治理国家，这一点在中国人心中已经根深蒂固。因此，西方国家提倡的一人一票的民主选举制度是不能再中国出现。中国的特殊性也决定了中国需要开辟一条属于自己的道路。此外，在中国这片土地上不再可能出现大规模的动乱或者反政府活动了。从“乌坎事件”可以得出两点结论：一是共产党能保持它的掌控地位，在党的领导下社会可以恢复秩序。二是共产党拥有强大的国家安全机器，可以运用软硬兼施的方式控制局势。与此同时，共产党是支持民众反对腐败的地方官的，而民众也是支持共产党，反对的只是腐败的地方官。</p><p>中国经历改革开放，在过去的四十年经济突飞猛进，重新以重要大国的形象出现在国际舞台。中国人也变得崇尚多元爱好的充满理想。随着全国各地的变化，中国的政治也必须变革。然而中国地域广阔，人口基数大，维持社会稳定是根本前提，因此制度改革的进度一定是缓慢的。此外，中国目前的法制不健全，更多的是依赖于人制，这与中国的特殊国情和历史渊源有关。不论将来中国如何发展体制和制度，完全都是中国式的，并且有一个不变的核心：强大的中央政权。</p><p>中国能发展到今天这个地步离不开历届领导人的贡献。毛泽东作为开国主席，主张革命之后再革命，尽管其主导的“文化大革命”给新中国带来毁灭性的打击，但是仍不能掩盖他的光芒。第二代领导人邓小平作为改革开放的领路人，扭转了中国的发展方向，给中国带来了翻天覆地的改变。第三代领导人是邓小平选拔的江泽民，进一步的加快了中国四个现代化的建设步伐。第四代领导人胡锦涛是一位整合者，为人沉着冷静，思考缜密，面临着城镇化与贫富差距等多项挑战，并作出了一些根本性的改变。第五代领导人习近平能将中国带向何处尚不可知。但是历届领导人都有一个共同的特点就是不露锋芒，保持谦逊。</p><p>为了营造和维持一个有利于经济发展的国际环境，中国只寻求和平崛起，绝不称霸。但是在关乎主权和领土完整等原则性问题，中国是丝毫不会退让与妥协的。其中，中日的纠纷在于钓鱼岛归属问题，中美则会出现的最大危机是在台湾问题上。李光耀先生认为随着中国大陆与台湾在经济等多方面的联系日趋紧密，台湾与大陆重新统一只是时间问题，这是任何国家无非阻挡的。</p><p>当今的中国，由于经济发展速度过快，以至于社会其他方面没能跟上步伐实现同步发展，意味着高速发展的背后隐藏着各种各样的问题。首先是新一代中国年轻人的观念转变，他们不像经历过战争、革命和改革的老一辈中国人明白和平稳定的珍贵。新一代的年轻人看到的更多是当下中国的强盛，并以这样的姿态自居，这样导致在面对一些国际敏感话题是容易自傲。其次是中国社会贫富差距的进一步加大，以及为了眼前发展经济从而忽略了环境与长远发展，这无疑是国内稳定与经济发展潜在隐患。最后是经济发展将面临瓶颈，最容易实现经济发展的时期已经过去，为了确保今后几十年的经济能持续增长，整个经济战略需要调整。</p><h4 id="美国：陷入困境但优势仍在"><a href="#美国：陷入困境但优势仍在" class="headerlink" title="美国：陷入困境但优势仍在"></a>美国：陷入困境但优势仍在</h4><p>由于中国的崛起以及中国亚洲有着距离上的优势，导致美国在亚太地区的影响力正在削弱。为了应对这一势力格局的变化，打算重新将战略重心移回本区域。除中国之外的其他亚洲国家希望美国持续参与本区域的事务，以平衡中国的影响力，有助于保持亚太区域的稳定和安全。但是美国能否长期履行承诺与美国的未来的经济发展有关系，发挥影响力需要有强大的经济做后盾。</p><p>美国的成功在于它活力十足的经济，这活力的来源是一种不可思议的能力，不仅能以更少资源去实现同等的产出，还能不断创新。这使得美国能够始终走在科技前沿，掌握话语权。此外，美国是一个开放自由，且由移民组成的社会，能够吸引并且留住人才。中国在吸引人才方面不如美国的原因之一在于语言问题，比起英语，华语是一门更难掌握的语言。美国竞争力的另一来源，是有许多遍布全国各地并相互竞争的卓越中心，每个中心都认为本身能媲美其他中心，从而构成了美国这样一个多元的社会。而中国则完全不同，中国人相信只有中央强大，中国才能繁荣。最后，美国拥有一种颂扬勇闯天下的文化。对于成功的企业家会获得应有的社会地位和认可，对于创业失败的情况认为是通往终极成功的必要过程，不会因此而受到鄙视。</p><p>美国面临着很多严重问题。首先是债务问题。比起一些欧元国家，美国面临的债务问题相对轻微。部分原因在于美元是世界储备货币，这意味着美国享有比其他国家低许多的借贷成本。国会与总统对如何解决债务问题难以达成共识，他们更关注下一届选举。其次，美国公立学校的教育得不到重视，中下层人才的教育问题面临危机，不同于私立学校，公立学校的地方政府拨款受金融危机影响被进一步削减，而联邦政府又不能直接干涉。长久下去，美国的竞争力会逐渐下滑。除此之外，美国面临的问题还包括：基础设施差、阶级鸿沟加剧、种族歧视根深蒂固、拜金主义严重以及繁琐冗长的选举过程。</p><p>美国人属于乐观主义，从根本上相信未来会更好，更倾向于提前消费。完全不同于中国和日本人的未雨绸缪。美国作为世界第一强国，乐于担任世界警察的职务，但是有时候确得不偿失，进攻伊拉克和阿富汗就佐证。</p><h4 id="欧洲：衰退与分歧"><a href="#欧洲：衰退与分歧" class="headerlink" title="欧洲：衰退与分歧"></a>欧洲：衰退与分歧</h4><p><strong>欧元困境</strong></p><p>欧洲现在有17国家加入欧元，整个欧洲现在处于一种财政没有整合而货币是通一的困境中。不同的欧元国家的财政预算和公民消费习惯差异很大，国家之间的发展速度和经济实力也存在差距，这些不协调因素逐步破坏者欧元一体化制度。欧元面临的困境是一个必然的历史结果。</p><p>解决欧元危机，有三个可行的方案。</p><ul><li>完全整合。模仿美国建立有一个联邦储备局和一个财政部长，当某个洲出现经济困境，联邦政府会伸出援手，而其他州的民众也视他们为同胞，不会要求偿还。而在欧洲是行不通的，不同国家之间民族差异性大。而且欧洲各国的选民不大愿意将国家的财政大权交给一个中央机关。</li><li>欧元解体。每个国家有各自的财政部长并各自自行管理本国货币。当一个国家经济放缓，因为不受限于一种共同货币，可以采用“量化宽松”政策扩大货币供应量，使货币贬值，加大出口吸引力。欧元区国家则没办法采用这样的货币政策来刺激经济复苏。此外欧洲国家出于选举的压力，也不能通过消减福利，改革税收制度，放宽劳动力市场规则或延后退休等措施来加强国家竞争力。</li><li>局部解体。这种结局的可能性很多，竞争力相近的国家可组合成一个新共同体，从而分成不同层次的欧洲。每个层次以不同的速度发展。</li></ul><p><strong>福利社会和僵化的劳动力市场法律</strong></p><p>欧洲走向衰退的另一个原因在于：难以维继的福利制度和僵化的劳动力市场法律。随着二战红利的殆尽和全球化市场经济的发展，欧洲工人的竞争力逐步削弱，工资也自然下降，对社会福利的依赖也越大。福利制度一定制定就很难往下调整，政府处于选举的压力，往往尽力满足民众的要求。</p><p>如果说福利开支的维持在一定水平的话，问题或许还可以受到控制。可事实是这类开支的随时间递增的，占国家总收入的比重逐步上升。原因之一民粹主义者要求更多福利。</p><p>福利社会最坏的影响，在于它削弱了人们努力奋斗的动力。如果社会保障体系设计成不管一个人努力工作或是悠闲生活都能得到同样的好处，那么努力的工作的意义变得渺小。</p><p><strong>欧洲一体化的理想幻灭</strong></p><p>欧洲如果能实现一体化，不论从和平的角度还是经济发展的角度都是一个最佳选择。然而现实是欧洲不可能完全融合。首先欧洲国家未能成功的实现货币一体化，更何况实现政治和军队一体化。原因在于欧洲国家都有自己悠久的历史与光荣的传统，并且各自引以为豪。此外，欧洲其他国家也不会接受英语作为唯一的工作语言，因为语言背后有着荣耀和文学，他们都想保留本身的语言。</p><p>尽管欧洲在国家的地位和话语权减弱，但是不会对其生活水平造成同等的影响。这片大陆有着高水平的教育和技能，足以让欧洲人过上好生活。个别国家将有些衰退，但会根据自身的竞争力达到一个稳定的状态。</p><h4 id="日本，走向平庸"><a href="#日本，走向平庸" class="headerlink" title="日本，走向平庸"></a>日本，走向平庸</h4><p>关于日本，人口的老龄化加上持续下降的生育率，相较于经济停滞不前和政治领导人虚弱等问题，人口问题成为了日本面临的最大问题。任何社会的经济主力军都是年轻人，年轻人群体的比重逐渐减小，也意味着经济的萎缩。即便是像中国这样的人口大国，在实时计划生育近30年后，随着人口红利的消失，开始出现老龄化和生育率低的问题，于是在2013年放宽生育政策，开发二胎，试图调整和改善社会人口组成结构。由此可见人口问题对经济是多么重要。</p><p>日本人口问题的产生原因是多方面的，其中包括：</p><ol><li>日本女性的社会角色开始由传统的家庭主妇向现代的职业女性转变</li><li>日本企业对女性的包容性差，让职业女性很难兼顾家庭和工作，导致生育成本过高</li><li>日本民族的种族纯洁性观念强，日本社会对外国移民极为抗拒，即便是对日侨移民也是如此</li></ol><p>即便如此，不可否认日本是一个了不起的民族，公民素质很高，团队精神举世无双。这些特质让日本在未来的一段时间内仍能在世界经济强国中有一席之地。但是日本正在走向平庸也是不争的事实。</p><h4 id="朝-韩，偷天换日"><a href="#朝-韩，偷天换日" class="headerlink" title="朝 韩，偷天换日"></a>朝 韩，偷天换日</h4><p>谈及朝鲜和韩国，绕不开的话题的朝鲜半岛局势。就目前而言，朝鲜半岛局势在可预计的未来不会有什么变化。即不可能和平统一又不可能爆发战争。</p><p>和平统一的阻力在于，一方面朝鲜与韩国的经济实力差距悬殊，韩国暂时不愿意为了和平统一而付出巨大的经济利益。而是希望朝鲜能够对外开放，发展经济，在双方差距缩小到一定程度时才考虑和平统一的可行性；另一方面，作为朝鲜邻国的中国不愿意看到朝韩统一，这意味美国可能将会在朝鲜设立军事基地，更近一步的威胁中国。</p><p>爆发战争的可能性也几乎为零。一方面尽管朝鲜有核武器，对韩国包括首尔在内的重要城市有直接的杀伤力。但是朝鲜的核武器更多在于巩固金氏政权；另一方面，朝鲜的工业水平与韩国差距太大，即便的真的发动战争也很可能战败。</p><p>目前来说，朝鲜的经济仍然停滞不前，国内人民的温饱问题都没能得到解决。韩国则仍然保持经济增长，得益于三星、LG和现代等国际品牌企业。虽然同日本一样面临生育率低和人口老龄化问题，但是韩国愿意接纳外国移民，所以这问题能够得到缓解。</p><h4 id="印度：受种性制度羁绊"><a href="#印度：受种性制度羁绊" class="headerlink" title="印度：受种性制度羁绊"></a>印度：受种性制度羁绊</h4><p>印度是一个由多种族组成的国家，印度境内使用的民族语言多达400种。印度有着中国的人口规模，却不同于中国一样有共同使用的语言：普通话。印度语言环境的多元化无疑是国家管理的一大障碍。</p><p>印度从来都不是一个单一性的实体，不同于中国超过90%的人口比例是汉族。因此，我们不能把中国和印度两大文明相提并论。印度不具备中国那样的决心和专一。</p><p>这种分离情况也体现在印度的政治体系上。地区的领导人不会按照联邦政府的意志办事，他们的委任来源于百姓的选票。</p><p>此外，种姓制度使得印度情况更为复杂，成为了阻碍其发展的另外一个重要的原因。印度分为婆罗门人（僧侣阶级）、吠舍人（平民阶级）和达利人（贱民阶级）。不同的阶级直接等级分明，不能通婚。从宏观的层面来看，种姓制度限制了各阶级的基因库的多样化。</p><p>由于印度国内的官僚化和阶级化，导致许多有才干的印度人到国外寻求机遇，并且一去不回，造成人才流失，进一步影响国家发展。</p><p>此外，印度的基础建设落后，虽然人口红利优势明显，但是却很难得到国外投资方的青睐。</p><p>综上，首先，印度虽然是民主制度，然而却没能体现民主带来的优势。其次，由于印度有着悠久的历史，社会内有一些根本的势力难以改变。印度受制于内部构造结构和种姓制度的束缚，几乎无法挣脱。</p><h4 id="马来西亚：分道扬镳"><a href="#马来西亚：分道扬镳" class="headerlink" title="马来西亚：分道扬镳"></a>马来西亚：分道扬镳</h4><p>在李光耀先生看来，马来西亚和新加坡是同根同生的，当年英国离开时留给两个国家大致相同的遗产，两国在后殖民时期的发展水平也旗鼓相当。可以说两个国家离开殖民统治之后处于同一起跑线。</p><p>然而，两个国家的领导人选择两条完全不一样的发展道路。马来西亚放弃了英语选择建立一个以马来语为主的国家，并且是属于马来人的马来西亚。新加坡则选择建立一个以英语为主的多元种族化的国家。正所谓道不同不相为谋，两个国家最终没能结成联盟，分道扬镳。</p><p>马来西亚随着马来人的比重越来越重，其他种族的权益得不到保障，从而造成了人才流失严重。马来人的特权已经在马来西亚社会根深蒂固，因为即便是新的领导人有意促进种族和谐加强团结，有意提出一些保障其他种族的权益的举措，但是实际上往往是力不从心，因为他们需要大多数马来人的选票来赢的竞选。</p><p>由于马来西亚和新加坡的发展道路截然不同，且均不能改变对方的想法，二者学会了和平相处，接受彼此的不同。</p><h4 id="印度尼西亚：偏离中央"><a href="#印度尼西亚：偏离中央" class="headerlink" title="印度尼西亚：偏离中央"></a>印度尼西亚：偏离中央</h4><p>印度尼西亚是由分散在5000公里范围内的1.75万个岛屿组成，有超过200个民族，是一个多元化的国家。</p><p>在哈比比出任印尼总统之前，印尼是全世界政治上最集权的国家之一。苏加诺和苏哈托都依赖于中央集权来管理这个地理上分散的国家。除了利用国家机器镇压叛乱和维持团结之外，苏加诺选择了马来语而非爪哇语作为印尼的官方语言，尽管爪哇族是印尼的主要民族，苏加诺本身是爪哇人，且印尼的经济和文化中心的首都雅加达也位于爪哇岛。这一举措不仅解决了印尼各地区的交流沟通问题，还有利于维护国家团结稳定。</p><p>在哈比比担任总统之后，政府开始走地方化道路。中央权力的下方不仅加速了地区经济的发展，也维持了国家统一。然而，地方化是一个不可逆转的过程，一旦权力下放到地方就不可能再收回。</p><p>地方化对于印尼是发展是一件好事，但是并不能解决印尼面临的所有问题。除了面对传统的挑战，印尼还需要面对新的挑战。其中包括中央的政治僵局、基础建设的落后和贪污成风的现状。</p><p>印尼目前发展虽然良好，但是其本质上是以天然资源为基础的经济体，印尼国民也过于依赖土地的馈赠，而非靠双手谋生。印尼因为其丰富的资源能够吸引国外的巨额投资，从而获得持续的经济增长。然而，自然资源总有耗尽的一天，届时再纠正印尼国民已经养成的闲散的生活态度不是一件容易的事情。</p><h4 id="泰国：苏醒的社会底层"><a href="#泰国：苏醒的社会底层" class="headerlink" title="泰国：苏醒的社会底层"></a>泰国：苏醒的社会底层</h4><p>在他信·西那瓦就任之前，泰国的精英阶层垄断了整个政治局面，执政方针主要以首都的利益为考量。</p><p>在他信担任泰国首相之后，将原本被曼谷既得利益集团和中产阶级独占的资源转移到泰国较为贫穷的地区，颠覆了泰国的政治现状。他信为农民提供贷款，给贫困家庭的学生颁发海外奖学金，为城市贫民提供政府津贴的住房，让穷人享受医疗保障。</p><p>他信的这些政策严重的威胁和影响到曼谷精英阶层的利益，他信的政府在2006年的军事政变中被推翻。泰国的首都陷入巨大的动荡，主要有两股军事力量相互抗衡，分别是保皇派的黄衫军和支持他信的红杉军。</p><p>在泰国，军人向来是扮演者主要的角色。但是随着年轻一代对王室的尊敬日渐减弱，黄衫军的实力也日渐衰退。整个社会还是沿着他信开创的道路继续前进，许多农民加入中产阶级，协助推高国内消费。泰国的发展态势会是良好的。</p><h4 id="越南：解不开的社会主义思维枷锁"><a href="#越南：解不开的社会主义思维枷锁" class="headerlink" title="越南：解不开的社会主义思维枷锁"></a>越南：解不开的社会主义思维枷锁</h4><p>越南同中国一样是一个忠于社会主义道理的国家，在中国改革开放几年之后，越南也决定推行自由市场改革。然而，越南老一辈共产党领袖的思维基本上无法跳出社会主义的枷锁。他们始终都拿不出像中国领导人一样的真正决心，去彻底改变整个制度。</p><p>和中国不同，越南没有像邓小平那样既在干部中有不可动摇的崇高地位，又坚信改革是唯一出路的领导人。究其原因在于，在改革开放之前十几年间中国在不断的摸索和积累经验，为改革打下了基础。而此时的越南正与美国进行残酷的越南战争，与此同时很多了解资本主义运行规律的成功商人也纷纷逃离了越南。</p><p>越南人是东南亚最能干和精力最充沛的人民之一，但愿在老一代共产党领导人谢世之后，新一代年轻人接班之后，能够肯定自由市场的重要性，让越南进入一个新篇章。</p><h4 id="缅甸：将领改变路向"><a href="#缅甸：将领改变路向" class="headerlink" title="缅甸：将领改变路向"></a>缅甸：将领改变路向</h4><p>缅甸军政府在2011年开始改革，将缅甸从死胡同中挽救过来，然而这种彻底的改变，既不是源于深刻的自我反省或真实的顿悟，也不是一个濒临倒台的独裁政权急于自救的举动，而是别无选择。</p><p>对比于有着同样自然资源和气候条件的泰国，通过开发市场变得富裕，缅甸却停滞不前，整个国家固步自封近40年。直到2011年无路可走才选择掉头。</p><h4 id="新加坡：处在十字路口"><a href="#新加坡：处在十字路口" class="headerlink" title="新加坡：处在十字路口"></a>新加坡：处在十字路口</h4>]]></content>
    
    
    <summary type="html">这本书是关于李光耀先生对当今世界，以及在可预见的未来各股力量相互角力的看法。</summary>
    
    
    
    <category term="书评" scheme="http://naivertc.top/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
    <category term="人物传记" scheme="http://naivertc.top/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>在MacOS系统中使用OpenCV库（sandbox supported）</title>
    <link href="http://naivertc.top/2017/12/24/%E5%9C%A8MacOS%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8OpenCV%E5%BA%93%EF%BC%88sandbox%20supported%EF%BC%89/"/>
    <id>http://naivertc.top/2017/12/24/%E5%9C%A8MacOS%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8OpenCV%E5%BA%93%EF%BC%88sandbox%20supported%EF%BC%89/</id>
    <published>2017-12-24T09:47:07.000Z</published>
    <updated>2022-03-14T15:53:53.592Z</updated>
    
    <content type="html"><![CDATA[<p>最近因工作需要研究图片格式转换相关的知识点，其中使用到OpenCV库（一个基于BSD许可（开源）发行的跨平台计算机视觉库，很强大）中的ssim（结构相似性）算法实现来计算两张图片的相似度，用以做图片转换前后的对比。因此需要在Xcode中配置OpenCV库并且能在沙盒下使用，这一过程花费了将近一天的工作时间才配置成功，由于网上大多数资料基本上都是在非沙盒条件下的配置教程，对我没有太多实质性的帮助，这也是笔者写这篇博客的意义所在。</p><h3 id="安装OpenCV库"><a href="#安装OpenCV库" class="headerlink" title="安装OpenCV库"></a>安装OpenCV库</h3><p>在Mac下，安装OpenCV库的方式一般有两种：使用brew命令或者使用make编译源代码。笔者用的是第一种：在终端执行命令：brew insall opencv，即可安装opencv库及其所依赖的动态库。安装成功之后，会在命令行终端的最后一行显示当前OpenCV库的安装路径和版本号，笔者电脑上的安装路径为：/usr/local/Cellar/opencv/3.4.0_1，版本号为3.4.0_1。</p><p>在/usr/local/Cellar/opencv/3.4.0_1/include目录下有两个文件夹：opencv和opencv2，里面是OpenCV相关的头文件。/usr/local/Cellar/opencv/3.4.0_1/lib/下有许多前缀为libopencv_的dylib文件，这些都是OpenCV的链接库文件。</p><h3 id="在MacOS下配置并使用OpenCV库"><a href="#在MacOS下配置并使用OpenCV库" class="headerlink" title="在MacOS下配置并使用OpenCV库"></a>在MacOS下配置并使用OpenCV库</h3><p>笔者项目中用到OpenCV库中的libopencv_imgproc.3.4.0.dylib库。因此下文以这个库为例进行展开，其他的库类似操作即可。</p><h4 id="使用otool查看库依赖关系"><a href="#使用otool查看库依赖关系" class="headerlink" title="使用otool查看库依赖关系"></a>使用otool查看库依赖关系</h4><p>首先使用otool命令查看libopencv_imgproc.3.4.0.dylib的依赖关系，必须确保其这些依赖的库在系统中能够找到。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib </span><br><span class="line">/usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib:</span><br><span class="line">/usr/local/opt/opencv/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">@rpath/libopencv_core<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以看到libopencv_imgproc.3.4.0.dylib一共依赖了4个库，忽略系统自带的libc++.1.dylib和libSystem.B.dylib，因为这两个库任何Mac电脑上都可以找到。另外两个库分别是@rpath/libopencv_core.3.4.dylib和/usr/local/opt/tbb/lib/libtbb.dylib，分别查看这两个库所依赖的库。</p><p>查看libopencv_core.3.4.dylib库的依赖关系。这个库是以libopencv_开头的，与libopencv_imgproc.3.4.0.dylib在同一个目录下。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L  /usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib </span><br><span class="line">/usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib:</span><br><span class="line">/usr/local/opt/opencv/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libz<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1.2</span><span class="number">.5</span>)</span><br><span class="line">/System/Library/Frameworks/OpenCL.framework/Versions/A/OpenCL (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1.0</span><span class="number">.0</span>)</span><br><span class="line">/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">4.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，忽略系统自带的库之后其所依赖的库只有一个：/usr/local/opt/tbb/lib/libtbb.dylib。说明libtbb.dylib这个库同时被libopencv_core.3.4.dylib和libopencv_imgproc.3.4.0.dylib引用到。</p><p>查看libtbb.dylib库的依赖关系，在目录/usr/local/opt/tbb/lib/目录下可找到这个库。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/local/opt/tbb/lib/libtbb.dylib</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib:</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到libtbb.dylib库所依赖的都是系统自带的库，所以库依赖关系遍历到此结束。如果当前库还依赖于其他非系统自带库，则需要继续查找下去。</p><p>弄清楚库之间的依赖关系之后，接下来将库配置到Xcode中。</p><h4 id="无沙盒"><a href="#无沙盒" class="headerlink" title="无沙盒"></a>无沙盒</h4><p>如果是无沙盒条件下使用OpenCV还是很简单的，因为使用brew命令安装OpenCV过程中所有依赖的库都已帮你配置好了，只需要配置好头文件和库文件即可，不需要关心库之间的依赖关系。</p><p>首先配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/include。</p><p>配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/lib。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/1.png" alt="无沙盒配置头文件"></p><p>接着切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png" alt="无沙盒配置库文件"></p><p>对于 Lion 操作系统，需要在Xcode-&gt;Target-&gt;Build Settings中，将“C++ Language Dialect”设置成 C++11，将“C++ Standard Library”设置成libstdc++ ，如下图所示。个人感觉是由于Xcode默认设置的GNU++11、libc++与OpenCV库有一些兼容性问题，我在更改该设置前老是出现编译错误。后续版本在Montain Lion系统中解决了这个问题，因此不需要此操作。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/3.png" alt="无沙盒配置编译器"></p><p>注意，如果使用OpenCV库函数的源文件扩展名是.m的，你还需要改成.mm，这样编译器才知道该文件混合使用C++语言和Objective-C语言。</p><p>以上，无沙盒条件下配置完成。这种配置存在一个严重的缺陷，即如果想要编译后的软件在其他电脑上正常运行则必须确保其他电脑在同样系统目录下安装了OpenCV库，即OpenCV库头文件与链接库文件目录与编译电脑一致，显然这是不能接受的。常规的解决方法是将软件所依赖的库一并打包到软件中，具体配置过程可见于下文的有沙盒配置过程。</p><h4 id="有沙盒"><a href="#有沙盒" class="headerlink" title="有沙盒"></a>有沙盒</h4><p>有沙盒与无沙盒的区别出来签名之外，还有一个重要的区别就是访问权限。无沙盒条件下，软件和Xcode一样拥有当前用户下的最高权限，可以访问当前用户下的任何目录，这也是为什么在Xcode的配置项中可以直接使用当前用户的系统路径的原因。</p><p>一旦为添加沙盒条件后，软件所能访问的目录局限于自己的沙盒下，不再有访问当前用户系统目录的权限。此时，只有将软件所依赖的库一并打包到软件中，才能使软件正常运行。具体步骤如下所示。</p><p>首先，将软件所依赖的库文件和头文件拷贝到项目工程下的OpenCV目录中，分别存放于lib目录和include目录中：</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/4.png" alt="有沙盒配置拷贝库相关文件"></p><p>然后，配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：$(PROJECT_DIR)/OpenCV/include。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/5.png" alt="有沙盒配置头文件"></p><p>接着，配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：$(PROJECT_DIR)/OpenCV/lib。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/6.png" alt="有沙盒配置库文件"></p><p>其中PROJECT_DIR宏是Xcode自带的，表示xxx.xcodeproj文件所在的目录路径。</p><p>然后，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件用到依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png" alt="有沙盒配置关联库文件"></p><p>接着，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Copy Files”中，将libopencv_imgproc.3.4.0.dylib库及其所依赖的库拷贝到软件目录下的Frameworks中。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/7.png" alt="有沙盒配置关联库文件"></p><p>最后一步，使用install_name_tool命令修改依赖库之间、软件与依赖库的依赖关系。因为使用brew安装，库之间的依赖关系以及库本身的加载路径都是系统路径，在沙盒条件下是无效的。</p><p>切换到Xcode-&gt;Target-&gt;Build Phases的tab下，点击左上角的“+”，选择“New Run Script Phase”，新建一个“Run Script”项目，里面是一个shell脚本文件，在Xcode编译运行前执行。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/8.png" alt="有沙盒配置修改库依赖关系"></p><p>修改依赖关系的顺序很重要，如果依赖关系是：软件-&gt;dylibA-&gt;dylibB-&gt;dylibC，则修改依赖关系的顺序是：dylibC-&gt;dylibB-&gt;dylibA-&gt;软件。</p><p>笔者当前软件中的依赖关系是：软件-&gt;libopencv_imgproc.3.4.0.dylib-&gt;libopencv_core.3.4.0.dylib-&gt;libtbb.dylib。</p><p>由于libtbb.dylib库所依赖的都是系统自带库，因此不需要修改。</p><p>修改命令与参数简单介绍，详细使用方式可通过终端执行命令：man install_name_tool查看：<br>install_name_tool -change oldPath newPath lib(or executable file)</p><p><strong>1. 修改libopencv_core.3.4.0.dylib对libtbb.dylib的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/tbb/lib/libtbb.dylib"</span> <span class="string">"@loader_path/libtbb.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib"</span></span><br></pre></td></tr></tbody></table></figure><p>其中@loader_path是Xcode自带的宏，表示库加载路径，即libopencv_core.3.4.0.dylib的加载路径，因为libtbb.dylib与libopencv_core.3.4.0.dylib是在同一目录，因此@loader_path/libtbb.dylib表示告诉libopencv_core.3.4.0.dylib在自身所在目录中加载libtbb.dylib。</p><p>$TARGET_BUILD_DIR是Xcode自带的宏，表示Xcode编译目录，即编译后的软件存放的目录。PRODUCT_NAME宏也是Xcode自带的，表示软件名称。因为笔者项目中是先拷贝库文件到软件目录中，再修改依赖关系。因此libopencv_core.3.4.0.dylib库所在路径为：$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib。</p><p>以下修改命令类似，不再赘述。</p><p><strong>2. 修改libopencv_imgproc.3.4.0.dylib对libtbb.dylib和libopencv_core.3.4.0.dylib的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/tbb/lib/libtbb.dylib"</span> <span class="string">"@loader_path/libtbb.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib"</span></span><br><span class="line"></span><br><span class="line">install_name_tool -change <span class="string">"@rpath/libopencv_core.3.4.dylib"</span> <span class="string">"@loader_path/libopencv_core.3.4.0.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.软件对libopencv_imgproc.3.4.0.dylib库的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/opencv/lib/libopencv_imgproc.3.4.dylib"</span> <span class="string">"@executable_path/../Frameworks/libopencv_imgproc.3.4.0.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME"</span></span><br></pre></td></tr></tbody></table></figure><p>值得注意的是，软件路径必须可执行文件的路径$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME，而不能是$TARGET_BUILD_DIR/$PRODUCT_NAME.app，因为xxx.app文件本质上的一个目录。</p><p><strong>注意：如果在软件编译后运行时crash，并提示类似ImageLoaderMachO的错误则很可能是因为从系统目录下拷贝过来的库文件没有写的权限。因为OpenCV使用的是brew命令安装，brew使用的是root权限，而Xcode只有当前目录下的最高权限，所以必须确保库文件在当前用户下有读写权限，可以使用chmod +rw /path/to/dylib添加读写权限</strong></p><p>以上，在有沙盒条件下的配置完成。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>笔者在刚开始配置过程中，由于自身知识储备不足的原因被折腾得够呛。现在看来整个配置过程其实不难，通过博客记录一遍思路和流程显得更为清晰，理解也更为深刻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因工作需要研究图片格式转换相关的知识点，其中使用到OpenCV库（一个基于BSD许可（开源）发行的跨平台计算机视觉库，很强大）中的ssim（结构相似性）算法实现来计算两张图片的相似度，用以做图片转换前后的对比。因此需要在Xcode中配置OpenCV库并且能在沙盒下使用，</summary>
      
    
    
    
    <category term="iOS" scheme="http://naivertc.top/categories/iOS/"/>
    
    
    <category term="OpenCV" scheme="http://naivertc.top/tags/OpenCV/"/>
    
  </entry>
  
</feed>
