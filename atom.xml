<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MarkCao</title>
  
  
  <link href="http://naivertc.top/atom.xml" rel="self"/>
  
  <link href="http://naivertc.top/"/>
  <updated>2022-03-20T13:35:13.704Z</updated>
  <id>http://naivertc.top/</id>
  
  <author>
    <name>Mark Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YUV格式详解</title>
    <link href="http://naivertc.top/2021/03/20/YUV%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://naivertc.top/2021/03/20/YUV%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-19T23:00:07.000Z</published>
    <updated>2022-03-20T13:35:13.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>YUV色彩模型不同于RGB的新模型，其原理是利用人类视觉对色彩的亮度比色差更为敏感的特点，将亮度信息从色度信息中分离出来，即使没有色度信息一样可以显示完整的图像，只不过是黑白的。这样的设计很好的解决了彩色电视与黑白电视兼容的问题。</p><span id="more"></span><p>YUV使用三个分量来表示像素颜色，分别是：</p><ul><li><p>Y：Luma</p><p>  表示明亮度，描述像素的灰度值</p></li><li><p>U 和 V ：Chroma</p><p>  表示色度，描述像素的色调及饱和度</p></li></ul><p>YUV可以通过缩放和偏移衍生出很多变种，其中YCbCr是在计算机系统中应用最多的一种，JPEG和MPEG均采用这种格式。YCbCr中的Y表示亮度分量，Cb表示蓝色色度分量，Cr表示红色色度分量。</p><h3 id="多种采样格式"><a href="#多种采样格式" class="headerlink" title="多种采样格式"></a>多种采样格式</h3><p>YUV色彩模型支持Y（亮度分量）和UV （色度分量）使用不同的采样率，主流的采样方式有三种，分别是：</p><ul><li><p>YUV4:4:4 采样</p><p>  Y分量和UV分量的采样比例相同，即每1个Y分量对于1组UV分量。这种采用方式和RGB色彩模型的图像大小一样。</p></li><li><p>YUV4:2:2 采样</p><p>  Y分量和UV分量按照2:1的比例采样，即每采样两个Y分量才采样一组UV分量，因此每2个Y分量对于1组UV分量。这种采用方式比RGB格式节省1/3的存储空间。</p></li><li><p>YUV4:2:0 采样</p><p>  Y分量和U或V分量按照2:1的比例采样，即每采样两个Y分量才采样一个U分量或V分量，因此每4个Y分量对于1组UV分量。这种采用方式比RGB格式节省1/2的存储空间。因此，YUV4:2:0被选为主流的采样方式。</p></li></ul><h3 id="两种存储格式"><a href="#两种存储格式" class="headerlink" title="两种存储格式"></a>两种存储格式</h3><p>YUV有两种存储格式，分别是：</p><ul><li><p>planar格式</p><p>  先连续存储所有像素点的Y分量，然后是所有像素点的U分量，最后是所有像素点的V分量。比如YUV422P、YUV420P、YUV420SP、YV12和YU12 (属于YUV420)等。</p></li><li><p>packed格式</p><p>  每个像素点的Y、U、V分量连续交叉存储。大部分的采样方式都是采用packed格式的存储方式。</p></li></ul><p>以16x16的图像为例，以下是常见的YUV存储格式：</p><ol><li><p>YUYV格式</p><p> YUYV格式属于YUV422采样格式，采用packed存储方式。像素点还原方式：相邻的两个Y分量共用其相邻的两个Cb、Cr分量，比如像素点Y00和Y01共用Cb00和Cr00，其他的像素点以此类推。</p> <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start + 0:  Y00  Cb00  Y01  Cr00  Y02  Cb01  Y03  Cr01</span><br><span class="line">start + 8:  Y10  Cb10  Y11  Cr10  Y12  Cb11  Y13  Cr11</span><br><span class="line">start + 16: Y20  Cb20  Y21  Cr20  Y22  Cb21  Y23  Cr21</span><br><span class="line">start + 24: Y30  Cb30  Y31  Cr30  Y32  Cb31  Y33  Cr31</span><br></pre></td></tr></tbody></table></figure></li><li><p>UYVY格式 ，采用packed存储格式</p><p> UYVY格式属于YUV422采样格式，采用packed存储方式。与YUYV格式区别在于UV的排列顺序不同，还原像素点的方式与YUYV一样。</p> <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start + 0:  Cb00  Y00  Cr00  Y01  Cb01  Y02  Cr01  Y03</span><br><span class="line">start + 8:  Cb10  Y10  Cr10  Y11  Cb11  Y12  Cr11  Y13</span><br><span class="line">start + 16: Cb20  Y20  Cr20  Y21  Cb21  Y22  Cr21  Y23</span><br><span class="line">start + 24: Cb30  Y30  Cr30  Y31  Cb31  Y32  Cr31  Y33</span><br></pre></td></tr></tbody></table></figure></li><li><p>YUV422P</p><p> YUV422P，又叫I422，属于YUV422采样格式，采用planar存储方式。</p> <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------Y分量</span><br><span class="line">start + 0:  Y00  Y01  Y02  Y03</span><br><span class="line">start + 4:  Y10  Y11  Y12  Y13</span><br><span class="line">start + 8:  Y20  Y21  Y22  Y23</span><br><span class="line">start + 12: Y30  Y31  Y32  Y33</span><br><span class="line">-------------------------------U分量</span><br><span class="line">start + 16: Cb00 Cb01  </span><br><span class="line">start + 18: Cb10 Cb11 </span><br><span class="line">start + 20: Cb20 Cb21 </span><br><span class="line">start + 22: Cb30 Cb31</span><br><span class="line">-------------------------------V分量</span><br><span class="line">start + 24: Cr00 Cr01 </span><br><span class="line">start + 26: Cr10 Cr11 </span><br><span class="line">start + 28: Cr20 Cr21 </span><br><span class="line">start + 30: Cr30 Cr31 </span><br></pre></td></tr></tbody></table></figure></li><li><p>I420、YV12</p><p> I420和YV12都属于YUV420采用格式，采用planar存储方式。I420格式和YV12格式的不同处在U分量和V分量存放的顺序不同。在I420格式中，U分量在V分量之前，故又叫YU12。YV12则恰好相反，U分量在V分量之后。以下是I420的存储格式：</p> <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------Y分量</span><br><span class="line">start + 0:  Y00  Y01  Y02  Y03</span><br><span class="line">start + 4:  Y10  Y11  Y12  Y13</span><br><span class="line">start + 8:  Y20  Y21  Y22  Y23</span><br><span class="line">start + 12: Y30  Y31  Y32  Y33</span><br><span class="line">-------------------------------U分量</span><br><span class="line">start + 16: Cb00 Cb01  </span><br><span class="line">start + 18: Cb10 Cb11</span><br><span class="line">-------------------------------V分量</span><br><span class="line">start + 20: Cr00 Cr01 </span><br><span class="line">start + 22: Cr10 Cr11 </span><br></pre></td></tr></tbody></table></figure></li><li><p>NV12、NV21</p><p> NV12和NV21属于YUV420采样格式，是一种two-plane模式，Y分量视为一个plane，UV合并视为一个plane。Y和UV两个plane采用planar存储方式，但是UV内部为packed存储方式。</p> <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------Y分量</span><br><span class="line">start + 0:  Y00  Y01  Y02  Y03</span><br><span class="line">start + 4:  Y10  Y11  Y12  Y13</span><br><span class="line">start + 8:  Y20  Y21  Y22  Y23</span><br><span class="line">start + 12: Y30  Y31  Y32  Y33</span><br><span class="line">-------------------------------UV分量</span><br><span class="line">start + 16: Cb00 Cr00 Cb01 Cr01</span><br><span class="line">start + 20: Cb10 Cr10 Cb11 Cr11 </span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="YUV与RGB转换"><a href="#YUV与RGB转换" class="headerlink" title="YUV与RGB转换"></a>YUV与RGB转换</h3><p>鉴于使用YUV422格式或YUV420格式，能够在RGB格式的基础上显著地减少的数据量，且YUV422和YUV420的数据量为RGB的2/3和1/2。因此常将RGB转换成YUV格式进行传输，然后再将YUV格式转换成RGB格式进行显示。二者的转换公式如下：</p><ul><li><p>YUV转RGB：</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = 0.299 <span class="emphasis">* R + 0.587 *</span> G + 0.144 <span class="emphasis">* B</span></span><br><span class="line"><span class="emphasis">U = -0.168 *</span> R - 0.331 <span class="emphasis">* G + 0.5 *</span> B + 128</span><br><span class="line">V = 0.5 <span class="emphasis">* R - 0.419 *</span> G - 0.081 <span class="emphasis">* B + 128 </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>RGB转YUV:</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R = Y + 1.13983 <span class="emphasis">* (V - 128)</span></span><br><span class="line"><span class="emphasis">G = Y - 0.39465 *</span> (U - 128) - 0.58060 <span class="emphasis">* (V - 128)</span></span><br><span class="line"><span class="emphasis">B = Y + 2.03211 *</span> (U - 128)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/YUV">YUV - 维基百科，自由的百科全书</a></p><p><a href="https://blog.csdn.net/jane_6091/article/details/80633680">YUV色彩模型与RGB色彩模型详解_jane_6091的博客-CSDN博客_yuv颜色模型</a></p><p><a href="https://www.cnblogs.com/-9-8/p/4692653.html">YUV编码格式</a></p><p><a href="https://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html">图文详解YUV420数据格式</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;YUV色彩模型不同于RGB的新模型，其原理是利用人类视觉对色彩的亮度比色差更为敏感的特点，将亮度信息从色度信息中分离出来，即使没有色度信息一样可以显示完整的图像，只不过是黑白的。这样的设计很好的解决了彩色电视与黑白电视兼容的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="音视频" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="音视频" scheme="http://naivertc.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>RGB格式详解</title>
    <link href="http://naivertc.top/2021/03/15/RGB%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://naivertc.top/2021/03/15/RGB%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-14T23:00:07.000Z</published>
    <updated>2022-03-20T13:35:08.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>RGB色彩模型是工业界的一种颜色标准，又称三原色光模式，是一种加色模型。简单地说，因为红、绿、蓝这三种颜色是人眼的感知最为敏感的颜色，故称之为三原色。因此，将红、绿、蓝三原色的色光按照不同比例叠加，可以合成产生各种色彩光。</p><p>RGB色彩模型主要用于电子设备显示，比如电视或电脑，利用大脑强制视觉模糊化（失焦），将红绿蓝三原色分量合成一色彩色像素，进而产生感知层面的色彩，并不需要物理上将三种原色叠加。因此三原色背后的原理是基于生理原因而非物理原因。</p><p>RGB颜色模式所产生的颜色几乎覆盖了人类所能感知的所有色彩，因此是目前运用最广的色彩模型之一。</p><span id="more"></span><h3 id="两种格式"><a href="#两种格式" class="headerlink" title="两种格式"></a>两种格式</h3><p>RBG色彩模型有两种数据格式，分别是：</p><ul><li><p>索引格式</p><p>  这种格式是一种比较老的格式，所能表达的色彩有限，但相对于像素格式而已更节省空间。RGB对应的像素空间存储的不是像素值而是一个索引，通过索引可找在调色板找到对应的颜色。</p><p>  常用的类型有RGB1、RBG4和RGB8，分别表示用1 bit、4 bits和8 bits来表示一个像素，因此它们分别能表示的颜色范围为2种、16种和256种。</p></li><li><p>像素格式</p><p>  像素格式是一种新型的格式，RGB对应的像素空间中直接存储对应的像素值，这样不再需要调色板便可以直接表示色彩值。</p><p>  常用的类型有以下几种：</p><ul><li><p>RGB565</p><p>  每个像素使用2个字节表示，即16 bits，RGB分量从高到底分别占用5 bits、6 bits和5 bits</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high                                low</span><br><span class="line"><span class="code">|   5 bits |   6 bits  |   5 bits  |</span></span><br><span class="line"><span class="code">|----R-----|-----G-----|-----B-----|</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>RGB555</p><p>  每个像素使用2个字节表示，即16 bits，RGB分量从高到底分别占用5 bits、5 bits和5 bits，且最高位保留。</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high                                 low</span><br><span class="line"><span class="code">| |  5 bits  |   5 bits  |   5 bits  |</span></span><br><span class="line"><span class="code">|-|----R-----|-----G-----|-----B-----|</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>RGB24</p><p>  每个像素使用3个字节表示，即24 bits，RGB分量各占用1个字节，即8 bits。注：RGB24在内存中的存放顺序为BGR。</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high                                low</span><br><span class="line"><span class="code">|  8 bits  |   8 bits  |   8 bits  |</span></span><br><span class="line"><span class="code">|----B-----|-----G-----|-----R-----|</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>RGB32</p><p>  每个像素使用4个字节表示，即32 bits，RGB分量各占用1个字节，即8 bits，且最低位的1个字节保留。注：RGB32在内存的存放顺序为BGR。</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high                                             low</span><br><span class="line"><span class="code">|  8 bits  |   8 bits  |   8 bits  |    8 bits  |</span></span><br><span class="line"><span class="code">|----B-----|-----G-----|-----R-----|--reserved--|</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>ARGB32</p><p>  每个像素使用4个字节表示，即32 bits，RGB分量各占用1个字节，即8 bits，最低位的1个字节用于表示透明度alpha。注：ARGB32在内存的存放顺序为BGRA。</p>  <figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high                                             low</span><br><span class="line"><span class="code">|  8 bits  |   8 bits  |   8 bits  |    8 bits  |</span></span><br><span class="line"><span class="code">|----B-----|-----G-----|-----R-----|---alpha----|</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F">三原色光模式 - 维基百科，自由的百科全书</a></p><p><a href="https://blog.51cto.com/u_15077548/3518839">图解RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32等格式的区别_mb5ff591cb6ec96的技术博客_51CTO博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;RGB色彩模型是工业界的一种颜色标准，又称三原色光模式，是一种加色模型。简单地说，因为红、绿、蓝这三种颜色是人眼的感知最为敏感的颜色，故称之为三原色。因此，将红、绿、蓝三原色的色光按照不同比例叠加，可以合成产生各种色彩光。&lt;/p&gt;
&lt;p&gt;RGB色彩模型主要用于电子设备显示，比如电视或电脑，利用大脑强制视觉模糊化（失焦），将红绿蓝三原色分量合成一色彩色像素，进而产生感知层面的色彩，并不需要物理上将三种原色叠加。因此三原色背后的原理是基于生理原因而非物理原因。&lt;/p&gt;
&lt;p&gt;RGB颜色模式所产生的颜色几乎覆盖了人类所能感知的所有色彩，因此是目前运用最广的色彩模型之一。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="音视频" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="音视频" scheme="http://naivertc.top/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>跳表（skiplist）</title>
    <link href="http://naivertc.top/2020/03/17/%E8%B7%B3%E8%A1%A8%EF%BC%88skiplist%EF%BC%89/"/>
    <id>http://naivertc.top/2020/03/17/%E8%B7%B3%E8%A1%A8%EF%BC%88skiplist%EF%BC%89/</id>
    <published>2020-03-16T23:00:07.000Z</published>
    <updated>2022-03-20T13:36:56.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>跳表是一种基于并联的链表，底层是一个普通的有序链表，更高层链表是基于随机方式构建的稀疏子链表，充当下层链表的快速通道，因此链表的长度由低到高层层递减。</p><p>跳表的查找、插入和删除操作的平均时间复杂度都为O(logn)，有效地解决有序链表查询效率低下的问题。</p><p>注意：跳表的最底层必须是一个有序链表。</p><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>构建一个跳表可分以下4个步骤：</p><ol><li>给定一个有序的链表作为底层。</li><li>构建上一层链表：<ol><li>选出当前层中的最大和最小的元素；</li><li>从当前层的剩余的元素中按照随机算法选出一定数量n的元素，n+2小于当前层元素个数；</li><li>将所有选出的元素组成有序链表，作为当前层的上一层链表；</li><li>给新增的链表中的所有元素添加一个指针域，该指针指向下一层中元素的值与自己相等的元素。</li></ol></li><li>重复步骤2，直到当前层的只剩下最大和最小的两个元素为止。</li></ol><p>C语言中常使用结构体+可变长数组的结构作为节点，如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NodeStructure</span> {</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeStructure</span>* <span class="title">forward</span>[1];</span> <span class="comment">// struct hack,可变长数组</span></span><br><span class="line">}Node;</span><br></pre></td></tr></tbody></table></figure><p>这样做的的好处在于所有层的值相同的节点共享一个节点，通过可变长数组实现不同层的定位。</p><p>注：C++由于虚表指针的位置存放在对象的最末端（一般是在对象起始位置，由编译器决定），因此struct hack不适应与C++对象。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><p>插入</p><ol><li>新建一个数组update，长度为当前跳表的最大层数值。</li><li>从高层往下遍历，查找新节点在每一层的插入位置，即新节点在该层的上一个节点，将该节点放入update。</li><li>生成一个随机数k用于表示新节点即将插入的层数。如果该值大于当前层数n，则需要更新链跳表。<ol><li>在更高层新建k-n层，并将新建层的头指针指向跳表头指针。</li><li>更新跳表的层数为k。</li></ol></li><li>基于k值，逐层插入新节点，与普通链表插入操作一样。</li></ol></li><li><p>删除</p><p>  删除操作与插入操作的前两步一样，使用update数组记录删除的位置，然后逐层删除目标节点。</p><p>  不同之处在于，如果目标节点是当前层的最大值，则需要更新跳表的层数。</p></li><li><p>查询</p><ol><li>从高层往下查找，逐层遍历。</li><li>在该层找到值小于或等于目标节点的节点：<ol><li>如果当前节点的值等于目标节点，则查找完成。</li><li>否则，从当前节点进入下一层，继续向后查找。</li></ol></li><li>否则进入下一层遍历。</li></ol></li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>跳表是按层构造的，底层是一个有序链表，而更高层是按某个固定的概率p从下一层选取元素，换言之下一层的元素个数是上一层的1/p倍。</p><ul><li><p>时间复杂度</p><p>  跳表的时间复杂度取决于跳表的层数，跳表的层数为log(1/p)^n。且p是常数，所以跳表的查询、插入和删除操作的平均时间复杂度为O(logn)，最坏情况是退化为链表的复杂度O(n)。</p></li><li><p>空间复杂度</p><p>  假设底层链表的元素个数为n，那么第i级索引的个数为n/(p^i)。跳表所有节点的总和是：<em><strong>∑ =</strong></em> n + n/(p^1) + n/(p^2) + n/(p^3) + … + 1，又因为p是常数，所以跳表的平均空间复杂度为O(n)。</p><p>  最坏情况是每一层都与底层链表的元素个数相同，此时空间复杂度为O(nlogn)。</p></li></ul><h3 id="对比平衡树"><a href="#对比平衡树" class="headerlink" title="对比平衡树"></a>对比平衡树</h3><p>跳表的出现是为了解决有序链表查询效率低下的问题，而平衡树的发明也同样是为了解决有序链表的查询瓶颈。常用的平衡树有AVL树和红黑树。</p><p>跳表在查询、插入和删除操作的时间复杂度上能与AVL树和红黑树媲美。相较于平衡树通过复杂的旋转操作为维持平衡，跳表采用的是以空间换时间的方式，因此在实现上比平衡树更为简单。redis就是选择跳表作为底层存储结构。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">跳跃列表 - 维基百科，自由的百科全书</a></p><p><a href="https://www.iteye.com/blog/dsqiu-1705530">Skip List（跳跃表）原理详解与实现 - One thing I know,that is I know nothing.(Socrates Greek) - ITeye博客</a></p><p><a href="https://www.cnblogs.com/Laymen/p/14084664.html">跳表(SkipList)原理篇</a></p><p><a href="https://www.zhihu.com/question/20202931">为啥 redis 使用跳表(skiplist)而不是使用 red-black？</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;跳表是一种基于并联的链表，底层是一个普通的有序链表，更高层链表是基于随机方式构建的稀疏子链表，充当下层链表的快速通道，因此链表的长度由低到高层层递减。&lt;/p&gt;
&lt;p&gt;跳表的查找、插入和删除操作的平均时间复杂度都为O(logn)，有效地解决有序链表查询效率低下的问题。&lt;/p&gt;
&lt;p&gt;注意：跳表的最底层必须是一个有序链表。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://naivertc.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>红黑树（Red-black tree）</title>
    <link href="http://naivertc.top/2020/03/14/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-black%20tree%EF%BC%89/"/>
    <id>http://naivertc.top/2020/03/14/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-black%20tree%EF%BC%89/</id>
    <published>2020-03-13T23:00:07.000Z</published>
    <updated>2022-03-20T13:36:42.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>红黑树同AVL树一样也是一种自平衡二叉搜索树，不同于AVL树是高度平衡树，红黑树属于近似平衡树。</p><p>所谓近似平衡就是对平衡的要求相对宽松，不像AVL树那么严格。红黑数的平衡标准是：任一节点的左右子树的高度差小于两倍。 </p><span id="more"></span><p>判断一颗二叉搜索树是否是红黑树的条件如下:</p><ul><li>每个节点非黑即红</li><li>根节点必须是黑色</li><li>每个叶子节点必须是黑色，即NIL节点或空节点必须是黑色</li><li>不能出现连续的红色节点，即不能有两个相邻的红色节点</li><li>任一节点到其每个叶子节点的所有路径都包含相关数目的黑色节点</li></ul><p>其中，最后两点可确保红黑树的平衡标准始终得以满足，证明过程略。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度</p><p>  由于红黑树也是近似平衡树，所以其查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。</p></li><li><p>空间复杂度</p><p>  红黑树的空间复杂度只与节点个数相关，因此为O(n)。</p></li></ul><h3 id="对比AVL数"><a href="#对比AVL数" class="headerlink" title="对比AVL数"></a>对比AVL数</h3><p>红黑树与AVL树的比较：</p><ul><li>AVL树的查找速度更快，因为AVL有更为严格的平衡标准</li><li>红黑树提供了更快的插入和删除的操作，因为红黑树的平衡标准更为宽松，所以旋转操作更少。</li><li>红黑树对额外空间的消耗更小。AVL树的每一个节点需要存储一个平衡因子或高度值，只是需要一个整型，而红黑树只需要一个bit位用于标识节点的颜色属性，非红即黑。</li></ul><p>综上， 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入或删除操作更少的旋转操作，整体来说性能优于AVL树。</p><p>注：红黑树和AVL树在数据量较小时的性能相近，但是在百万或千万级的数据量时，二者的性能差异会比较明显。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>鉴于红黑树在插入和删除的性能更佳，因此广泛用于实现插入或删除操作较为频繁的数据结构，如C++的STL中map和set等。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树 - 维基百科，自由的百科全书</a></p><p><a href="https://www.coursera.org/lecture/algorithms-part1/red-black-bsts-GZe13">Red-Black BSTs - Balanced Search Trees | Coursera</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;红黑树同AVL树一样也是一种自平衡二叉搜索树，不同于AVL树是高度平衡树，红黑树属于近似平衡树。&lt;/p&gt;
&lt;p&gt;所谓近似平衡就是对平衡的要求相对宽松，不像AVL树那么严格。红黑数的平衡标准是：任一节点的左右子树的高度差小于两倍。 &lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://naivertc.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自平衡二叉搜索树（AVL）</title>
    <link href="http://naivertc.top/2020/03/09/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL%EF%BC%89/"/>
    <id>http://naivertc.top/2020/03/09/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL%EF%BC%89/</id>
    <published>2020-03-08T23:00:07.000Z</published>
    <updated>2022-03-20T13:36:10.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>AVL树是计算机科学中最早被发明的自平衡二叉搜索树，顾名思义，AVL首先是一颗平衡树，其次它能够实现自平衡。</p><span id="more"></span><h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>AVL树引入了平衡因子（Balance Factor）的概念，即任意一个节点的左右子树的最大高度差为1，因此平衡因子的取值范围是：{-1, 0, 1}。因此，AVL树也被称为高度平衡树。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度</p><p>  由于AVL树一直都处于高度平衡的状态，所以其查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。</p></li><li><p>空间复杂度</p><p>  AVL树的空间复杂度只与节点个数相关，因此为O(n)。</p></li></ul><h3 id="四种旋转"><a href="#四种旋转" class="headerlink" title="四种旋转"></a>四种旋转</h3><p>由于AVL树需要时刻保持平衡状态，因此在每一次插入或删除后都可能需要进行旋转操作，以确保插入或删除后的AVL树仍然处于平衡状态。</p><p>AVL旋转主要包括四种基础旋转，分别是：</p><ul><li>左旋转</li><li>右旋转</li><li>左右旋转：先进行一次左旋转，再进行一次右旋转</li><li>右左旋转：先进行一次右旋转，再进行一次左旋转</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><p>  AVL树的优势源于它的高度平衡，不管是查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。</p></li><li><p>不足</p><p>  AVL树不足是为了维持高度平衡，节点需要存储额外的信息，比如每个节点需要存储一个平衡因子（至少是一个整数类型）。</p><p>  此外，由于AVL树每次插入或删除操作后都可能需要进行旋转操作，所以调整次数会比较频繁，导致维护成本偏高。</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>鉴于AVL树的优缺点，AVL树适用于查询操作远大于插入或删除的场景，比如数据库。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91">平衡树 - 维基百科，自由的百科全书</a></p><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树 - 维基百科，自由的百科全书</a></p><p><a href="https://www.youtube.com/watch?v=vVcBk9aan8k&amp;ab_channel=%E8%AE%A4%E7%9F%A5%E5%8D%87%E7%BA%A7%E5%BA%93">第15课丨AVL树和红黑树的实现和特性</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;AVL树是计算机科学中最早被发明的自平衡二叉搜索树，顾名思义，AVL首先是一颗平衡树，其次它能够实现自平衡。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://naivertc.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树（BST）</title>
    <link href="http://naivertc.top/2020/03/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89/"/>
    <id>http://naivertc.top/2020/03/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89/</id>
    <published>2020-03-05T23:00:07.000Z</published>
    <updated>2022-03-20T13:23:58.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>二叉查找树（Binary Search Tree），又叫有序二叉树，具有以下3个性质：</p><ul><li>左子树如果不为空，那么它所有的节点的值都小于它的根节点</li><li>右子树如果不为空，那么它所有的节点的值都大于它的根节点</li><li>任意节点的左、右子树都是二叉查找树。</li></ul><span id="more"></span><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度</p><p>  由于二叉搜索树的查询、插入或删除的时间复杂度取决于目标节点到根节点的距离，即深度。</p><p>  二叉搜索树可分为平衡树和非平衡树两大类，注：此处的平衡是指所有叶子的深度趋于平衡。</p><ul><li>平衡度最高的二叉树是AVL树，其时间复杂度同二分查找一样为O(logN)</li><li>非平衡树最极端的情况是偏斜二叉树，即所有的节点都在根节点的一边，也就是链表结构。此时树的深度为n，其时间复杂度同顺序查找一样为O(n)</li></ul><p>  因此，二叉搜索树的时间复杂度介于O(logn)和O(n)之间。  </p></li><li><p>空间复杂度</p><p>  二叉搜索树的空间大小只与其节点的个数相关，所以其空间复杂度是O(n)。</p></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>二叉搜索树有三种遍历方式，分别是：</p><ul><li>先序遍历：根节点→左节点→右节点。</li><li>中序遍历：左节点→根节点→右节点，结果是一个有序序列。</li><li>后序遍历：左节点→右节点→根节点。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><p>  二叉搜索树是介于数组和链表的一种折中方案，数组查找方便但是插入或删除麻烦，而链表则恰好与数组相反。</p><p>  相较之下，二叉查找树在查找、插入或删除的时间复杂度都较低，适用于处理大批量的动态数据。</p></li><li><p>缺点</p><p>  构建二叉搜索树本身或维护其平衡需要额外的时间或空间成本。</p></li></ul><p>参考资料</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二元搜尋樹 - 维基百科，自由的百科全书</a></p><p><a href="https://blog.csdn.net/xuxinrk/article/details/89553511">二叉排序树（二叉搜索树）的时间复杂度&amp;空间复杂度_xuxinrk的博客-CSDN博客_二叉查找树的时间复杂度</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;二叉查找树（Binary Search Tree），又叫有序二叉树，具有以下3个性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子树如果不为空，那么它所有的节点的值都小于它的根节点&lt;/li&gt;
&lt;li&gt;右子树如果不为空，那么它所有的节点的值都大于它的根节点&lt;/li&gt;
&lt;li&gt;任意节点的左、右子树都是二叉查找树。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://naivertc.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>++i和i++的区别</title>
    <link href="http://naivertc.top/2020/01/07/++i%E5%92%8Ci++%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://naivertc.top/2020/01/07/++i%E5%92%8Ci++%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-01-06T23:00:07.000Z</published>
    <updated>2022-03-20T13:34:48.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>二者的区别本质上在于++i属于左值操作，而i++属于右值操作，可分以下几种情况分析：</p><span id="more"></span><ul><li><p>只有自增操作</p><p>  如果只用于自增操作，++i和i++经过编译器优化之后其实是等价的，以下是二者的汇编代码（编译器为x86-64 gcc 11.2）：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">++i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编代码</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="type">int</span>):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     DWORD PTR [rbp<span class="number">-4</span>], edi     <span class="comment">// 形参i赋值</span></span><br><span class="line"></span><br><span class="line">        add     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">1</span>       <span class="comment">// ++i</span></span><br><span class="line"></span><br><span class="line">        <span class="function">nop</span></span><br><span class="line"><span class="function">        pop     rbp</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function"><span class="title">f2</span><span class="params">(<span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-4</span>], edi    // 形参i赋值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        add     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">1</span>      // i++</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        pop     rbp</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></tbody></table></figure><p>  此处，i++被编译优化后变成了左值操作，因此二者的汇编代码相同。那么在这种情况下它们的执行速度也是一样的。</p></li><li><p>自增后赋值</p><p>  如果自增后再赋值，编译器将严格安装二者的左右值属性进行操作，比如：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">i = ++i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">i = i++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编代码</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="type">int</span>):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     DWORD PTR [rbp<span class="number">-4</span>], edi</span><br><span class="line"></span><br><span class="line">        add     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">1</span>   <span class="comment">// ++i仍使用一行汇编指令即可完成自增和赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="function">nop</span></span><br><span class="line"><span class="function">        pop     rbp</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function"><span class="title">f2</span><span class="params">(<span class="type">int</span>)</span>:</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-4</span>], edi</span></span><br><span class="line"><span class="function">// i++则会被拆分成<span class="number">3</span>条汇编指令：</span></span><br><span class="line"><span class="function">        mov     eax, DWORD PTR [rbp<span class="number">-4</span>]  // 右值操作：读取i值，存入临时变量中，即寄存器eax</span></span><br><span class="line"><span class="function">        lea     edx, [rax+<span class="number">1</span>]            // 寄存器自增加<span class="number">1</span></span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-4</span>], edx  // 将自增后的右值赋值给形参i（i是左值）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-4</span>], eax</span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        pop     rbp</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></tbody></table></figure><p>  由于i++对应三条汇编指令，而++i只有一条汇编指令，因此这种情况下，++i的执行速度会快于</p><p>  i++。</p><p>  此外，由于i++会被拆分成3条汇编指令，因此在未加锁的多线程环境下，三条指令执行中可能会因为线程切换而出现中断，进而导致计算结果未知。而由于++i只有一条汇编指令，因++i还可避免因为i++引入的竞争问题。</p></li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>计算 i++ + i++</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">i++ + i++ = <span class="number">3</span>;    <span class="comment">// 从左往右：先执行第一个i++，返回值为字面量1，此时i = 1 + 1 = 2，</span></span><br><span class="line">  <span class="comment">// 再执行第二个i++，返回值为字面量2，此时i = 2 + 1 = 3，</span></span><br><span class="line">  <span class="comment">// 最后两个返回值相加，1 + 2 = 3</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>计算 ++i + i++ 和 i++ + ++i</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ++i + i++ </span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">++i + i++ = <span class="number">5</span>;     <span class="comment">// 从左往右：先执行++i，返回值是i的引用r，此时i自增一次值为2</span></span><br><span class="line">   <span class="comment">// 再执行i++，返回值为字面量2，此时i经过两次自增后值为3</span></span><br><span class="line">   <span class="comment">// 最后两个返回值相加，r + 2 = 3 + 2 = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i++ + ++i</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">i++ + ++i = <span class="number">3</span>;     <span class="comment">// 从左往右：先执行i++，返回值为字面量1，此时i = 2，</span></span><br><span class="line">   <span class="comment">// 在执行++i，返回值为i的引用r，此时i经过两次自增后值为3，</span></span><br><span class="line">   <span class="comment">// 最后两个返回值相加：1 + r = 1 + 3 = 4</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>计算 ++i + ++i</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">++i + ++i = <span class="number">6</span>;      <span class="comment">// 从左往右：先执行第一个++i，返回值是i的引用r1，</span></span><br><span class="line">    <span class="comment">// 再执行第二个++i，返回值为i的引用r2，此时i经过两次自增后值为3，</span></span><br><span class="line">    <span class="comment">// 最后两个返回值相加，3 + 3 = 6</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>计算 ++i + ++i + ++i</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">++i + ++i + ++i = <span class="number">10</span>;   <span class="comment">// 从左往右：先执行第一个++i，返回值是i的引用r1，</span></span><br><span class="line"><span class="comment">// 再执行第二个++i，返回值是i的引用r2，此时i经过两次自增后值为3，</span></span><br><span class="line"><span class="comment">// 此时对两个返回值相加，返回值为字面量a：r1 + r2 = 6，</span></span><br><span class="line"><span class="comment">// 然后执行第三个++i，返回值是i的引用r3，此时i经过三次自增后值为4，</span></span><br><span class="line"><span class="comment">// 最后执行第二个加法：a + r3 = 6 + 4 = 10 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理可得</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">i += ++i + ++i + ++i = <span class="number">4</span> + <span class="number">10</span> = <span class="number">14</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;二者的区别本质上在于++i属于左值操作，而i++属于右值操作，可分以下几种情况分析：&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>关于熵的一点理解</title>
    <link href="http://naivertc.top/2019/10/10/%E5%85%B3%E4%BA%8E%E7%86%B5%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://naivertc.top/2019/10/10/%E5%85%B3%E4%BA%8E%E7%86%B5%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/</id>
    <published>2019-10-10T15:16:07.000Z</published>
    <updated>2022-03-20T14:23:47.625Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了台湾医学教授柯文哲在TED演讲《生死的智慧》，里面提及了熵的概念，这也是我第一次接触熵这个概念。出于兴趣做了一些粗浅的了解，才发现这其实就是宇宙的终极规则。</p><span id="more"></span><p>他对熵和死亡的理解让我印象深刻：“从科学上讲，一切物理化学反应都应该趋向最低能量、最大乱度，也就是熵。人的存在其实是违反这种趋向的。任何组织的团体都是不稳定的，必须通过破坏环境才能使得总的趋向是最低能量、最大乱度的。有一天，我再不能破坏环境，就只好破坏自己，这就叫死亡。</p><p>那什么是死亡？追求这个问题的答案就是这个问题的答案。因为人一定会死，所以死亡不是人生的目的，人生就是一个过程。我们在这个过程中不断去锥形一个问题，这就是是人生。置于死地而后生，我们唯有面对死亡，才能看清人生到底是什么？人终究会死，人生只是一个追求人生意义的过程。</p><p>人生应该像a的n次方。如果a大于1，a的n次方就无限大；如果a小于1，a的n次方很快就趋近于零。你知道这是什么意思？我对社会的付出多于索取，就代表a大于1，每个人都如此，社会就会越来越好，如果每个人对社会都是索取大于付出，就代表a小于1，社会很快就会崩溃。”</p><p>根据热力学第一定律，即能量守恒定律，能量在理论上是可以在不同能量形态之间完成百分百地转换的。然而，现实生活中缺并非如此。比如，蒸汽机在将热能转换为机械能的过程中，总是有一些热能损耗掉。</p><p>物理学家将这些在能量转换过程中浪费掉的、无法再利用的能力称为熵。根据热力学第二定律：能量转换总是会产生熵，如果是在封闭的系统中，所有能量最终都会变成熵。能量转换过程中会创造新的状态，熵就是进入这些状态的能量。</p><p>状态多就是可能性多，表示比较混乱；状态少，就可能性少，相对来说比较有秩序。能量转换会让系统的混乱度增加，而熵就是系统混乱度。在没有外力注入的情况下，所有封闭系统最终都会趋向于混乱度最大的状态。从宏观层面来说，如果不施加外力影响，事物永远向着更加混乱的状态发展。比如，房间如果没人打扫，会变得越来越乱。</p><p>如果从熵的角度来理解人类的发展进程，那么人类社会并非一定会变得更进步、更文明。过去五千年，人类文明的进步只是因为人类学会利用外部力量，包括驯化牲畜、运用火种、利用水力等，使得人类社会向着文明有序的方向发展。</p><p>随着工业革命的到来，人类社会进步的步伐加快，使用的能量也呈指数级增长，能量消耗越大，就会产生越多的熵。因此，人类社会始终处于一种矛盾的状态：整个社会变得更加有秩序和严密的同时，无序和混乱也在暗处不断地滋长。</p><p>物理学告诉我们，没有办法消除熵和混乱，我们只能不断依靠更大的外力输入，维持现有的秩序，于此同时产生了更大的熵和混乱，如此反复。</p><p>迄今为止，人类一直能够找到足够的能量和替代资源来解决熵带来的混乱。假如未来的某一天，人类无法弥补日渐增大的能量缺口，地球的能量不足以解决熵，那是一切就会发生逆转，人类秩序开始崩塌，世界走向混乱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了台湾医学教授柯文哲在TED演讲《生死的智慧》，里面提及了熵的概念，这也是我第一次接触熵这个概念。出于兴趣做了一些粗浅的了解，才发现这其实就是宇宙的终极规则。&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://naivertc.top/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>关于中国的户籍改革的一点想法</title>
    <link href="http://naivertc.top/2019/07/28/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%88%B7%E7%B1%8D%E6%94%B9%E9%9D%A9%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
    <id>http://naivertc.top/2019/07/28/%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%88%B7%E7%B1%8D%E6%94%B9%E9%9D%A9%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</id>
    <published>2019-07-28T15:25:07.000Z</published>
    <updated>2022-03-20T14:21:27.592Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇文章是看《意见中国–经济学家访谈录》第112期，秦晖教授谈论“户籍制度背后的三大不平等”的观后感。</p><span id="more"></span><p><strong>观点一：户籍制度改革落后于人们的期望</strong></p><p>有人说这种户籍制度只有中国和北朝鲜才有，其实把人分成不同等级和身份，享有不同权利的制度很大程度上在前现代很多民族都有。</p><p>但是这种身份性等级制度是以国家法律的方式强制推行，并且普及到社会几乎所有人，且有具有很明显的原始记录功能的个例很少。另外一个类似的例子出现在南非种族隔离时代。</p><p>这种制度的产生的主要原因是为了实现国家的原始积累。一方面，大量的农民工进城打工带来拥有廉价劳动力，又因为城市户籍人口远小于农村人口因此城市有大量的廉价土地，这是所谓的良好投资环境的基础要素。另一方面，一旦城市不需要这些农民工，可以通过户籍制度驱使其中的大部分人回到农村，避免了一些国家由于自由居住造成的城市贫民窟问题。</p><p>户籍制度背后是人权、财产权和公共服务的不平等。普通的外来农民工对户籍改革的期望很低，只有不被赶出贫民窟，不需要任何补偿。很多发展中国家的飞速发展都是建立在低人权的基础之上。</p><p>在户籍改革之前，即取消现存户籍类别之前，农村人口是不能随便进城，如果一定进城需要有相关的证明，否则就可能被抓，到后面逐渐改为罚款，再到现在的默认迁移。从这个趋势来看，都是朝着废除户籍和不合理的身份等级的方向发展。只不过离人们的预期还有相当大的距离。而造成户籍制度落后的原因是：政府权力不受限制和政府的责任不可追问。</p><p><strong>观点二：户籍制度考验人的忍耐力</strong></p><p>户籍制度需要改革其背后的三大平等：一是人权不平等，尤其是居住权；二是财产权不平等，即农民的土地不是他们真正的财产；三是公共服务福利的不平等。</p><p>在一个宪政国家，比如欧美国家，一个国家政府能够承担多大的公共服务责任，公民就为让出相应的权利，这是由契约决定的。</p><p>然而，现在的中国拥有一个无限权利的政府，但是百姓又不能对其进行问责。这就是造成这三个不平等的根本原因。</p><p>对于受户籍制度管制的百姓来说，现在的户籍制度对他们没有什么积极的意义可言，只是一个忍耐力的问题罢了。</p><p><strong>观点三：减少大城市的吸引力</strong></p><p>很多人担心农村人口大量涌入城市，造成大城市规模的过度膨胀，因此需要“排挤”很大一部分外来人口。然而，从另外一个角度来看，之所以造成这种现象是因为这些大城市享有的特权远远大于其他地方。比如北京，即是集政治、经济、文化三个中心唯一体，享受最后的社会福利和资源。</p><p>如果能够通过减少大城市的吸引力，平衡不同城市直接的吸引力和特权，才是解决问题的根本。</p><p><strong>小记</strong></p><p>早上与好友聊天，我们以前在一个镇上读小学。他对我感叹到现在我们镇上的孩子只能在镇上完成九年义务教育，除非你在县城买房子。记得我们读书那会还可以通过考试进入县城的高中读书。</p><p>教育资源的稀缺的，县城的资源绝对不是镇上能比拟的。有稀缺就要区别对待，区别对待就意味着歧视。另外一个原因是，现在城市人口比例已经超过农村人口，不同与我们那个时候农村人口占多数。因此，现在对农村人口进行这样赤裸裸的歧视，其实是对于弱势群体的歧视。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天这篇文章是看《意见中国–经济学家访谈录》第112期，秦晖教授谈论“户籍制度背后的三大不平等”的观后感。&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://naivertc.top/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>初识汇编-知识点摘记</title>
    <link href="http://naivertc.top/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
    <id>http://naivertc.top/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/</id>
    <published>2019-06-27T13:34:07.000Z</published>
    <updated>2022-03-20T10:43:20.736Z</updated>
    
    <content type="html"><![CDATA[<h4 id="汇编语言的由来"><a href="#汇编语言的由来" class="headerlink" title="汇编语言的由来"></a>汇编语言的由来</h4><ul><li>汇编语言是基于机器语言（由0或1组成）而产生的一种助记符</li><li>汇编语言介于机器语言和高级语言之间</li><li>汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令</li><li>汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言</li><li>高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。</li></ul><span id="more"></span><h4 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h4><p><strong>优点</strong></p><ul><li>汇编语言可直接访问或控制硬件：存储器、CPU，能最大限度的发挥硬件功能</li><li>目标代码少，占位内存少，执行速度快</li><li>不同厂商的CPU都有对应的机器指令集和汇编指令集合</li><li>大小写不敏感</li></ul><p><strong>缺点</strong></p><ul><li>不易于编写、维护、调试</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>CPU由寄存器、运算器和控制器组成，其中最主要部件是寄存器，通过改变寄存器的内容来实现对CPU的控制</li><li>不同的CPU，寄存器个数和结构存在差异</li></ul><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul><li>arm64寄存器有31个64位的通用寄存器x0-x30，这些寄存器通常用来存放一般数据</li><li>w0-w28是32位寄存器，是x0-x28寄存器的低32位，即64位的CPU是兼容32位的</li><li>CPU会先将内存中的数据存储到通用寄存器中，然后在对通用寄存器中的数据进行运算，原因在于寄存器的执行速度比内存快</li><li>arm64架构下，函数参数都是保存在x0-x7（32位下即w0-w7）这8个寄存器，超过8个参数入栈</li><li>函数返回值是存放在x0寄存器中</li><li>函数的局部变量都是保存在栈中</li></ul><h5 id="PC寄存器：program-counter-register"><a href="#PC寄存器：program-counter-register" class="headerlink" title="PC寄存器：program counter register"></a>PC寄存器：program counter register</h5><ul><li>指令指针寄存器，指向CPU当前要执行的指令地址</li><li>内存中指令和数据无区别，都是二进制数据。CPU将PC寄存器指向的内存单元的内容看作指令</li></ul><h5 id="sp与fp寄存器"><a href="#sp与fp寄存器" class="headerlink" title="sp与fp寄存器"></a>sp与fp寄存器</h5><ul><li>sp寄存器会在任意时刻保存栈顶地址</li><li>fp寄存器即为x29寄存器，有时也用于保存栈低的地址</li></ul><h5 id="lr寄存器"><a href="#lr寄存器" class="headerlink" title="lr寄存器"></a>lr寄存器</h5><ul><li>lr寄存器就是0x30通用寄存器</li><li>0x30寄存器存放函数返回地址，执行ret指令时会读取这个寄存器的值，实现函数返回</li></ul><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><h5 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h5><blockquote><p>arm64架构中取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp；ldp/stp是ldr/str的衍生，可同时读写两个寄存器，而ldr/str只能读写一个</p></blockquote><ul><li>str指令：store register指令，将数据从寄存器中读出，写入内存</li><li>ldr指令：load register指令，将数据从内存读出，存入寄存器</li></ul><p>eg：利用栈将x0和x1寄存器中的值互换</p><blockquote><p>arm64架构中，栈是16字节内存对齐的，即一次读写至少是16（0x10）个字节</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub sp,sp,#0x10 ;栈顶指针下移0x10个字节，两个64位的寄存器共16个字节</span><br><span class="line">stp x0,x1,[sp,0x10] ;寄存器x0,x1先后的值入栈</span><br><span class="line">ldp x1,x0,[sp,0x10] ;出栈，先后写入x0,x1寄存器</span><br><span class="line">add sp,sp,0x10 ;栈还原，stp、ldp指令不会改变sp指针位置，且都是由高地址向低地址读写</span><br></pre></td></tr></tbody></table></figure><h5 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h5><ul><li>CPU执行的指令是由PC寄存器决定的，因此可以通过修改PC寄存器的内容来控制CPU的指令执行</li><li>传送指令用于操作通用寄存器，比如mov指令；此外是转移指令，用于修改PC的值，最简单的就是bl指令</li><li>bl指令跳转前将当前指令的下一条指令存放到lr(0x30)寄存器：链接寄存器</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;汇编语言的由来&quot;&gt;&lt;a href=&quot;#汇编语言的由来&quot; class=&quot;headerlink&quot; title=&quot;汇编语言的由来&quot;&gt;&lt;/a&gt;汇编语言的由来&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;汇编语言是基于机器语言（由0或1组成）而产生的一种助记符&lt;/li&gt;
&lt;li&gt;汇编语言介于机器语言和高级语言之间&lt;/li&gt;
&lt;li&gt;汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令&lt;/li&gt;
&lt;li&gt;汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言&lt;/li&gt;
&lt;li&gt;高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="汇编" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>关于真相的一点想法</title>
    <link href="http://naivertc.top/2019/06/26/%E5%85%B3%E4%BA%8E%E7%9C%9F%E7%9B%B8%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
    <id>http://naivertc.top/2019/06/26/%E5%85%B3%E4%BA%8E%E7%9C%9F%E7%9B%B8%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</id>
    <published>2019-06-26T15:02:00.000Z</published>
    <updated>2022-03-20T14:21:48.033Z</updated>
    
    <content type="html"><![CDATA[<p>都说现在的人越来越浮躁，愿意思考的人越来越少，导致整个社会都显得浮躁不安。我觉得其实我们一直以来都是这样的，与这个时代的关系不大。之所以当代人会这么认为，是因为大多数人相较于不熟悉的历史更了解自己当下生活的年代。一旦自己所处的社会没有达到自己的预期，往往更愿意相信以前的年代比现在更好，人也更单纯。现在网络上很多人都在追捧民国时代，认为那个年代更加自由与开明。这是因为他们看到的都是民国精英贵族的事迹，认为自己如果生活在那个年代会同样的潇洒与自由，但是如果你深入了解了民国普通老百姓的生活你就不会这么认为了，毕竟你我都是属于普通阶层。</p><span id="more"></span><p>我觉得造成这种现象的原因至少包含了两个原因：一是大多数人缺乏辩证思想，往往会选择自己那些与自己意愿相符的事物来构成对某一件事情的认知，从而容易忽略其他的客观事实；其次是信息的不对称，如果对一件事情没有足够的深入了解是不可能接近真相的，我一直相信真相永远是掌握在少数人手里。</p><p>记得心理学上有一个著名的“棉花糖实验”：研究者给幼儿园小朋友一颗棉花糖，并且说你可以现在就吃掉它，但如果你等上15分钟都不吃，就会得到第二颗棉花糖。根据后续跟踪，得到第二颗棉花糖的孩子在未来更加成功。这项研究发表在1990年，当时学者认为，忍耐不吃糖的小孩具备更强的意志力，能为了长远利益放弃暂时的欢愉，这种“延迟满足能力”正是他们成为人生赢家的原因。然而，研究者忽略了一个很重要的因素：小孩子的家庭背景。事情的真相是那些推迟吃掉棉花糖的小孩子几乎都是来自富裕家庭，棉花糖对于他们来说压根没有什么的诱惑力，日常生活中随时可以获得。而那些没有经受住诱惑的小孩子基本上是来自于经济条件较差的家庭，棉花糖对于他们来说是稀缺资源，因此也就很具有诱惑力。</p><p>即便网络再发达，信息不对称还是会一直存在的。网络的出现只是帮助我们减缓信息不对称带来认知偏差。更何况人的言论都是带有倾向性的，说话的人的目的就是让听者认同自己的观点。因此，面对网络上海量的信息时，一定要学会思考，并尽量用辩证的态度去质疑和思考问题。</p><p>最后想起一句话，历史是任人打扮的姑娘。因此，有些历史的真相也许是我们永远都不会知道的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;都说现在的人越来越浮躁，愿意思考的人越来越少，导致整个社会都显得浮躁不安。我觉得其实我们一直以来都是这样的，与这个时代的关系不大。之所以当代人会这么认为，是因为大多数人相较于不熟悉的历史更了解自己当下生活的年代。一旦自己所处的社会没有达到自己的预期，往往更愿意相信以前的年代比现在更好，人也更单纯。现在网络上很多人都在追捧民国时代，认为那个年代更加自由与开明。这是因为他们看到的都是民国精英贵族的事迹，认为自己如果生活在那个年代会同样的潇洒与自由，但是如果你深入了解了民国普通老百姓的生活你就不会这么认为了，毕竟你我都是属于普通阶层。&lt;/p&gt;</summary>
    
    
    
    <category term="随想" scheme="http://naivertc.top/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款24：区分万能引用和右值引用</title>
    <link href="http://naivertc.top/2019/05/18/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE24/"/>
    <id>http://naivertc.top/2019/05/18/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE24/</id>
    <published>2019-05-17T23:00:07.000Z</published>
    <updated>2022-03-20T13:34:12.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>万能引用和右值引用都用”T&amp;&amp;“表示。</p><ul><li><p>万能引用</p><p>  所谓万能引用，即它既可以绑定左值，又可以绑定右值。一般用于表示型别推导的结果。</p></li><li><p>右值引用</p><p>  右值引用，顾名思义就是只能绑定到右值，它的主要作用是作为可移动对象的标识。</p></li></ul><span id="more"></span><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ul><li><p>万能引用</p><p>  万能引用有两种最常见的场景，这两种场景都涉及型别推导，它们分别是：</p><ul><li><p>模板函数的形参</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">// param是个万能引用</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(w);  <span class="comment">// param的型别是左值引用，即Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(w));  <span class="comment">// param的型别是右值引用，即Widget&amp;&amp;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>用于auto声明</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;  <span class="comment">// w1是个左值引用，即Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = std::<span class="built_in">move</span>(w);  <span class="comment">// w2是个右值引用，即Widget&amp;&amp;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>   万能引用首先是一个引用，所以初始化是必须的，且初始化的对象决定了它代表的是左值还是右值引用。</p><p>  几个要点：</p><ul><li><p>万能引用的声明形式必须是”T&amp;&amp;“，且型别推导必须是涉及param本身：</p><ul><li><p>模板函数的形参并不一定涉及型别推导</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">// param是个右值引用，</span></span><br><span class="line">   <span class="comment">// 因为型别已确定是std::vector&lt;T&gt;&amp;&amp;，</span></span><br><span class="line"> <span class="comment">// 而非T&amp;&amp;</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">f</span>(v);             <span class="comment">// 编译错误！不能给一个右值引用绑定一个左值</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(v));  <span class="comment">// 编译通过</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>位于模板内并不能保证涉及型别推导</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector的类声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; param);  <span class="comment">// param是个右值引用，虽然形参的声明形式为”T&amp;&amp;“，</span></span><br><span class="line"><span class="comment">// 但是调用该函数并不涉及型别推导，</span></span><br><span class="line"><span class="comment">// 因为T的类型在创建vector时已确定。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args... args)</span></span>;  <span class="comment">// args是个万能引用</span></span><br><span class="line">  ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::vector&lt;Widget&gt; v;   <span class="comment">// 此时push_back的形参型别已确定为Widget,</span></span><br><span class="line"> <span class="comment">// 但是emplace_back的形参需要推导。</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>使用const修饰的”T&amp;&amp;”一定是右值引用</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;   <span class="comment">// param是个右值引用</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;万能引用和右值引用都用”T&amp;amp;&amp;amp;“表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;万能引用&lt;/p&gt;
&lt;p&gt;  所谓万能引用，即它既可以绑定左值，又可以绑定右值。一般用于表示型别推导的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;右值引用&lt;/p&gt;
&lt;p&gt;  右值引用，顾名思义就是只能绑定到右值，它的主要作用是作为可移动对象的标识。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款23：理解std::move和std::forward</title>
    <link href="http://naivertc.top/2019/05/13/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE23/"/>
    <id>http://naivertc.top/2019/05/13/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE23/</id>
    <published>2019-05-12T23:00:07.000Z</published>
    <updated>2022-03-20T13:34:23.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul><li><p>std::move</p><p>  std::move，即移动语义。它的设计初衷在于让编译器用一种低成本的移动操作替换昂贵的复制操作。与之相关的两个函数分别是移动构造函数和移动赋值运算符。</p><p>  此外，std::move使得创建一个只可移动不可复制的对象成为可能，比如std::unique_ptr、std::future和std::thread等。</p></li><li><p>std::forward</p><p>  std::forward，即完美转发。它的设计初衷是使对任何一个函数模板，都可以将当前函数所接受的实参原封不动地转发给其它函数，且目标函数接受到的实参与传入当前函数的实参完全相同，包括实参的左右值属性。</p></li><li><p>形参总是左值</p><p>  所谓左值，简单地说就是可寻址变量，而右值则是不可寻址的临时变量。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;  <span class="comment">// a是左值，3是右值</span></span><br><span class="line">a = a + <span class="number">1</span>;  <span class="comment">// 等号左边的a是右值，等号右边的a是右值</span></span><br><span class="line">  <span class="comment">// CPU取a的值存入临时变量，即寄存器，然后+1，再将寄存器的值赋值给a</span></span><br></pre></td></tr></tbody></table></figure><p>  实参既可以是左值，也可以是右值。而形参总是左值，原因在于形参是为了传递实参的值或指针或引用而出现的，因此必须是可被赋值的左值。即便形参的类别是右值引用，如下：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Widget&amp;&amp; w)</span></span>;  <span class="comment">// 形参w是一个左值</span></span><br></pre></td></tr></tbody></table></figure></li></ul><span id="more"></span><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ol><li><p>std::move</p><p> std::move本质上就是使用std::remove_reference_t将传入实参的引用属性移除（但不包括const属性，移除const属性需要使用std::remove_const_t），再将其强制转换成右值引用。以下是C++14中std::move的实现：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line"><span class="keyword">using</span> ReturnType = std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;; <span class="comment">// 即便param是一个左值引用，移除引用后变成左值类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);  <span class="comment">// 强制转换成右值引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> 鉴于std::move不会移除实参中的const属性，因此只能保证其返回值是一个右值，但是不能保证返回值的可移动能力。比如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> std::string&amp; s);   <span class="comment">// 复制构造函数</span></span><br><span class="line">  <span class="built_in">A</span>(std::string&amp;&amp; s);        <span class="comment">// 移动构造函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string a = <span class="string">"hello"</span>;  <span class="comment">// a是一个常量左值</span></span><br><span class="line">std::string b = <span class="string">"hello"</span>;  <span class="comment">// a是一个非常量左值</span></span><br><span class="line"><span class="built_in">A</span>(std::<span class="built_in">move</span>(a));  <span class="comment">// 调用复制构造函数</span></span><br><span class="line"><span class="built_in">A</span>(std::<span class="built_in">move</span>(b));  <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>std::forward</p><p> std::forward是一种有条件的强制型别转换：仅当传入的实参是一个右值时，才会执行右值型别的强制转换。</p><p> std::forward本质上就是转发实参的左右值属性。如果传入的实参是左值，那么转发之后仍是左值。如果传入的实参是右值，那么转发之后仍是右值。比如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lval)</span></span>;  <span class="comment">// 函数1，处理左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rval)</span></span>;  <span class="comment">// 函数2，处理右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>{</span><br><span class="line">..... <span class="comment">// add a log</span></span><br><span class="line">  <span class="built_in">process</span>(std::forward&lt;T&gt;(param));  <span class="comment">// param是一个形参，由于所有形参都是左值，理论上只会调用函数1。</span></span><br><span class="line"><span class="comment">// 解决机制：param所接收的实参的左右属性被编码进目标参数T中，</span></span><br><span class="line"><span class="comment">// 当param传递给std::forward后，std::forward再将编码的信息</span></span><br><span class="line"><span class="comment">// 解码，获取传入实参的左右属性。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="built_in">logAndProcess</span>(w);  <span class="comment">// 传入左值，调用函数1</span></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));  <span class="comment">// 传入右值，调用函数2</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>std::move实际上不会进行任何移，而std::forward实际上也不会进行任何转发。二者都是编译期的行为，在运行期不会有任何行为，即不会生成任何可执行代码。</p><ul><li><p>相同点</p><p>  二者本质上都仅是执行强制类别转换的函数模板。</p></li><li><p>不同点</p><p>  std::move是无条件地将实参强制转换成右值，而std::forward则是在满足特定条件下才执行同类别强制转换（即转发）。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;std::move&lt;/p&gt;
&lt;p&gt;  std::move，即移动语义。它的设计初衷在于让编译器用一种低成本的移动操作替换昂贵的复制操作。与之相关的两个函数分别是移动构造函数和移动赋值运算符。&lt;/p&gt;
&lt;p&gt;  此外，std::move使得创建一个只可移动不可复制的对象成为可能，比如std::unique_ptr、std::future和std::thread等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;std::forward&lt;/p&gt;
&lt;p&gt;  std::forward，即完美转发。它的设计初衷是使对任何一个函数模板，都可以将当前函数所接受的实参原封不动地转发给其它函数，且目标函数接受到的实参与传入当前函数的实参完全相同，包括实参的左右值属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;形参总是左值&lt;/p&gt;
&lt;p&gt;  所谓左值，简单地说就是可寻址变量，而右值则是不可寻址的临时变量。&lt;/p&gt;
  &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// a是左值，3是右值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = a + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// 等号左边的a是右值，等号右边的a是右值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					  &lt;span class=&quot;comment&quot;&gt;// CPU取a的值存入临时变量，即寄存器，然后+1，再将寄存器的值赋值给a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  实参既可以是左值，也可以是右值。而形参总是左值，原因在于形参是为了传递实参的值或指针或引用而出现的，因此必须是可被赋值的左值。即便形参的类别是右值引用，如下：&lt;/p&gt;
  &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Widget&amp;amp;&amp;amp; w)&lt;/span&gt;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// 形参w是一个左值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款18：使用std::unique_ptr管理专属的资源</title>
    <link href="http://naivertc.top/2019/05/07/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE18/"/>
    <id>http://naivertc.top/2019/05/07/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE18/</id>
    <published>2019-05-06T23:00:07.000Z</published>
    <updated>2022-03-20T13:33:46.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>std::unique_ptr是C++11用表达专属所有权的方式，一个非空的std::unique_ptr总是拥有其所指的资源。因此，std::unique_ptr不允许复制，即只能通过移动操作将所有权转移。</p><span id="more"></span><h3 id="三个优点"><a href="#三个优点" class="headerlink" title="三个优点"></a>三个优点</h3><p>使用std::unique_ptr相对于其他智能指针或裸指针而已，具有一下三个优点：</p><ul><li><p>防止内存泄漏</p><p>  std::unique_ptr内封装了一个原始指针，通过构造函数和析构函数实现对原始指针的内存管理。即在构造函数中通过new申请原始指针的内存，在析构函数中调用delete释放原始指针。</p><p>  因此，使用std::unique_ptr时不再需要担心内存泄漏。</p></li><li><p>快速小巧</p><p>  在默认情况下，即使用默认析构器，std::unique_ptr和裸指针占用的内存空间基本相同。</p><p>  由于std::unique_ptr重载了“→”和“*”运算符，所以可以像使用裸指针一样使用它。</p><p>  因此，std::unique_ptr几乎和裸指针一样，足够小且足够快。这就意味着在任何使用裸指针的场合都可以使用裸指针替代，包括内存和时钟周期紧张的场合。</p></li><li><p>可高效地转成std::shared_ptr</p><p>  std::unique_ptr可以方便且高速地转换成std::shared_ptr。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">CreateAWidget</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成std::shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;Widget&gt; sp = <span class="built_in">CreateAWidget</span>(); </span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="自定义析构器"><a href="#自定义析构器" class="headerlink" title="自定义析构器"></a>自定义析构器</h3><p>自定义析构器相较于使用默认析构器的好处在于：可以在原始指针释放之前做一些操作，比如添加日志等。</p><p>在使用默认析构器的前提下，std::unique_ptr和裸指针占用的内存大小基本相同。但是，如果std::unique_ptr使用自定义析构器，情况则有所不同。</p><p>自定义析构器的实现主要分以下三种类型：</p><ul><li><p>无捕获的lambda</p><p>  由于lambda在没有捕获变量的情况下可以直接转换成函数指针。因此，可使用无捕获的lambda来实现std::unique_ptr的析构器，其所占用内存大小与使用默认析构器一样，即不会增加内存。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> deletor = [](Widget* pWidget) {</span><br><span class="line"><span class="comment">// Make some logs.</span></span><br><span class="line"><span class="keyword">delete</span> pWidget;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(deletor)</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Widget(), deletor)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>函数指针</p><p>  std::unique_ptr使用函数指针来实现析构器时，其占用内存一般至少增加一个函数指针的大小。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletor</span><span class="params">(Widget* pWidget)</span> </span>{</span><br><span class="line"><span class="comment">// Make some logs.</span></span><br><span class="line"><span class="keyword">delete</span> pWidget;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">void</span><span class="params">(*)</span><span class="params">(Widget*)</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Widget(), deletor)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>函数对象</p><p>  如果一个类或结构体重载了“()”运算符，则称之为函数类。这个类的对象即为函数对象，该对象可以被当做普通函数进行调用。</p><p>  函数对象的优势：</p><ul><li>编译器可以内联执行函数对象的调用。</li><li>函数对象可以有自己的状态，在函数对象被多次调用时可共享状态。普通函数则只能使用全局变量来共享状态。</li><li>函数对象有自己特有的类型，而普通函数则无清晰的类型界限。因此，在使用模板函数时，可以通过传递类型函数来实例化相应的模板。</li></ul><p>  使用无状态的函数对象来说实现析构器，与使用无状态的lambda一样不会占用额外内存。因此，如果析构器是函数对象，其带来的内存变化与该函数对象中存储状态的数量成正比。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deletor</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Widget* pWidget)</span> </span>{</span><br><span class="line"><span class="comment">// Make some logs.</span></span><br><span class="line"><span class="keyword">delete</span> pWidget;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, Deletor&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Widget())</span></span>;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;std::unique_ptr是C++11用表达专属所有权的方式，一个非空的std::unique_ptr总是拥有其所指的资源。因此，std::unique_ptr不允许复制，即只能通过移动操作将所有权转移。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款17：理解特种成员函数的生成机制</title>
    <link href="http://naivertc.top/2019/05/05/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE17/"/>
    <id>http://naivertc.top/2019/05/05/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE17/</id>
    <published>2019-05-04T23:00:07.000Z</published>
    <updated>2022-03-20T13:33:42.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在C++的官方用语中，所谓特种成员函数是指那些C++编译器会自行生成的成员函数。这些函数仅在需要时才会生成，即某些代码使用了它们，但在类中并未显式声明。</p><span id="more"></span><p>C++11中有以下六种特种函数，其中前四种同属于C++98，后两种则是C++11新加入的成员：</p><ul><li><p>默认构造函数</p><p>  默认构造函数仅当类中没有声明任何构造函数时才会被生成。</p></li><li><p>析构函数</p><p>  除了析构函数其他的特种函数都一定是非虚的。当基类的析构函数是一个虚函数时，编译器为派生类生成的析构函数也是一个虚函数。</p><p>  C++11中析构函数默认为noexcept。</p></li><li><p>复制构造函数和复制赋值运算符</p><p>  两种复制操作是彼此独立的：即只显示地声明其中一个不会阻止编译器生成另外一个。</p><p>  NOTE：尽管在已存在其中一个复制操作或析构函数的前提下，编译器仍生成另外一个复制操作，但是这成为被废弃行为。因此建议遵守大三律原则。</p></li><li><p>移动构造函数和移动赋值运算符</p><p>  两种移动操作并非彼此独立：即显式地声明了其中一种会阻止编译器生成另外一个。理由在于：一旦显示地声明了其中一种移动操作，编译器会理解为你需要的移动操作实现与编译器默认生成的实现会存在差异，因此希望你自己实现另外一个以统一移动逻辑。</p><p>  NOTE：调用移动构造或移动赋值并不能保证移动操作真的会发生，更像是一种移动请求。对于不可移动的型别，比如C++98中遗留的型别，将通过其复制操作实现”移动“。</p></li></ul><h3 id="大三律指导原则"><a href="#大三律指导原则" class="headerlink" title="大三律指导原则"></a>大三律指导原则</h3><p>大三律是指：如果声明了复制构造函数、复制赋值运算符或析构函数中的任一个，就得同时声明两位两个。</p><p>理由：</p><p>如果有改写复制操作的需求或声明了析构函数，往往意味着该类需要执行某种资源管理。即：</p><ol><li>如果在一种复制操作中进行了任何资源管理，那么在另外一种复制操作也极有可能需要进行</li><li>该类的析构函数也极有可能会参与到资源管理中，比如内存释放操作等。</li></ol><p>推论：</p><p>如果用户声明了析构函数，那么复制操作就不应该被自动生成，因此他们的行为极可能出错。但可惜地是C++98未支持该推论，即显示声明析构不会阻止编译器生成复制操作。C++11出于兼容C++98的原因也未加以限制，否则会破坏太多的遗留代码。</p><p>但是由于移动操作是C++11新引入的函数，因此，基于该推论，C++11规定：只要显示地声明了析构函数，编译器便不再生成移动操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>复制操作和移动操作相互压抑，即显示地声明了任意一种复制操作都阻止编译器生成移动操作，反之亦然。</p></li><li><p>复制操作彼此相互独立，即声明其中一个复制操作不会阻止编译器生成另外一个。</p></li><li><p>移动操作相互抑制，即声明其中一个复制操作会阻止编译器生成另外一个。</p></li><li><p>编译器生成移动操作需要同时满足三个条件：</p><ul><li>该类未显示声明任何复制操作</li><li>该类未显示声明任何移动操作</li><li>该类未显示声明任何析构函数</li></ul></li><li><p>C++11中可使用”=default“要求编译器自动生成某个特种函数：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Widget</span>();  <span class="comment">// 用户定义的析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Widget</span>(Widget&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 使用编译器生成的移动函数</span></span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp;) = <span class="keyword">default</span>;  <span class="comment">// 使用编译器生成的移动赋值运算符</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>成员函数模板在任何情况下都不会阻止特种成员函数的生成。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;在C++的官方用语中，所谓特种成员函数是指那些C++编译器会自行生成的成员函数。这些函数仅在需要时才会生成，即某些代码使用了它们，但在类中并未显式声明。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款16：保证const成员函数的线程安全性</title>
    <link href="http://naivertc.top/2019/04/30/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE16/"/>
    <id>http://naivertc.top/2019/04/30/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE16/</id>
    <published>2019-04-29T23:00:07.000Z</published>
    <updated>2022-03-20T13:33:32.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>使用const修饰对象的成员函数的本意在于告诉调用者调用该函数不会修改对象的成员变量，即在其中只能对成员变量进行只读操作。</p><span id="more"></span><h3 id="确保线程安全"><a href="#确保线程安全" class="headerlink" title="确保线程安全"></a>确保线程安全</h3><p>由于在多线程环境下执行读操作是安全的，因此const成员函数被认为是线程安全的。</p><p>换言之，从调用者的角度来说调用一个const成员函数应该是线程安全的，但这只是一种字面上的约定，因为使用const修饰的成员函数并不能保证一定是线程安全。</p><p>比如可以在const成员函数中可对使用mutable修饰的成员变量进行写操作。如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CachedValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (cache_valid_) {</span><br><span class="line"><span class="keyword">return</span> counter_;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">        first_cache_ = <span class="literal">true</span>;  <span class="comment">// 编译错误！first_cache_被视为const对象</span></span><br><span class="line">cache_valid_ = <span class="literal">true</span>;  <span class="comment">// 编译通过，mutable修饰的成员变量可被修改</span></span><br><span class="line">cache_value_ = <span class="built_in">DoExpensiveComputaion</span>();  <span class="comment">// 同上</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> first_cache_{<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">bool</span> cache_valid_{<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> cache_value_{<span class="number">0</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="comment">/*----线程1-----*/</span></span><br><span class="line"><span class="type">int</span> cached_value = w.<span class="built_in">CachedValue</span>();  <span class="comment">// 可能出现data race，存在未定义行为</span></span><br><span class="line"><span class="comment">/*----线程2-----*/</span></span><br><span class="line"><span class="type">int</span> cached_value = w.<span class="built_in">CachedValue</span>();  <span class="comment">// 同上</span></span><br></pre></td></tr></tbody></table></figure><p>解决方案有两个，分别是：</p><ul><li><p>使用互斥量mutex</p><p>  如果需要同时修改多个成员变量，使用mutex更方便。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CachedValue</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;  <span class="comment">// 加上互斥量</span></span><br><span class="line"><span class="keyword">if</span> (cache_valid_) {</span><br><span class="line"><span class="keyword">return</span> counter_;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">cache_valid_ = <span class="literal">true</span>;  <span class="comment">// 编译通过，mutable修饰的成员变量可被修改</span></span><br><span class="line">cache_value_ = <span class="built_in">DoExpensiveComputaion</span>();  <span class="comment">// 同上</span></span><br><span class="line">}</span><br><span class="line">} <span class="comment">// 解除互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex mutex_;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">bool</span> cache_valid_{<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> cache_value_{<span class="number">0</span>};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>  NOTE：由于std::mutex是个只移型别（move-only type），将mutex加入Widget的副作用就是使Widget失去了可复制性，但仍可移动。</p></li><li><p>使用原子数据型别std::atomic</p><p>  如果修改的成员变量只有一个，使用std::atomic的开销更低（是否真的成本更低取决于硬件以及互斥量的实现）。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Counter</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">++counter_;  <span class="comment">// 带原子性的自增操作</span></span><br><span class="line">} <span class="comment">// 解除互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">mutable</span> std::atomic&lt;<span class="type">int</span>&gt; counter_{<span class="number">0</span>};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>  NOTE：与std::mutex一样，std::atomic也是只移型别。因此Widget也变成了只移动型别。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;使用const修饰对象的成员函数的本意在于告诉调用者调用该函数不会修改对象的成员变量，即在其中只能对成员变量进行只读操作。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款15：只要可能使用constexpr，就使用它</title>
    <link href="http://naivertc.top/2019/04/27/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE15/"/>
    <id>http://naivertc.top/2019/04/27/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE15/</id>
    <published>2019-04-26T23:00:07.000Z</published>
    <updated>2022-03-20T13:33:27.901Z</updated>
    
    <content type="html"><![CDATA[<p>constexpr是C++11引入的关键字，主要目的是为了解决const关键字的二义性，constexpr既可用于修饰对象，又可用于修饰函数。</p><span id="more"></span><ul><li><p>constexpr对象</p><p>  所谓const二义性是指const既用于表示变量的只读性，又常用于修饰常量。但是const并不能代表“常量”，它只是变量的一个修饰，告诉编译器这个变量只能被初始化但不能被直接修改（实际上可以通过堆栈溢出等方式修改）。因此这个变量的值，可以在运行时也可以在编译期指定。比如：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参array_size是一个只读变量，其值在运行期指定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> array_size)</span> </span>{</span><br><span class="line">std::array&lt;<span class="type">int</span>, array_size&gt; arr;  <span class="comment">// 编译错误！因为array_size的在编译期未知，即非编译器常量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 实参array_size是一个只读变量，其值在编译期指定，因此是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> array_size = <span class="number">5</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, array_size&gt; arr;  <span class="comment">// 编译通过，因为array_size的值编译期已知，即编译期常量。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  因此，const并不能保证对象是编译期已知，而constexpr可以保证其修饰的对象一定是编译期常量。如下所示：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;  <span class="comment">// 普通变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> array_size = sz;       <span class="comment">// 编译通过，array_size是sz的一个const副本</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> array_size2 = sz;  <span class="comment">// 编译错误！sz的值在编译期未知</span></span><br></pre></td></tr></tbody></table></figure><p>  简而言之，所有的constexpr对象都是const对象，而并非所有的const对象都是constexpr对象。</p><p>  因此，C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达只读语义的场景都使用 const，凡是要求编译期常量的语境中都使用 constexpr。</p></li><li><p>constexpr函数</p><p>  使用constexpr修饰函数的好处在于可以拓展函数的使用语境，即既可在编译期调用，又能在运行时调用。</p><ul><li><p>编译期</p><p>  如果constexpr函数调用的语境是在编译期，那么必须确保传入的实参都是编译期常量，且内部调用的函数只能是constexpr函数，否则编译失败。</p><p>  好处是程序运行更快，坏处是编译时间更长。</p></li><li><p>运行期</p><p>  如果constexpr函数调用的语境在运行时，那么其运行方式与普通函数无异。</p></li></ul><p>  由于constexpr函数必须在传入编译期常量时能返回编译期结果，它们的实现就必须加以限制。且C++11和C++14中的限制还有所差异：</p><ul><li><p>C++11的限制条件</p><ul><li>保证constexpr函数返回值和参数必须是字面值（即可在编译期决议的值），</li><li>只能有且只有一行return代码，通常使用三目运算符（替代if-else语句）或递归（替代循环语句）来扩展表达力。</li></ul></li><li><p>C++14的限制条件</p><p>  只要保证返回值和参数是字面值，函数体中可有多条语句，这样更为方便灵活。</p></li></ul><p>  注：在C++11中除void以外的所有内建型别都是字面值，而C++14中所有内建型别都是字面值，包括void。</p></li></ul><p>参考资料：</p><p><a href="https://www.jianshu.com/p/34a2a79ea947">C++11/14 constexpr 用法</a></p><p><a href="http://c.biancheng.net/view/7807.html">C++11 constexpr和const的区别详解</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;constexpr是C++11引入的关键字，主要目的是为了解决const关键字的二义性，constexpr既可用于修饰对象，又可用于修饰函数。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款8：表示空指针优先选用nullptr，而非0或NULL</title>
    <link href="http://naivertc.top/2019/04/24/%E6%9D%A1%E6%AC%BE8%EF%BC%9A%E8%A1%A8%E7%A4%BA%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8nullptr%EF%BC%8C%E8%80%8C%E9%9D%9E0%E6%88%96NULL/"/>
    <id>http://naivertc.top/2019/04/24/%E6%9D%A1%E6%AC%BE8%EF%BC%9A%E8%A1%A8%E7%A4%BA%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8nullptr%EF%BC%8C%E8%80%8C%E9%9D%9E0%E6%88%96NULL/</id>
    <published>2019-04-23T23:00:07.000Z</published>
    <updated>2022-03-20T13:35:29.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul><li><p>字面常量0的型别是int，而非指针。C++会在只能使用指针的语境中才勉强将其解释为空指针。</p></li><li><p>NULL是一个宏定义，而非指针。同样，C++会在只能使用指针的语境中才勉强将其解释为空指针。</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define NULL pointer value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL    0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span>  <span class="comment">/* __cplusplus */</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL    ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* NULL */</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p>nullptr是C++关键字，不具备整型型别。实际上，它也不具备指针型别，但是它可以隐式转换成任意指针型别，这也就是为什么nullptr可以用于初始化所有指针型别的原因。</p></li></ul><span id="more"></span><h3 id="使用nullptr可避免多义性"><a href="#使用nullptr可避免多义性" class="headerlink" title="使用nullptr可避免多义性"></a>使用nullptr可避免多义性</h3><p>由于字面量0和NULL本质上是一个整型，因此用它们表示空指针时会出现多义性，而使用nullptr可避免多义性。</p><ul><li><p>避免重载决议中的意外</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// Func的三个重载版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w.<span class="built_in">Func</span>(<span class="number">0</span>);        <span class="comment">// 调用的是Func(int)，而非F(void*)</span></span><br><span class="line">w.<span class="built_in">Func</span>(<span class="literal">NULL</span>);     <span class="comment">// 可能编译错误，但一般会调用的Func(int)，</span></span><br><span class="line">                  <span class="comment">// 而非F(void*)</span></span><br><span class="line">w.<span class="built_in">Func</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用的是Func(void*)</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>提升代码清晰度</p><p>  比如涉及auto型别推导时：</p>  <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">FindRecord</span>(<span class="comment">/* 实参 */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) {  <span class="comment">// 很难判断result的型别是整型还是指针</span></span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">FindRecord</span>(<span class="comment">/* 实参 */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>) { <span class="comment">// 一目了然</span></span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>相对于0NULL，优先选用nullptr</li><li>使用nullptr可避免在整型和指针型别之间出现重载意外</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字面常量0的型别是int，而非指针。C++会在只能使用指针的语境中才勉强将其解释为空指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NULL是一个宏定义，而非指针。同样，C++会在只能使用指针的语境中才勉强将其解释为空指针。&lt;/p&gt;
  &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Define NULL pointer value */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; NULL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifdef&lt;/span&gt; __cplusplus&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NULL    0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;/* __cplusplus */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NULL    ((void *)0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;/* __cplusplus */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;/* NULL */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nullptr是C++关键字，不具备整型型别。实际上，它也不具备指针型别，但是它可以隐式转换成任意指针型别，这也就是为什么nullptr可以用于初始化所有指针型别的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款7：在创建对象时注意区分()和 {}</title>
    <link href="http://naivertc.top/2019/04/18/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE7/"/>
    <id>http://naivertc.top/2019/04/18/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE7/</id>
    <published>2019-04-17T23:00:07.000Z</published>
    <updated>2022-03-20T13:07:00.407Z</updated>
    
    <content type="html"><![CDATA[<p>在C++11中有三种指定初始化值得方式，分别是使用小括号()、等号=和大括号{}。其中，前两种在C++98中就已经存在，而使用大括号的初始化语法则是C++11引入的。</p><span id="more"></span><p>这三种初始化语法只有大括号适用于所有初始化场景，比如：</p><ol><li><p>初始化非静态成员变量</p><p> 可使用等号=或大括号{}，不能使用小括号()</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x{ <span class="number">0</span> };  <span class="comment">// 可行</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;   <span class="comment">// 可行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 不可行！</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化不可复制对象</p><p> 可使用小括号()或大括号{}，不能使用等号=</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a_1{<span class="number">0</span>};    <span class="comment">// 可行</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">a_2</span><span class="params">(<span class="number">0</span>)</span></span>;    <span class="comment">// 可行</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a_1 = <span class="number">0</span>;   <span class="comment">// 不可行，无赋值函数</span></span><br></pre></td></tr></tbody></table></figure></li></ol><p>大括号初始化语法的三个独有的特性：</p><ol><li><p>禁止隐式窄化类别转换（narrowing conversion）</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x, y ,z;</span><br><span class="line"><span class="type">int</span> sum1{x + y + z};  <span class="comment">// 报错！double之和可能无法用int表达，存在窄化转换</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(x + y + z)</span></span>;  <span class="comment">// 可行，double之和被截断（窄化）为int</span></span><br><span class="line"><span class="type">int</span> sum3 = x + y + z; <span class="comment">// 可行，同上</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>对C++解析语法免疫</p><blockquote><p>C++规定：任何能够解析为声明的语句都要解析为声明。</p></blockquote><p> 因此，当使用默认构造方式来创建对象时会被解析为一个函数声明，如下：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 正确，调用Widget的带形参的构造函数，w1被解析为对象</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;    <span class="comment">// 错误！本意是想调用Widget的默认构造函数创建w2对象，</span></span><br><span class="line"><span class="comment">// 结果w2被解析为函数声明，且返回一个Widget对象</span></span><br><span class="line">Widget w3{}     <span class="comment">// 正确，由于函数声明不能使用大括号来指定形参列表，</span></span><br><span class="line"><span class="comment">// 所以w3不会被解析为函数声明，而是调用默认构造函数创建w3对象</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>优先选择使用std::initializer_list模板为形参的构造函数，甚至劫持复制或移动构造函数</p><p> 根据std::initializer_list模板中的型别，具体可分四种情况：</p><ol><li><p>构造函数的参数可被隐式强制转换成std::initializer_list模板中的型别，如下int和bool都可以强制转换成long double。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">bool</span> b);   <span class="comment">// 第一个构造函数</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">int</span> i, <span class="type">double</span> d);   <span class="comment">// 第二个构造函数</span></span><br><span class="line">  <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; i); <span class="comment">// 第三个构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 强制转换成float</span></span><br><span class="line">  ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;  <span class="comment">// 调用第一个构造函数</span></span><br><span class="line">Widget w2{<span class="number">10</span>, <span class="literal">true</span>};  <span class="comment">// 调用第三个构造函数，10和true均被强制转换成long double</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;   <span class="comment">// 调用第二个构造函数</span></span><br><span class="line">Widget w4{<span class="number">10</span>, <span class="number">5.0</span>};   <span class="comment">// 调用第三个构造函数，10和5.0均被强制转换成long double</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w5</span><span class="params">(w4)</span></span>;  <span class="comment">// 调用复制构造函数</span></span><br><span class="line">Widget w6{w4};  <span class="comment">// 调用第三个构造函数，w4的返回值被强制转换成float，</span></span><br><span class="line">                <span class="comment">// 随后又被强制转换成long double</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w7</span><span class="params">(std::move(w4))</span></span>;  <span class="comment">// 调用移动构造函数</span></span><br><span class="line">Widget w8{std::<span class="built_in">move</span>(w4)};  <span class="comment">// 调用第三个构造函数，同w6</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>构造函数的参数可被隐式窄化转换成std::initializer_list模板中的型别</p><p> 比如上列中的std::initializer_list模板中的型别是bool，即std::initializer_list<bool>。由于int或double转换成bool属于窄化转换，而窄化转换在大括号初始化中是被禁止的，因此会编译报错。</bool></p></li><li><p>构造函数的参数无法隐式强制转换成std::initializer_list模板中的型别</p><p> 比如上列中的std::initializer_list模板中的型别是std::string，即std::initializer_list<a href="std::string">std::string</a>。由于int或double无法被隐式转换成std::string，因此编译器会退而求其次去找其他的构造函数。</p></li><li><p>空大括号</p><p> 空大括号{}表示的语义是”没有实参“，而非”空的std::initializer_list“，因此使用空大括号调用的是默认构造函数。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">Widget w2{};  <span class="comment">// 同上，调用默认构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>;  <span class="comment">// 被解析为函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w4</span><span class="params">({})</span>  <span class="comment">// {}作为实参表示一个空的std::initializer_list，</span></span></span><br><span class="line"><span class="function">   <span class="comment">// 因此调用std::initializer_list为形参的构造函数</span></span></span><br><span class="line"><span class="function">Widget w5</span>{{}}  <span class="comment">// 同上</span></span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在C++11中有三种指定初始化值得方式，分别是使用小括号()、等号=和大括号{}。其中，前两种在C++98中就已经存在，而使用大括号的初始化语法则是C++11引入的。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Modern C++》条款1：理解模板型别推导</title>
    <link href="http://naivertc.top/2019/04/10/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE1/"/>
    <id>http://naivertc.top/2019/04/10/%E3%80%8AEffective%20Modern%20C++%E3%80%8B%E6%9D%A1%E6%AC%BE1/</id>
    <published>2019-04-09T23:00:07.000Z</published>
    <updated>2022-03-20T14:13:09.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>一个函数模板的声明和调用大致形如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;   <span class="comment">// ParamType表示形参型别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">f</span>(expr);  <span class="comment">// expr表示调用时传入的实参</span></span><br></pre></td></tr></tbody></table></figure><p>模板型别推导的结果，不仅依赖于传入实参的型别，还依赖函数形参的型别。</p><span id="more"></span><p>具体可分三种情况：</p><ol><li><p>函数形参ParamType是一个指针或普通引用（非万能引用）</p><ol><li><p>ParamType是引用</p><ol><li><p>ParamType是一个普通引用，传入实参的引用性会被忽略，但保留其常量性。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;     <span class="comment">// param是个普通引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 型别推导</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;         <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;   <span class="comment">// cx的型别是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;  <span class="comment">// rx的型别是const int的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推导过程：保留实参的常量性（constness），忽略实参的引用性（reference-ness）</span></span><br><span class="line"><span class="built_in">f</span>(x);     <span class="comment">// T的型别是int, param的型别是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);    <span class="comment">// T的型别是const int, param的型别是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);    <span class="comment">// T的型别是const int, param的型别是const int&amp;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>ParamType是一个const引用，传入实参的引用和常量性都会被忽略。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;     <span class="comment">// param是个const引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;         <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;   <span class="comment">// cx的型别是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;  <span class="comment">// rx的型别是const int的&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推导过程：传入实参的常量性（constness）和引用性（reference-ness）都会被忽略</span></span><br><span class="line"><span class="built_in">f</span>(x);     <span class="comment">// T的型别是int, param的型别是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);    <span class="comment">// T的型别是int, param的型别是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);    <span class="comment">// T的型别是int, param的型别是const int&amp;</span></span><br></pre></td></tr></tbody></table></figure><p> 因为ParamType已经是一个const类型，因此T的类型推导没必要再包含const。</p></li><li><p>传入实参是一个数组或函数，ParamType会被推导成数组引用</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;     <span class="comment">// param是个普通引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">"iceberg"</span>;   <span class="comment">// name的型别是const char[7]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);   <span class="comment">// T的型别是数组本身，即const char[7]，</span></span><br><span class="line">   <span class="comment">// param的型别数组引用，是const char(&amp;)[7]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;  <span class="comment">// someFunc是个函数，其型别是void(int, double)</span></span><br><span class="line"><span class="built_in">f</span>(someFunc);                 <span class="comment">// T的型别是函数本身，即void(int, double)，</span></span><br><span class="line"> <span class="comment">// param的型别是函数引用，即void(&amp;)(int, double)</span></span><br></pre></td></tr></tbody></table></figure><p> 扩展：可用于在编译期计算数组大小</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以编译器常量形式返回数组的大小</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="type">array_t</span> <span class="title">arraySize</span><span class="params">(T (&amp;)[])</span> <span class="keyword">noexcept</span> </span>{</span><br><span class="line"><span class="keyword">return</span> N;  <span class="comment">// 返回数组大小</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> keys = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span> , <span class="number">11</span>, <span class="number">22</span>, <span class="number">43</span>};</span><br><span class="line">std::array&lt;<span class="type">int</span>, arraySize(keys)&gt; mapped;  <span class="comment">// 编译期就可以确定mapped数组的大小</span></span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>ParamType是指针</p><ol><li><p>ParamType是一个普通指针，传入实参的常量性会被保留</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;      <span class="comment">// param是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;           <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">int</span>* px1 = &amp;x;        <span class="comment">// px1的型别是int*</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px2 = &amp;x;  <span class="comment">// px2的型别是const in*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推导过程：传入实参的常量性会被保留</span></span><br><span class="line"><span class="built_in">f</span>(x);      <span class="comment">// T的型别是int，param的型别是int*</span></span><br><span class="line"><span class="built_in">f</span>(px1);    <span class="comment">// T的型别是int，param的型别是int*</span></span><br><span class="line"><span class="built_in">f</span>(px2);    <span class="comment">// T的型别是const int，param的型别是const int*</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>ParamType是一直const指针，传入实参的常量性会被忽略</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T* param)</span></span>;      <span class="comment">// param是指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;           <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">int</span>* px1 = &amp;x;        <span class="comment">// px1的型别是int*</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* px2 = &amp;x;  <span class="comment">// px2的型别是const in*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推导过程：传入实参的常量性会被忽略</span></span><br><span class="line"><span class="built_in">f</span>(x);      <span class="comment">// T的型别是int，param的型别是const int*</span></span><br><span class="line"><span class="built_in">f</span>(px1);    <span class="comment">// T的型别是int，param的型别是const int*</span></span><br><span class="line"><span class="built_in">f</span>(px2);    <span class="comment">// T的型别是int，param的型别是const int*</span></span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol></li><li><p>函数形参ParamType是万能引用</p><p> 万能引用既可以绑定左值，也可以绑定右值。因此，当ParamTyep是万能引用时，传入实参即可以是左值，也可以是右值。</p><ol><li><p>传入实参是左值，T和ParamType都会被推导为左值引用</p><p> NOTE：这是在所有的模板型别推导中， T被推导为引用型别的唯一情形。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;      <span class="comment">// param是万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;         <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;   <span class="comment">// cx的型别是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx = x;  <span class="comment">// rx的型别是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);               <span class="comment">// x是个左值，T和Param的型别均为int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);              <span class="comment">// cx是个左值，T和Param的型别均为const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);              <span class="comment">// rx是个左值，T和Param的型别均为const int&amp;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>传入实参是右值，则使用情况1中的规则。</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;      <span class="comment">// param是万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;          <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;    <span class="comment">// cx的型别是const int</span></span><br><span class="line"><span class="type">int</span>&amp; rx = x;         <span class="comment">// rx的型别是int&amp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; crx = x;  <span class="comment">// crx的型别是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);               <span class="comment">// 27是个右值，T的型别是int，Param的型是int&amp;&amp;</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(x));     <span class="comment">// T的型别是int，Param的型是int&amp;&amp;</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(cx));    <span class="comment">// 编译错误！右值引用不能绑定到const型别</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(rx));    <span class="comment">// T的型别是int，Param的型别int&amp;&amp;</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(crx));   <span class="comment">// 编译错误！右值引用不能绑定到const型别</span></span><br></pre></td></tr></tbody></table></figure></li></ol></li><li><p>函数形参ParamType是既不是指针，也非引用，即值传递</p><ol><li><p>由于是值传递，因此不管传入实参是左值还是右值，其的引用性和常量性都会被忽略</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;      </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;         <span class="comment">// x的型别是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;   <span class="comment">// cx的型别是const int</span></span><br><span class="line"><span class="type">int</span>&amp; rx = x;  <span class="comment">// rx的型别是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);               <span class="comment">// x是个左值，T和Param的型别均为int</span></span><br><span class="line"><span class="built_in">f</span>(cx);              <span class="comment">// cx是个左值，T和Param的型别均为int</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(rx));   <span class="comment">// 传入右值，T和Param的型别均为int</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>当传入实参是一个数组，数组会退化成首元素指针</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;      </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">"iceberg"</span>;   <span class="comment">// name的型别是const char[7]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);    <span class="comment">// T和Param的型别均为const char*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;  <span class="comment">// someFunc是个函数，其型别是void(int, double)</span></span><br><span class="line"><span class="built_in">f</span>(someFunc)                  <span class="comment">// T的型别是函数本身，即void(int, double)，</span></span><br><span class="line"> <span class="comment">//  param的型别是函数指针void(*)(int, double)</span></span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;一个函数模板的声明和调用大致形如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ParamType param)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// ParamType表示形参型别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;f&lt;/span&gt;(expr);  &lt;span class=&quot;comment&quot;&gt;// expr表示调用时传入的实参&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;模板型别推导的结果，不仅依赖于传入实参的型别，还依赖函数形参的型别。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="http://naivertc.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C++" scheme="http://naivertc.top/tags/C/"/>
    
  </entry>
  
</feed>
