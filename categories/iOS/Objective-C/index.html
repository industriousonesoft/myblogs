<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Objective-C - MarkCao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MarkCao"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MarkCao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MarkCao"><meta property="og:url" content="http://naivertc.top/"><meta property="og:site_name" content="MarkCao"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://naivertc.top/img/og_image.png"><meta property="article:author" content="Mark Cao"><meta property="article:tag" content="WebRTC, C++, iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naivertc.top"},"headline":"MarkCao","image":["http://naivertc.top/img/og_image.png"],"author":{"@type":"Person","name":"Mark Cao"},"publisher":{"@type":"Organization","name":"MarkCao","logo":{"@type":"ImageObject","url":"http://naivertc.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="MarkCao" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li><a href="/categories/iOS/">iOS</a></li><li class="is-active"><a href="#" aria-current="page">Objective-C</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-06-11T14:28:07.000Z" title="6/11/2017, 10:28:07 PM">2017-06-11</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">28 minutes read (About 4143 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/11/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">剖析@synchronizd底层实现原理</a></h1><div class="content"><p>@synchronizd是Objective-C中的一个语法糖，用于给某个对象加锁，因为使用起来简单方便，所以使用频率很高。然而，滥用@synchronizd很容易导致代码效率低下。本篇博客旨在结合@synchronizd底层实现源码并剖析其实现原理，这样可以更好的让我们在适合的情景使用@synchronizd。</p>
<p>@synchronizd本质上是一个编译器标识符，在Objective-C层面看不其任何信息。因此可以通过clang -rewrite-objc指令来获得@synchronizd的C++实现代码。示例代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"Iceberg"</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) {</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello,world! =&gt; %@"</span> , obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>{</span><br><span class="line">    </span><br><span class="line">    NSString *obj = (NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_0;</span><br><span class="line">    </span><br><span class="line">    {</span><br><span class="line">        id _rethrow = <span class="number">0</span>;</span><br><span class="line">        id _sync_obj = (id)obj;</span><br><span class="line">        <span class="built_in">objc_sync_enter</span>(_sync_obj);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">	            <span class="keyword">struct</span> <span class="title class_">_SYNC_EXIT</span> {</span><br><span class="line">	                _SYNC_EXIT(id arg) : <span class="built_in">sync_exit</span>(arg) {}</span><br><span class="line">	                ~_SYNC_EXIT() {</span><br><span class="line">	                    <span class="built_in">objc_sync_exit</span>(sync_exit);</span><br><span class="line">	                }</span><br><span class="line">	                id sync_exit;</span><br><span class="line">	            } _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_1 , obj);</span><br><span class="line">                </span><br><span class="line">            } <span class="built_in">catch</span> (id e) {</span><br><span class="line">                _rethrow = e;</span><br><span class="line">            }</span><br><span class="line">        </span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_FIN</span> {</span><br><span class="line">                _FIN(id reth) : <span class="built_in">rethrow</span>(reth) {}</span><br><span class="line">                ~_FIN() {</span><br><span class="line">                    <span class="keyword">if</span> (rethrow)</span><br><span class="line">                        <span class="built_in">objc_exception_throw</span>(rethrow);</span><br><span class="line">                }</span><br><span class="line">                id rethrow;</span><br><span class="line">            } _fin_force_rethow(_rethrow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过分析C++代码可以看到@sychronized的实现主要依赖于两个函数：objc_sync_enter和objc_sync_exit。此外还有try{}catch{}语句用于捕捉@sychronized{}语法块中代码执行过程中出现的异常。</p>
<p>我们发现objc_sync_enter函数是在try语句之前调用，参数为需要加锁的对象。因为C++中没有try{}catch{}finally{}语句，所以不能在finally{}调用objc_sync_exit函数。因此objc_sync_exit是在_SYNC_EXIT结构体中的析构函数中调用，参数同样是当前加锁的对象。这个设计很巧妙，原因在_SYNC_EXIT结构体类型的_sync_exit是一个局部变量，生命周期为try{}语句块，其中包含了@sychronized{}代码需要执行的代码，在代码完成后，_sync_exit局部变量出栈释放，随即调用其析构函数，进而调用objc_sync_exit函数。即使try{}语句块中的代码执行过程中出现异常，跳转到catch{}语句，局部变量_sync_exit同样会被释放，完美的模拟了finally的功能。</p>
<p>接下来，在<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm">苹果公开的源代码文件objc-sync.mm</a>中找到objc_sync_enter和objc_sync_exit这两个函数的实现，一窥其中的奥秘。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncData</span> {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SyncData</span>* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">//当前加锁的对象</span></span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">//使用对object加锁的线程个数</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex; <span class="comment">//递归互斥锁</span></span><br><span class="line">} SyncData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockCount;  <span class="comment">//表示当前线程对object对象加锁次数</span></span><br><span class="line">} SyncCacheItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncCache</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocated;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> used;</span><br><span class="line">    SyncCacheItem list[<span class="number">0</span>];</span><br><span class="line">} SyncCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SyncList</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SyncList</span>() : <span class="built_in">data</span>(nil) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码是一些相关的数据结构，下面分别进行介绍：</p>
<p>SyncData结构体中有四个成员变量，其中object指针变量指向当前加锁对象，threadCount表示对object加锁的线程个数，mutex是一个递归互斥锁，意味着可以对object进行多次加锁，其具体作用后面会提到。</p>
<p>SyncCacheItem结构体中有两个成员变量，其中data是SyncData结构体类型的指针，lockCount表示当前线程对当前结构体对象加锁次数，其实就是对加锁对象object的加锁次数。我们可以看到SyncCacheItem与SyncData是一对一关系，SyncCacheItem只是对SyncData进行了再次封装以便于缓存，具体使用见后文。</p>
<p>SyncCache结构体中有三个成员变量，其中维护了一个SyncCacheItem类型的数组，allocated和used则分别表示当前分配的SyncCacheItem数组中的总个数和已经使用的个数。这个结构体与线程是一对一的关系，用于存储当前线程已加锁对象对应的SyncCacheItem结构体，因为一个线程可以对同一个对象多次加锁，所以通过引入缓存SyncCache可以提高效率，具体使用见后文。</p>
<p>SyncList结构体中有两个成员变量和一个构造函数，其中data是SyncData结构体类型的指针，lock是一个自旋锁。</p>
<p>sDataLists是一个全局StripedMap哈希列表，其中value为SyncList对象，key为加锁对象object指针进行hash后的值。StripedMap是一个C++模板类，其实现代码如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> { CacheLineSize = <span class="number">64</span> };</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_EMBEDDED</span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">8</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">64</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> {</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) { </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() {</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">assert</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，由于自己对C++模板类不熟悉，所以只能看个大概。其中有两个值得注意的地方，其中StripeCount表示哈希数组的长度，如果是嵌入式系统值为8，否则值为64，也就意味着哈希数组最大长度为64；函数indexForPointer为散列函数，算法不难，但是很巧妙，值得学习。</p>
<p>下面开始分析相关的函数实现，首先找到@sychronized直接调用的两个函数：objc_sync_enter和objc_sync_exit，代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, ACQUIRE);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) {</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">objc_sync_nil</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) {</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.<span class="built_in">tryUnlock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!okay) {</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不难发现，上述代码都调用了id2data函数来获取一个与obj对应的SyncData对象，然后使用该对象中的递归互斥锁分别进行加锁与解锁。至此@sychronized的大致实现过程已经很清晰了，本质上是为一个对象分配一把递归互斥锁，可以也是为什么可以反复使用@sychronized对同一个对象进行加锁的原因。那么@sychronized是如果管理这把互斥锁，以及是如何处理多个线程对同一个对象进行多次加锁的情况？很明显，一切奥秘都藏在id2data函数中，其代码如下所示：</p>
<ul>
<li>注：为了描述方便，下面将id2data函数的形参object描述为同步对象obejct。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//从全局哈希表sDataLists中获取object对应的SyncList对象</span></span><br><span class="line">	<span class="comment">//lockp指针指向SyncList对象中自旋锁</span></span><br><span class="line">	<span class="comment">//listp指向一条SyncData链表，因为C++ STL中的哈希表处理地址冲突的方法是链地址法</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lockp = &amp;<span class="built_in">LOCK_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData **listp = &amp;<span class="built_in">LIST_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class="line">	<span class="comment">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class="line">	<span class="comment">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="comment">//用于标识当前线程的是否已使用fastCache</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    <span class="comment">//直接调用tls_get_direct函数获取SyncData对象</span></span><br><span class="line">    SyncData *data = (SyncData *)<span class="built_in">tls_get_direct</span>(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) {</span><br><span class="line">    	 <span class="comment">//标识fastCache已被使用</span></span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line">		 <span class="comment">//比较fastCache中的SyncData对象中的object与当前同步对象object是否为同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) {</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">   			  <span class="comment">//fastCache中的对象恰好是当前同步对象object，则后续处理直接使用fastCache中SyncData对象</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            <span class="comment">//获取当前线程对应当前SyncData对象已经加锁的次数</span></span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)<span class="built_in">tls_get_direct</span>(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data fastcache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">			  <span class="comment">//判断当前操作的加锁还是解锁</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: {</span><br><span class="line">                <span class="comment">//加锁一次</span></span><br><span class="line">                lockCount++;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                <span class="comment">//解锁一次</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="comment">//已加锁次数为0，表示当前线程对当前同步对象object达到锁平衡，因此不需要再持有当前同步对象。</span></span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    <span class="comment">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class="line">                    <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="comment">//此函数为原子操作函数，用于对32位的threadCount整形变量执行减一操作，且确保线程安全。因为可能存在同一时间多个线程对一个threadCount进行加减操作，避免出现多线程竞争。不同于lockCount，threadCount是多个线程共享的一个变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能。而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁。</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">//这是第二章缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class="line">    <span class="comment">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class="line">    SyncCache *cache = <span class="built_in">fetch_cache</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) {</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) {</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="comment">//当前同步对象object已存在的SyncCache中</span></span><br><span class="line">            <span class="comment">//获取对应的SyncData对象</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//后续操作同fastCache一样，参考fastCache的注释</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">			  </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class="line">    <span class="comment">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class="line">    lockp-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) {</span><br><span class="line">        	  <span class="comment">//哈希表中存在对应的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) {</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                <span class="comment">//此函数为原子操作函数，确保线程安全，用于对32位的threadCount整形变量执行加一操作，表示占用当前同步对象的线程数加1。</span></span><br><span class="line">                <span class="built_in">OSAtomicIncrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//用于标记一个空闲的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="comment">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="comment">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) {</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="comment">//关联当前同步对象</span></span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            <span class="comment">//重置占用线程为1</span></span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到这一步说明需要新建一个SyncData对象</span></span><br><span class="line">    result = (SyncData*)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(SyncData), <span class="number">1</span>);</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建递归互斥锁</span></span><br><span class="line">    <span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="built_in">recursive_mutex_t</span>();</span><br><span class="line">    <span class="comment">//以“入栈”的方式加入当前同步对象object对应的SyncData链表</span></span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line"> 	 <span class="comment">//对全局哈希表的操作结束，解锁</span></span><br><span class="line">    lockp-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="comment">//只有ACQUIRE才需要新建SyncData对象</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) {</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//fastCache缓存模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) {</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            <span class="comment">//直接缓存新建的SyncData对象</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            <span class="comment">//设置加锁次数为1</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		 <span class="comment">//SyncCache缓存模式，则直接加入SyncCacheItem数组中</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = <span class="built_in">fetch_cache</span>(YES);</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上述代码的注释，id2data函数的功能已经大致清晰。id2data函数主要是用于管理同步对象object与线程之间的关联。不论是ACQUIRE、RELEASE还是CHECK操作，都会先从当前线程的缓存中去获取对应的SyncData对象。如果当前线程的缓存区中不存在，那么再从全局的哈希数组中查找，查看其它线程是否已经占用过当前同步对象object。如果还是没有，那么就新建一个与之对应的SyncData对象，分别加入全局哈希表和当前线程缓存中。</p>
<p>至此，@synchronized的实现原理已经剖析结束，其有一个最大的特点是：不论是多个线性同一时间内对一个对象进行多次同步还是一个线程对同一个对象同步多次，一个对象只分配一把递归互斥锁。也就意味着对同一个对象而言，当执行某一次同步操作时，其他线程或同一线程的其他同步操作都会被阻塞，不言而喻，这种加锁方式的效率是很低的。</p>
<p>下面代码展示了@synchronized经典的使用案例之一：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject1:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember1 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject2:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember2 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject3:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember3 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码，调用其中一个设置函数时，另外两个成员变量的设置函数在同一时间被调用都会被阻塞。这里@synchronized同步的代码很简单，所以不会效率差别不大。如果是同步的代码需要执行较长的时间，且被多个线程并发调用，那么效率变得很低。如果不清楚@synchronized的实现原理，可能很难排查出来导致效率低下的问题所在。我建议使用GCD取代@synchronized实现同步功能，GCD不仅是线程安全，且其由底层实现，效率会好很多。我们发生@synchronized的底层实现有捕获异常的功能，因此适合在需要确保发生错误时代码不会死锁，而是抛出异常时使用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-08-08T14:25:07.000Z" title="8/8/2016, 10:25:07 PM">2016-08-08</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">38 minutes read (About 5693 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/08/08/%E6%8F%AD%E7%A7%98dispatch_once/">揭秘dispatch_once的内部实现</a></h1><div class="content"><p>这是一篇译文，原文<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html">Secrets of dispatch</a>的作者是Mike Ash大神。在拜读这篇文章之后，颇有收获，不得不感叹Mike Ash专业知识的深度与广度。因此，我想试着进行翻译以加深理解。</p>
<p><strong>以下是原文</strong></p>
<p>一位名为Paul Kim的读者向我推荐了Micheal Tsai的一篇关于“让dispatch_once执行更快”的博客。虽然dispatch_once源代码中的注释精彩且详实，但是它并没有深入剖析那些让人着迷的细节。因为这是我最喜欢研究的方面之一，所以今天的文章我将进行深入地探究dispatch_once内部逻辑和实现原理。</p>
<h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p>dispatch_once函数顾名思义，它只执行一次且唯一的一次。函数接收两个参数，第一个参数是一个predicate，用于跟踪和保证函数的“一次性”；第二个参数是一个block，在函数第一次被调用时执行。调用方式如下所示：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate , ^{</span><br><span class="line">	<span class="comment">//执行一次性的任务</span></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这个函数很适用于共享状态的“懒初始化”，适用范围包括全局字典、单例实体、缓存或者其他任何需要在第一次执行时进行配置的地方。</p>
<p>在只有单线程的环境中，这种调用方式显得有些繁琐，用一个简单的if语句就能取而代之。然而，我们现在面临的都是多线程的运行环境，且diaspatch_once是线程安全的。这就保证了即使多个线程同时调用dispatch_once函数，函数也只执行一个block，并且所有线程直到block中的任务执行结束且dispatch_once退出之前都会处于阻塞状态。尽管你自己实现一个类似的函数不是很难，但是dispatch_once函数执行速度相当之快，并且实现的难度很大。</p>
<h4 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h4><p>让我们先看一个这个函数精简后的单线程版本。虽然这个版本没有实用性，但是让我们对这个函数有一个具体的视觉感官。注意到dispatch_once_t只是一个long整型，且初始化为0，根据实现被赋予不同的含义。以下是实现：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SimpleOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!*predicate)</span><br><span class="line">	{</span><br><span class="line">		block();</span><br><span class="line">		*predicate = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现很简单：如果predicate是0，执行block且更新predicate的值为1。后续的函数调用会发现predicate未非0值便不会重复执行block。如果不是因为在多线程环境是不安全的，这完全就是我们想要的结果。糟糕的是，如果两个线程可能同时访问if语句，会导致block被调用两次。很不幸，这种情况时有发生，因此，让这份代码变成线程安全意味着一次实质性的成功。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>当谈及dispatch_once的性能时，主要有以下三种不同的情景：</p>
<p>1、第一次调用dispatch_once时，指定一个predicate，并执行block.<br>2、在第一次调用dispatch_once之后且block未执行完之前，后续调用线程必须等待直到block执行完成。<br>3、在第一次调用dispatch_once且执行完成之后，后续调用不需要等待而是立即执行。</p>
<p>情景1基本上不影响性能，毕竟只执行一次，只要block执行速度不是太慢。</p>
<p>情景2同样不太影响性能。这个情况可能潜在地发生好几次，但是只有在block未执行完才会发生。大多数情况，这种情况几乎不会发生。如果发生了也可能是仅仅出现一次。甚至在极端测试下：很多线程同时调用dispatch_once并且block执行时间很长，后续处于等待的调用也局限在几千个以内。这些后续调用线程全都必须等待block执行完成，所以即使这些线程在等待过程中耗费了一些不必要的CPU时间也是无关紧要的。</p>
<p>情景3则是性能高低的关键所在。这种性质的调用可能在程序中潜在发生成千上万次。我们想通过dispatch_once来保护那些一次性运算，运算结果被作为调用的返回值。理想情况下，dispatch_once的性能应该可以与直接读取一个提前初始化好的全局变量的性能媲美。换言之，一旦你面临情景3，我们想让下面两个代码块执行的效率是一样的。</p>
<p>代码段1：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> gObject;</span><br><span class="line"><span class="keyword">void</span> Compute(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	gObject = ....;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> Fetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> gObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码段2：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> DispatchFetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">id</span> object;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;predicate, ^{</span><br><span class="line">            object = ...;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在被编译器内联处理和优化之后，SimpleOnce函数的执行效率接近DispatchFetch函数。在我电脑上测试，DispatchFetch函数执行时间为0.5纳秒。这无疑是线程安全版本中的黄金标准。</p>
<p>如何自己实现一个的dispatch_once版本，关键在于确保线程安全，以下列出几种方式：</p>
<h4 id="使用线程锁"><a href="#使用线程锁" class="headerlink" title="使用线程锁"></a>使用线程锁</h4><p>常规的线程安全的做法是在共享数据访问前后添加锁。因为是示例代码，我决定只用一个单一的全局锁变量来做。代码中使用一个静态线程锁变量pthread_mutex_t来保护predicate的线程安全。在实际的项目中，随着函数被多个不同的类调用，伴随着很多不同的predicate变量，这将会是一个糟糕的设计。因为每一个互不关联的predicate变量必须一直等待当前被保护的predicate解锁才能获得执行机会。作为一个快速测试，这里我仅仅只测试一个predicate的情况。这份代码除了加了锁之外与前面的SimpleOnce函数没有区别：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LockedOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">            block();</span><br><span class="line">            *predicate = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码是线程安全的，但不幸的是执行速度太慢。在我的电脑上测试结果为每次调用需要30纳秒，相较于上述0.5纳秒的版本实在差太远。线程锁已经算很快的了，但不属于纳秒级别的。</p>
<h4 id="使用自旋锁"><a href="#使用自旋锁" class="headerlink" title="使用自旋锁"></a>使用自旋锁</h4><p>自旋锁是一种试图将额外的开销降到最低的锁。顾名思义，自旋锁在处于需要等待的时候拥有“自旋”的功能，不断地轮询临锁的状态查看是否已经解锁。一般的锁都会配合操作系统休眠正在等待的线程，等解锁之后再唤醒所在的线程。这种锁虽然节省了CPU时间，但是这种协调休眠的机制也是有代价的。自旋锁不会休眠等待线程，因此在处于等待解锁的情况下节省了很多时间，付出的代价则是当多个线程试图获得自旋锁时效率会比较低。</p>
<p>MacOS X提供了<a target="_blank" rel="noopener" href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/spinlock.3.html">一套便利的自旋锁API</a>名为OSSpinLock.使用OSSinLock实现LockedOnce只需要在原有的基础修改几个名称：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpinlockOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">       <span class="keyword">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line">       OSSpinLockLock(&amp;lock);</span><br><span class="line">       <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">           block();</span><br><span class="line">           *predicate = <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">       OSSpinLockUnlock(&amp;lock);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p>这次有了相当大的提升。在我电脑上测试结果为每次调用需要6.5纳秒，远好于pthread_mutex版本的每次调用30纳秒。然而于dispatch_once比起来还是太慢了。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作是底层CPU级别的操作且即使没有锁也一直都是线程安全。从技术层面来说，它们使用的硬件锁。使用锁会带来额外的开销，直接使用原子操作可以带来性能上的提升。多线程编程没有锁可能会显得很别捏，所以除非你真的需要原子操作，否则这不是明智的选择。我们现在讨论的是一个可能会被频繁使用的系统库，因此也许值得添加原子操作。</p>
<p>原子操作创建锁的过程是“比较并交换”。这是一个类似于下面代码的简单操作：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> CompareAndSwap(<span class="keyword">long</span> *ptr, <span class="keyword">long</span> testValue, <span class="keyword">long</span> newValue) {</span><br><span class="line">	<span class="keyword">if</span>(*ptr ==  testValue) {</span><br><span class="line">		*ptr = newValue;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>总而言之，函数CompareAndSwap的功能用来测试内存的一个地址是否存储着一个特定的值，如果是则用新的值替换原有的值，返回结果表示匹配成功与否。因为“比较并交换”是一个CPU级的原子指令，所以即使有多个线程都试着对同一个内存区域进行“比较并交换”的操作都能确保其中只有一个操作能够成功。</p>
<p>LockedOnce的这个版本的实现策略是对predicate赋予三个不同的值。0表示函数还未被调用过；1表示函数block正处于执行状态，后续调用线程则处于等待状态；2表示block执行完成且释放阻塞的等待线程并返回结果。</p>
<p>“比较并交换”原子操作将被用于检测predicate的值是否为0，如果是则自动更新predicate为1。一旦原子操作返回的是YES，意味着当前线程是第一个调用线程，并开始唯一一次地block执行。在block执行完成后更新predicate的值为2作为标识.</p>
<p>如果“比较并交换”原子操作执行失败意味着当前线程不是第一个调用者，然后线程进入一个循环，不断地检测predicate的值是否更新为2，直到predicate更新为2才退出循环。这将导致线程在block执行结束之前一直处于等待状态。</p>
<p>以下是这个版本的函数的具体：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">	<span class="comment">//将predicate指针转换成volatile指针，</span></span><br><span class="line">	<span class="comment">//以告知编译器这个变量的值可能在函数执行过程中被其他线程更改，</span></span><br><span class="line">	<span class="comment">//必须每次从内存地址取值，而非寄存器</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用“比较并交换”原子操作。</span></span><br><span class="line">	<span class="comment">//Gcc编译器和clang编译器均提供了各种以_sync开头的内置函数以实现原子操作。</span></span><br><span class="line">	<span class="comment">//下面的函数对predicate执行了“比较并交换”的原子操作，</span></span><br><span class="line">	<span class="comment">//检测predicate的值是否为0，如果是则更新为1</span></span><br><span class="line">	<span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">		<span class="comment">//执行block</span></span><br><span class="line">		block();</span><br><span class="line">		<span class="comment">//一旦block执行完成，更新predicate的值为2用以告知当前正在等待的调用线程以及未来的调用者block已经执行完成。</span></span><br><span class="line">		<span class="comment">//然而，考虑到CPU的优化机制，我们使用内存屏障以确保volatilePredicate值的读书顺序是正确的。</span></span><br><span class="line">		<span class="comment">//使用内置函数__sync_synchronize在此出设置内存屏障，</span></span><br><span class="line">		<span class="comment">//确保volatilePredicate在block执行完后立即更新为2，且在此之前不可读。</span></span><br><span class="line">		__sync_synchronize();</span><br><span class="line">		<span class="comment">//更新</span></span><br><span class="line">		*volatilePredicate = <span class="number">2</span>;</span><br><span class="line">	}<span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">//等待线程循环检测</span></span><br><span class="line">		<span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>);</span><br><span class="line">		<span class="comment">//线程返回之前设置内存屏障，匹配if语句中的内存屏障设置，保证volatilePredicate读取一致性</span></span><br><span class="line">		__sync_synchronize();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码满足需求且是线程安全的，但是性能一般。在我电脑上每次调用时间为20纳秒，明显高于自旋锁版本。</p>
<h4 id="提前预判"><a href="#提前预判" class="headerlink" title="提前预判"></a>提前预判</h4><p>这里有一个显而易见的优化可以添加到原子操作的版本中。因为通常情况下都是predicate的值已经是2，在函数最开始的地方加一个判断语句，可以在大多数情况下加快函数执行速度：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>) {</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>这个版本的执行效率有相当大的提升，大约是调用一次11.5纳秒。然而，对比与dispatch_once版本还是相去甚远，甚至不如自旋锁版本。</p>
<p>设置内存屏障有额外的开销，这也是为什么这个版本的执行速度比dispatch_once慢的原因所在。至于为什么会比自旋锁版本慢，是因为代码中设置了不同类型的内存屏障。__sync_synchronize函数会产生一个mfence的指令，这个指令是可能是最耗费资源的指令之一，然而OSSpinLock使用的是一个效率更高的指令。我们可以尝试不同的内存屏障以到达更好的效果，但是很明显代码最终的执行速度未达到我们预期结果，因为我打算弃用这种方法。</p>
<h4 id="非线程安全的提前预判"><a href="#非线程安全的提前预判" class="headerlink" title="非线程安全的提前预判"></a>非线程安全的提前预判</h4><p>这个版本与上面的版本很类似，只不过将内存屏障移除了：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UnsafeEarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>不出意外，这个版本的执行速度与SimpleOnce一样都是0.5纳秒。因为*predicate == 2的适用于大多数情况，差不多每次调用都是检测predicate的值并返回。这个版本除了第一次执行block之外，几乎与SimpleOnce函数一样。</p>
<p>正如函数名所示，这是一个非线程安全版本，缺少了内存屏障导致线程不安全。原因何在？</p>
<h4 id="CPU流水线执行方式"><a href="#CPU流水线执行方式" class="headerlink" title="CPU流水线执行方式"></a>CPU流水线执行方式</h4><p>我们可以将CPU想象成一个简单的机器，我们告诉它做什么，它就做什么。如此反复直到天荒地老。</p>
<p>曾经有一段时间确实如此。老版的CPU的工作方式很简单，一眼一板。不幸的是，这种方式简单，容易且成本低，但是执行效率低。根据摩尔定律，CPU内置的晶体管成指数增长。8086CPU内置了大约29000个晶体管。一个英特尔处理器CPU集成了超过十亿的晶体管。</p>
<p>根据市场需求决定了CPU拥有更好的效率，现在的CPU集成了越来越多的晶体管旨在让电脑运行速度更快。</p>
<p>这里面有很多技巧让CPU执行的更快。其中一种就是流水线。执行单一的CPU指令，分成多个小步骤：</p>
<ol>
<li>从内存加载指令</li>
<li>指令解码（分析指令解析包含哪些运算操作）</li>
<li>加载输入数据</li>
<li>结合输入执行运算</li>
<li>保存输出数据</li>
</ol>
<p>在一个早期的CPU，上述流程执行步骤如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加载指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">加载下一个指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>在一个流水线型的CPU，执行步骤则如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加载指令  </span><br><span class="line">解码				加载指令		</span><br><span class="line">加载数据			解码				加载指令</span><br><span class="line">运算				加载数据			解码</span><br><span class="line">保存输出			运算				加载数据</span><br><span class="line">					保存输出			运算</span><br><span class="line">										保存输出</span><br></pre></td></tr></tbody></table></figure>
<p>这种方式执行速度快很多。随着CPU中的晶体管数量越来越多，CPU内部结构也越来越复杂，同步执行的指令也越来越多。<br>更有甚者，如果可以让速度更快，指令的执行顺序会被完全打乱。不同于上述简单的例子，真实情况下，指令更为复杂以及变量更多。</p>
<p>代码执行的顺序并不以总是与代码本身的顺序一致的，比如下面的代码：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>CPU可能会先写入Y变量的值。有些情况下编译器也会对语法重新排序，即便你屏蔽了编译器的行为，CPU仍然会乱序执行。如果是多核CPU，在其他的CPU看了写入的顺序是乱序的。即使是按代码顺序写入的，其他的CPU也会乱序读取。综合考虑，其它的线程在读取x和y的值时会发现y的值已经改变而x还是原来的值。</p>
<p>在你需要这些值必须按照既定的顺序写入的时候，内存屏障就派上用场了。设置内存屏障以确保上述代码中x的值先被更新：</p>
<ul>
<li>x = 1;</li>
<li>memory_barrier();</li>
<li>y = 2;</li>
</ul>
<p>同样地，内存屏障可以确保读的顺序：</p>
<ul>
<li>use(x);</li>
<li>memory_barrier();</li>
<li>use(y);</li>
</ul>
<p>然而，因为内存屏障的主要功能导致CPU的执行速度，所以自然而然影响性能。</p>
<p>对于dispatch_once来说，代码必须按照既定的顺序执行，因此必须设置内存屏障。但是，内存屏障会导致代码效率低下，所以为了避免额外的开销，我们想办法避免设置内存屏障。</p>
<h4 id="CPU的分支预测和推测性执行"><a href="#CPU的分支预测和推测性执行" class="headerlink" title="CPU的分支预测和推测性执行"></a>CPU的分支预测和推测性执行</h4><p>流水线和乱序工作模式适用于一系列线性执行的指令，但是对于添加分支语句则变得麻烦。CPU在分支语句执行完之前不知道下一步该执行什么指令，因此不得不停止运行等待前面的分支语句结束再重新运行。这就是所谓的pipeline stall，在一定程度上影响CPU性能。</p>
<p>为了弥补pipeline stall带了的性能损失，CPU加入了推测性执行。当CPU遇到一个分支语句则会进行分支预测判断哪一个分支可能被执行。现在的CPU配置精密的分支预判硬件，准确率在90%以上。在做出预判之后，CPU开始执行假设的分支中的代码块，而不是等待分支语句的结果。如果分支预判是正确的则继续后续执行。如果预判错误则清空推测执行结果重新执行另外一个分支代码块。</p>
<p>这种情况被用在了dispatch_once的读取端，这也是我们期望执行速度越快越好的地方。dispatch_once中有一个判断predicate的值得分支语句。CPU应该会预判并执行else分支，因为这个大多数情况下会执行的分支，即绕过block执行然后立即返回结果。在推测性执行过程中，CPU可能会从内存中加载那些后续需要但是还未被其他线程初始化的变量。如果分支预判是正确的，CPU会使用未初始化的值进行推测性执行。</p>
<h4 id="非对称屏障"><a href="#非对称屏障" class="headerlink" title="非对称屏障"></a>非对称屏障</h4><p>内存屏障一般都是需要对称的：在写的一端确保按照正确的顺序写入，在读的一端确保按照正确的顺序读取。然而，我们需要非对称屏障来满足我们的性能需求：我们可以容忍写入端的速度缓慢，但是让读的速度越快越好。</p>
<p>这个技巧用来防范推测性执行导致的问题。当分支预判是错误的，推测性执行的结果会被弃用。如果dispatch_once可以在初始化完成之后强制确定CPU的分支预判，这个问题则可以被避免。</p>
<p>此处有一个间隔时间，即最初的推测性执行到条件语句执行结束之间的间隔时间。间隔具体的时间因CPU而异，但是最多几十个CPU周期的时间。</p>
<p>在英特尔CPU中，dispatch_once使用spuid指令到达上述目的。cpuid指令主要是用于获取CPU的ID和功能等信息，但是也可以强行序列化指令流并需要耗费几百个CPU周期的时间。</p>
<p>在dispatch_once的源代码中，你会发现在读的一端没有使用内存屏障：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_<span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) {</span><br><span class="line">        <span class="built_in">dispatch_once</span>(predicate, block);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></tbody></table></figure>
<p>这段代码位于头文件中，并内联只调用者的代码块。DISPATCH_EXPECT宏告诉编译器去告知CPU：*predicate = ~0l是更有可能发生的分支。这可以提高分支预判的准确性，继而提升执行效率。基本上，这里只有一个普通的if语句，没有设置任何屏障。调用dispatch_once的执行速度接近0.5纳秒的黄金标准。</p>
<p>在dispatch_once实现文件中可以看到写入端的实现，在block执行后立即执行了下面的宏：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_atomic_maximally_synchronizing_barrier();</span><br></pre></td></tr></tbody></table></figure>
<p>在英特尔的CPU中，这个宏使用了cpuid指令，在其他的CPU框架中也会产生类似的指令。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>多线程是最奇怪和复杂的地方，现代的CPU在背后做了很多不为认知的事情。内存屏障允许你告知硬件按照你需要的顺序执行代码，但是相应的需要在性能上做出牺牲。dispatch_once有着独一无二的需求，让CPU不走寻常路：在相关的内存写入完成之前牺牲足够多的等待时间，但是确保每一次读取都是高效安全的且不需要额外的内存屏障。            </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-04-01T15:50:07.000Z" title="4/1/2015, 11:50:07 PM">2015-04-01</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">15 minutes read (About 2266 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/04/01/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0+load%E5%92%8C+initialize/">两个特殊函数+load和+initialize</a></h1><div class="content"><p>记得还在上一家公司任职的时候，在研发部的探讨会会上就“+load的加载过程”这一议题有过激烈的讨论，大家各执一词，争得面红耳赤。最终是部门老大专门做了一期讲解，才平息了这场争执。但是那时候的讲解并未涉及到源代码分析，而是基于测试代码做的分析，故我并没有完全理解。</p>
<p>在苹果开发文档中提及到：+load是在类或者分类被添加到runtime的时候被调用，而+initialize则是在类的用实例方法或者类方法第一次被调用之前调用。</p>
<p>上面的说明只是说明了这两个函数调用时机，但是并没有涉及父类、子类和分类之间的调用顺序和相互影响，于是试着结合<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">apple公司的开源代码</a>objc4-532.2试着分析这两个函数的加载过程，以加深理解。</p>
<h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>首先在objc-os.mm文件中找到函数_objc_load_image_objc_load_image：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class="line">{</span><br><span class="line">    prepare_load_methods(hinfo);</span><br><span class="line">    call_load_methods();</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<p>根据参数判断，这个函数应该是在加载镜像文件的时候由系统直接调用，且里面就两行代码，分别是对+load函数的预处理与加载</p>
<p>接着在objc-runtime-new.mm文件找查看prepare_load_methods的函数实现：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> prepare_load_methods(header_info *hi)</span><br><span class="line">{</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">	<span class="comment">//获取头文件中所有的类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="comment">//先处理类中的+load方法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="comment">//处理类与父类中的+load函数    schedule_class_load(remapClass(classlist[i]));</span></span><br><span class="line">    }</span><br><span class="line">	 <span class="comment">//再处理分类中的+load方法</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    	 <span class="comment">//初始化分类</span></span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(isRealized(cls-&gt;isa));</span><br><span class="line">        <span class="comment">//将可加载的（存在+load函数）分类归类</span></span><br><span class="line">        add_category_to_loadable_list((Category)cat);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(isRealized(cls));  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//递归调用，优先处理父类</span></span><br><span class="line">    schedule_class_load(getSuperclass(cls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也就意味着父类中的+load方法先被加入列表</span></span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, <span class="number">0</span>); </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>由上述函数可以推断出：父类的+load方法先于子类被加入待处理列表，分类与类中的+load方法是区分对待的。</p>
<p>接着，在objc-loadmethod.mm文件中查看call_class_loads函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> more_categories;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_assert_locked(&amp;loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先调用类中的+load方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) {</span><br><span class="line">        	<span class="comment">//先入先出处理+load函数列表</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        }</span><br><span class="line">			</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">//再调用分类中的+load函数</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    } <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = <span class="literal">NULL</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="comment">//先入先出的遍历顺序，调用父类函数先于子类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">//获得+load的函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">   		  <span class="comment">//注意：是通过函数指针直接调用，而非使用objc_msgSend，因此不会走runtime调用过程。</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) _free_internal(classes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  _class_isLoadable(cls)) {</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             _class_getName(cls), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//直接通过函数指针进行调用，而非通过objc_msgSend调用</span></span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中，先调用了类的+load函数列表，再处理分类中的+load函数，且都是直接通过函数指针调用。又因为父类的+load函数先于子类加入列表，因此+load函数的调用顺序是：父类-&gt;子类-&gt;分类</p>
<p>在上一篇博客<a target="_blank" rel="noopener" href="http://icebergcwp.com/2015/03/25/Objective-C%20Category%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Objective-C Category 深入浅出系列之实现原理</a>中结合源代码分析了Category的实现原理。其中有一个重要的知识点就是分类Category中函数会覆盖主类中同名的函数。然而这种情况发生的前提是函数必须是通过runtime机制（使用objc_msgSend发送消息）调用，因为这样才会通过遍历类的方法列表去获得方法对应的实现。</p>
<h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p>既然+initialize函数是在类的实例方法或者类方法第一次被调用之前触发，而类的实例方法或者类方法正常的调用方式是通过objc_msgSend函数。那么+initialize很有可能是在objc_msgSend函数中进行判断和触发，于是，在objc-msg-x86_64.s文件找到了objc_msgSend的汇编实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line">	</span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">	.private_extern __objc_tagged_isa_table</span><br><span class="line">__objc_tagged_isa_table:</span><br><span class="line">	.fill 16, 8, 0</span><br><span class="line"></span><br><span class="line">	ENTRY	_objc_msgSend</span><br><span class="line">	DW_START _objc_msgSend</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		// r11 = self-&gt;isa</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend  // r11=method, eq set (nonstret fwd)</span><br><span class="line">	jmp	*method_imp(%r11)	// goto *imp</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport	NORMAL</span><br><span class="line"></span><br><span class="line">// cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">	DW_MISS _objc_msgSend</span><br><span class="line">	GetIsa	NORMAL			// r11 = self-&gt;isa</span><br><span class="line">	MethodTableLookup %a1, %a2, _objc_msgSend	// r11 = IMP</span><br><span class="line">	cmp	%r11, %r11		// set eq (nonstret) for forwarding</span><br><span class="line">	jmp	*%r11			// goto *imp</span><br><span class="line"></span><br><span class="line">	DW_END 		_objc_msgSend, 1, 1</span><br><span class="line">	END_ENTRY	_objc_msgSend</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	DW_START _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	SaveRegisters _objc_msgSend_fixup</span><br><span class="line">	</span><br><span class="line">	// Dereference obj/isa/cache to crash before _objc_fixupMessageRef</span><br><span class="line">	movq	8(%a2), %a6		// selector</span><br><span class="line">	GetIsa	NORMAL			// r11 = isa = *receiver</span><br><span class="line">	movq	cache(%r11), %a5	// cache = *isa</span><br><span class="line">	movq	mask(%a5), %a4		// *cache</span><br><span class="line"></span><br><span class="line">	// a1 = receiver</span><br><span class="line">	// a2 = address of message ref</span><br><span class="line">	movq	%a2, %a3</span><br><span class="line">	xorl	%a2d, %a2d</span><br><span class="line">	// __objc_fixupMessageRef(receiver, 0, ref)</span><br><span class="line">	call	__objc_fixupMessageRef</span><br><span class="line">	movq	%rax, %r11</span><br><span class="line"></span><br><span class="line">	RestoreRegisters _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	// imp is in r11</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	cmp	%r11, %r11		// set nonstret (eq) for forwarding</span><br><span class="line">	jmp 	*%r11</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line">	</span><br><span class="line">	DW_END 		_objc_msgSend_fixup, 0, 1</span><br><span class="line">	END_ENTRY 	_objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>汇编基本就是大一水平，很有限。初略发现在调用指令_objc_msgSend之前，先调用了_objc_fixupMessageRef函数。</p>
<p>接着在objc-runtime-new.mm文件中找到_objc_fixupMessageRef函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXTERN IMP </span><br><span class="line">_objc_fixupMessageRef(<span class="keyword">id</span> obj, <span class="keyword">struct</span> objc_super2 *supr, message_ref_t *msg)</span><br><span class="line">{</span><br><span class="line">    IMP imp;</span><br><span class="line">    class_t *isa;</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    msg-&gt;sel = sel_registerName((<span class="keyword">const</span> <span class="keyword">char</span> *)msg-&gt;sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(msg-&gt;sel)) {</span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        msg-&gt;imp = (IMP)&amp;vtable_ignored;</span><br><span class="line">        imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_VTABLE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;imp == (IMP)&amp;objc_msgSend_fixup  &amp;&amp;  </span><br><span class="line">        (vtableIndex = vtable_getIndex(msg-&gt;sel)) &gt;= <span class="number">0</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// vtable dispatch</span></span><br><span class="line">        msg-&gt;imp = vtableTrampolines[vtableIndex];</span><br><span class="line">        imp = isa-&gt;vtable[vtableIndex];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ordinary dispatch</span></span><br><span class="line">        <span class="comment">//常规的消息派发，遍历类的函数列表</span></span><br><span class="line">        imp = lookUpMethod((Class)isa, msg-&gt;sel, <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, obj);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中调用了lookUpMethod函数，其中调用了prepareForMethodLookup函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IMP prepareForMethodLookup(Class cls, SEL sel, <span class="built_in">BOOL</span> init, <span class="keyword">id</span> obj)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRealized(newcls(cls))) {</span><br><span class="line">        rwlock_write(&amp;runtimeLock);</span><br><span class="line">        realizeClass(newcls(cls));</span><br><span class="line">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用_class_initialize对类进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init  &amp;&amp;  !_class_isInitialized(cls)) {</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, obj));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在objc-initialize.mm函数中，找到_class_initialize函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">{</span><br><span class="line">    assert(!_class_isMetaClass(cls));</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">BOOL</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">//递归，保证父类先于子类初始化</span></span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) {</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: calling +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//通过objc_msgSend调用+initialize函数</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: finished +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Done initializing. </span></span><br><span class="line">        <span class="comment">// If the superclass is also done initializing, then update </span></span><br><span class="line">        <span class="comment">//   the info bits and notify waiting threads.</span></span><br><span class="line">        <span class="comment">// If not, update them later. (This can happen if this +initialize </span></span><br><span class="line">        <span class="comment">//   was itself triggered from inside a superclass +initialize.)</span></span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>通过上述函数可知两点：一是父类的+initialize函数先于子类调用，二是+initialize不同于+load函数的采用函数指针调用，而是通过objc_msgSend函数调用，如果分类实现了+initialize函数，那么类（包括子类和父类）的+initialize函数就会被覆盖。</p>
<p>因此，+initialize的调用顺序是父类-&gt;子类，且分类的实现覆盖类的实现，因此分类中的+initialize可能会被多次调用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，对于+load和+initialize的调用规则和方式有了进一步的认识。在日后的编程过程中也可以根据二者的特点，更好的使用它们的功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-02-25T15:45:07.000Z" title="2/25/2015, 11:45:07 PM">2015-02-25</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">10 minutes read (About 1515 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/02/25/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC3%E8%AF%9D/">揭开ARC的神秘面纱系列-第3话</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="http://www.galloway.me.uk/2012/02/a-look-under-arcs-hood-episode-3/">原文地址</a></p>
<p>“揭开ARC的神秘面纱系列”的这篇续集全都是关于@autoreleasepool这一新指令的。<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool">LLVM提及到</a>autorelease pools（自动释放池）的语义已经在LLVM3.0版本中发生变化，尤其是，我觉得探究ARC模式更新之后是如何实现的会很有意思。</p>
<p>因此，思考一下下面的函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() {</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>显然，这完全是不和谐的代码段，但是它能让我看到发生什么。在非ARC模式下，我们可能会假设：number将会在numberWithInt:函数中被分配内存，并返回的是一个自动释放的对象。因此当自动释放池随后被销毁时，number对象将会被释放。所以让我们看看是否如上所述（一如往常，使用的是ARMv7指令集）：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>不错，答案是肯定的。正是这样的。我们可以看到函数先将自动释放池入栈，然后调用numberWithInt:函数，然后将自动释放池出栈。正如我们所预料的。现在我们看看完全相同的代码在ARC模式编译出来是怎么样的：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#8</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>留意上述代码中objc_retainAutoreleasedReturnValue函数和objc_release的调用。ARC已经为我们做了决定，完全不必担心自动释放池，因为ARC可以直接不然自动释放池生效，通过调用objc_retainAutoreleasedReturnValue函数对number对象进行retain一次，然后在后面在调用objc_release函数释放它。这意味着自动释放池的逻辑不一定执行，让人满意的结果。</p>
<p>注意到自动释放池一直需要入栈和出栈，是因为ARC无法知晓numberWithInt函数和NSLog函数中会发生什么，不知道在函数中是否有对象会被加入释放池。如果说ARC知道这两个函数不会自动释放任何东西则实际上可以移除自动释放池的入栈和出栈操作。也许这种逻辑在ARC未来的版本中出现，尽管我不是很确定那时候ARC的语义会如何实现。</p>
<p>现在让我思考另外一个例子，在这个例子中我们想要在自动释放池的作用域之外使用number对象。这应该告诉我们为什么ARC是一个神奇的工具。思考下面的代码：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() {</span><br><span class="line">    <span class="built_in">NSNumber</span> *number;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>你可能会认为上述这段看似很和谐的代码会出问题。问题在于number对象将在自动释放池中创建，在自动释放池初衷时被释放，但是却在释放之后继续使用。噢！让我们通过在非ARC模式下编译上述代码来看看我们的猜想是否是正确的：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>很明显，正如我们所期望的那样没有调用retain,release或者autorelease，因为我们没有显式调用这些函数以及使用ARC。编译的结果也正如我们之前推理的那样。接下来让我们在ARC的帮助下会是什么样：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>此处应该有掌声！ARC识别出我们在自动释放池作用域之外使用了number对象，因此它如上一段代码一样对numberWithInt:函数的返回值进行了retain，但是这一次它将release操作放在了bar函数末尾而不是自动释放池出栈的时候。这一举措避免在一些代码中出现崩溃，我们可能会认为这些代码是正确的，但实际上却潜在着内存管理的bug。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-02-20T15:16:07.000Z" title="2/20/2015, 11:16:07 PM">2015-02-20</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">6 minutes read (About 957 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/02/20/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC2%E8%AF%9D/">揭开ARC的神秘面纱系列-第2话</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-2/">原文地址</a></p>
<p>以下是正文：</p>
<p>写完第一篇关于<a target="_blank" rel="noopener" href="http://icebergcwp.com/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/">揭开ARC神秘面纱</a>的博客，我想和大家分享另外一些有趣的片段。这一次我好奇当你通过函数返回一个存在数组中的对象时会发生什么。非ARC模式，你可能会对这个对象retain一次再返回一个自动释放的对象。ARC模式下，我们虽然可以免去这些内存管理的操作，但还是不放心，觉得别扭。因此，我决定检测一下ARC是否做到位了。</p>
<p>考虑一下这个类：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)popObject {</span><br><span class="line">    <span class="keyword">id</span> lastObject = [array lastObject];</span><br><span class="line">    <span class="keyword">if</span> (lastObject) {</span><br><span class="line">        [array removeLastObject];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lastObject;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在非ARC模式下，调用函数removeLastObject将会释放数组对对象的持有，如果这是对象的最后一个引用则对象的内存将会被释放，意味着返回的对象是一个已经被回收的对象。所以，我们应当retain一次lastObject并在返回前添加autorelease属性（加入自动释放池）。</p>
<p>尽管我完全明白ARC应该会完成这些工作，但是我还是担忧没有自己添加这些操作。我天真地以为ARC会一行行地解析函数中的代码。如果是这样，我觉得ARC也许没必要在我们引用lastObject对象的时候为它添加一次引用计数，此时ARC并不知道lastObject需要进行retain，所以ARC没必要非得做这些操作。</p>
<p>这就是我错误所在。显然，ARC在我们引用lastObject对象的时候为其添加一次引用计数，并在对象立刻作用域的时候进行了一次release操作，在我们这个例子中，由于我们是通过函数返回这个对象且函数名不是已关键字new或者copy开头，因此需要将对象加入自动释放池。</p>
<p>让我们看看上述代码编译之后的样子：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.thumb_func</span>     <span class="string">"-[ClassA popObject]"</span></span><br><span class="line"><span class="string">"-[ClassA popObject]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">cbz</span>     <span class="built_in">r5</span>, LBB0_2</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line"><span class="symbol">LBB0_2:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleaseReturnValue</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>好吧，事实如此。ARC已经为我们考虑周全了。ARC在代码中插入了objc_retainAutoreleaseReturnValue调用，这意味着ARC已经觉察到需要给一个已经加入自动释放池的返回值增加引用计数，这个操作属于ARC的一种优化处理，它仅仅是把对象从自动释放池中移除而并非真的添加一次引用计数。接下来在函数结尾处，ARC调用了objc_autoreleaseReturnValue，这个函数将即将返回的对象加入自动释放池。</p>
<p>这仅仅是关于揭开ARC神秘面纱系列的另外一个例子。随着使用ARC的次数增多，我愈发意识它的实用性。ARC减少代码中内存管理相关的错误，并将上述的代码片段进行最佳优化处理。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Mark Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mark Cao</p><p class="is-size-6 is-block">程序的世界让我着迷</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ChangSha</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/industriousonesoft" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/industriousonesoft"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">December 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">August 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">May 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">August 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">June 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">May 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">November 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">October 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/09/"><span class="level-start"><span class="level-item">September 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/08/"><span class="level-start"><span class="level-item">August 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">May 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">April 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/03/"><span class="level-start"><span class="level-item">March 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">February 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">January 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-06-27T13:34:07.000Z">2019-06-27</time></p><p class="title"><a href="/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/">初识汇编-知识点摘记</a></p><p class="categories"><a href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-12-01T03:33:07.000Z">2018-12-01</time></p><p class="title"><a href="/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/">《三体》系列第一部读后感之生存还是死亡？</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E8%AF%84/">书评</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-14T14:37:07.000Z">2018-11-14</time></p><p class="title"><a href="/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/">需求第三定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-13T14:13:07.000Z">2018-11-13</time></p><p class="title"><a href="/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/">需求第二定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-11T01:18:07.000Z">2018-11-11</time></p><p class="title"><a href="/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/">需求第一定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/Objective-C/"><span class="level-start"><span class="level-item">Objective-C</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/"><span class="level-start"><span class="level-item">专业</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/OSX/"><span class="level-start"><span class="level-item">OSX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/%E7%BF%BB%E8%AF%91/"><span class="level-start"><span class="level-item">翻译</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E8%AF%84/"><span class="level-start"><span class="level-item">书评</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BD%B1%E8%AF%84/"><span class="level-start"><span class="level-item">影评</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">汇编</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARC/"><span class="tag">ARC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Category/"><span class="tag">Category</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cocoa/"><span class="tag">Cocoa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coffee/"><span class="tag">Coffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaSctript/"><span class="tag">JavaSctript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KVO/"><span class="tag">KVO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OSX/"><span class="tag">OSX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Objective-C/"><span class="tag">Objective-C</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PlistBuddy/"><span class="tag">PlistBuddy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RunLoop/"><span class="tag">RunLoop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%89%E4%BD%93/"><span class="tag">三体</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"><span class="tag">人物传记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"><span class="tag">人类简史</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%B1/"><span class="tag">爱</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a><p class="is-size-7"><span>&copy; 2022 Mark Cao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>