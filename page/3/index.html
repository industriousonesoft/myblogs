<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MarkCao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MarkCao"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MarkCao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MarkCao"><meta property="og:url" content="http://naivertc.top/"><meta property="og:site_name" content="MarkCao"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://naivertc.top/img/og_image.png"><meta property="article:author" content="Mark Cao"><meta property="article:tag" content="WebRTC, C++, iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naivertc.top"},"headline":"MarkCao","image":["http://naivertc.top/img/og_image.png"],"author":{"@type":"Person","name":"Mark Cao"},"publisher":{"@type":"Organization","name":"MarkCao","logo":{"@type":"ImageObject","url":"http://naivertc.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="MarkCao" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-10-07T15:06:07.000Z" title="10/7/2017, 11:06:07 PM">2017-10-07</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">an hour read (About 8632 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/10/07/Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Effective Objective-C 2.0读书笔记</a></h1><div class="content"><h3 id="第1章-熟悉Objective-C"><a href="#第1章-熟悉Objective-C" class="headerlink" title="第1章 熟悉Objective-C"></a>第1章 熟悉Objective-C</h3><h4 id="1-了解Objective-C语言的起源"><a href="#1-了解Objective-C语言的起源" class="headerlink" title="1: 了解Objective-C语言的起源"></a>1: 了解Objective-C语言的起源</h4><ul>
<li>Objective-C语言是由Smalltalk演化而来，后者是消息型语言的鼻祖。</li>
<li>消息机构的语言，不论是否多态，其运行时所执行的代码都由运行环境来决定；而使用函数调用的语言则由编译器决定，但调用函数是多态的，则是在运行时通过查询“虚方法表（virtual table）”决定具体执行函数。</li>
<li>如果只需要保存int、flot、double、char等非对象类型，通常使用CGRect这种结构体，因为结构体可以使用栈空间，而不用分配和释放堆空间，避免额外开销。</li>
</ul>
<h4 id="2-在类的头文件中尽量少引用其他头文件"><a href="#2-在类的头文件中尽量少引用其他头文件" class="headerlink" title="2: 在类的头文件中尽量少引用其他头文件"></a>2: 在类的头文件中尽量少引用其他头文件</h4><ul>
<li>除非确实有必要，否则不要引入头文件，尽量使用向前声明，这样不但可以缩短编译时间和降低类之间的耦合。</li>
<li>如果无法使用向前声明，比如要声明某个类遵循一项协议。尽量把所遵循的协议移至实现文件中的匿名分类。如果必须在头文件引入协议头文件，则把协议单独放在一个头文件中。</li>
</ul>
<h4 id="3-多用字面量语法，少用与之对等的方法"><a href="#3-多用字面量语法，少用与之对等的方法" class="headerlink" title="3: 多用字面量语法，少用与之对等的方法"></a>3: 多用字面量语法，少用与之对等的方法</h4><ul>
<li>使用字面量语法创建字符串、数值、数组、字典更为简单扼要。</li>
<li>使用取下标操作访问数组下标或者字典中的键对应的元素。</li>
<li>使用字面量语言更为安全，遇到nil对象会抛出异常。</li>
<li>字面量语法的限制：除了字符串以外，所创建出来的对象必须属于Foundation框架才行。</li>
</ul>
<h4 id="4-多用类型常量，少用-define预处理指令"><a href="#4-多用类型常量，少用-define预处理指令" class="headerlink" title="4: 多用类型常量，少用#define预处理指令"></a>4: 多用类型常量，少用#define预处理指令</h4><ul>
<li>若常量局限于某个实现文件之内，则前面加字面k，若常量在类之外，则通常以类名为前缀。</li>
<li>static修饰符意味着变量仅在定义此变量的编译单元中可见，在Objective-C的语境下，编译单元通常指每个类的实现文件，即以.m为后缀名。</li>
<li>常量必须使用const修饰符声明，常量定义从右至左解读，下面例子中定义了一个常量指针，const修饰的是指针，指向NSString对象。<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果一个变量同时声明为static和const,那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值。</li>
<li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中，因此通常与之相关的类名做前缀加以区分。</li>
</ul>
<h4 id="5：用枚举表示状态、选项、状态码"><a href="#5：用枚举表示状态、选项、状态码" class="headerlink" title="5：用枚举表示状态、选项、状态码"></a>5：用枚举表示状态、选项、状态码</h4><ul>
<li>C++11标准修订了枚举的某些特性，其中包括可以指定何种“底层数据类型”来保存枚举类型的变量。这样做的好处是可以向前声明枚举变量了，如果编译器不清楚底层数据类型就不知道分配空间大小。</li>
<li>如果枚举类型是多个选项且同时使用，那么久将各选项值定义为2的幂，以便按位或操作进行组合。</li>
<li>用NS_ENUM与NS_OPTION宏来定义枚举类型，并指明其底层数据类型，这样确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的switch语句中不要实现default分析，这样加入新的枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li>
</ul>
<h3 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h3><h4 id="第6条：-理解“属性”这一概念"><a href="#第6条：-理解“属性”这一概念" class="headerlink" title="第6条： 理解“属性”这一概念"></a>第6条： 理解“属性”这一概念</h4><ul>
<li>使用@property语法编译器会自动创建一套存取方法，因此访问属性实质上就是调用存取函数，走消息派发流程。</li>
<li>@synthesize语言可以指定属性实例变量的名字，默认的属性名前加下划线。</li>
<li>@dynamic关键字可以阻止属性创建实例变量和存取方式，编译器即使在编译过程中没有发现该属性的存取方法也不会保存，而是相信这些方法在运行期能够找到。</li>
<li>原子性只能确保每次都能获取属性的有效值，即确保属性修改完成再被其他线程访问，但是不能确保线程安全。</li>
<li>处于性能考虑，iOS程序所有属性都是nonatomic，Mac OS X程序使用atomic属性通常不会有性能瓶颈。</li>
<li>对应一个属性定义的变量来说，直接访问实例变量会绕开指定的属性特质和消息派发流程。</li>
</ul>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>使用“点语法”（本质上使用实例变量存取方法）与直接访问实例变量的区别：<ul>
<li>直接访问实例变量不经过Objective-C的消息派发流程，因此速度比点语法快。</li>
<li>直接访问实例变量不会调用属性配置的存取方法，从而绕过了属性指定的相关特质。</li>
<li>直接访问实例变量不会触发“键值观测KVO”通知，因为键值观测是建立在存取方法之上的。</li>
</ul>
</li>
<li>在初始化方法和dealloc中尽量直接访问实例变量，因为子类可能覆写父类属性的存取方法，从而无法输出预期。</li>
<li>在对象内部读取数据时，应该直接通过实例变量来读，除惰性初始化技术之外。而写入数据时则应通过属性来写。</li>
</ul>
<h4 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h4><ul>
<li>检测对象的等同性，必须提供“isEqual:”和hash方法。相等的对象hash值必须相同，但是has值相同的对象未必相等。</li>
<li>计算hash值时应考虑减少碰撞。因为collection检索哈希表时会用对象的哈希值作为索引。hash方法的高效与低碰撞率可以使collection减少开销。</li>
<li>等同性判定的执行深度根据具体的对象决定，不一定将整个对象进行判定，有时候只需要判定代表对象唯一性的值即可。</li>
<li>在容器中放入可变类对象时，确保对象加入后就不再改变哈希值，否则容易造成未知行为。</li>
</ul>
<h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>
<li>类簇模式可以把实现细节隐藏在一套简单的公共接口后面。</li>
<li>系统框架中经常使用类簇，比如NSArray、NSNumber等。</li>
<li>从类簇的公共抽象基类中继承子类时，遵循几条规则：<ul>
<li>子类应该继承自类簇中的抽象基类。</li>
<li>子类应该定义自己的数据存储方式。</li>
<li>子类应当覆写超类文档中指明需要覆写的方法。</li>
</ul>
</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul>
<li>使用关联对象可以将两个对象以属性的方式关联起来，并指定类似于@property的内存管理语义和存储策略。</li>
<li>设置关联对象的键值是个“不透明指针”，若想令两个键值匹配到同一个值，二者必须是完全相同的指针才行。鉴于此，设置关联对象值时通常使用静态全局变量做键值。</li>
<li>由于关联对象容易引入难于排查的bug，所以不要轻易使用。</li>
</ul>
<h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><ul>
<li>objc_msgSend通过在运行期搜索接收者类的方法列表实现“动态绑定”，以选择子为key值搜索函数指针。</li>
<li>函数原型与objc_msgSend函数很像，在objc_msgSend函数内部搜索到选择子对应的函数并在函数最后return语句调用，利用“尾调用优化”进行优化。</li>
</ul>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><ul>
<li>消息转发分两大阶段：动态方法解析和完整的消息转发机制（分两阶段）</li>
<li>动态方法解析：实例对象收到无法解析的消息会触发类方法：+（BOOL）resolveInstanceMethod:(SEL)selector，如果是类对象对应的类方法为：+（BOOL）resolveClassMethod:(SEL)selector。在这个方法中可以通过class_addMethod动态插入方法，所添加的方法是用纯C函数（IMP指针）。</li>
<li>完整的消息转发机制第一阶段：调用函数-(id)forwardingTargetForSelector:(SEL)selector，看是否能把消息转发其他对象处理。通过此方案可以用“组合”来模拟”多重继承“的某些特性。</li>
<li>完整的消息转发机制第二阶段：- (void)forwardInvocation:(NSInvocation *)invocation;此阶段可以在转发消息前修改消息内容。若本类不处理，则需调用父类同名方法。</li>
</ul>
<p>###第4章 协议与分类</p>
<h4 id="23：通过委托与数据源协议进行对象间通信"><a href="#23：通过委托与数据源协议进行对象间通信" class="headerlink" title="23：通过委托与数据源协议进行对象间通信"></a>23：通过委托与数据源协议进行对象间通信</h4><ul>
<li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</li>
<li>当某对象需要从另外一个对象中获得数据时，可以使用委托模式【数据源协议】。</li>
<li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li>
</ul>
<h4 id="24：将类的实现代码分散到便于管理的数个分类之中"><a href="#24：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24：将类的实现代码分散到便于管理的数个分类之中"></a>24：将类的实现代码分散到便于管理的数个分类之中</h4><ul>
<li>使用分类机制将类的实现代码划分成易于管理的小块</li>
<li>将应该视为“私有”的方法归入名叫private的分类中，以隐藏实现细节。</li>
</ul>
<h4 id="25：总是为第三方类的分类名称加前缀"><a href="#25：总是为第三方类的分类名称加前缀" class="headerlink" title="25：总是为第三方类的分类名称加前缀"></a>25：总是为第三方类的分类名称加前缀</h4><ul>
<li>分类机制通常用于向无源代码的既有类中增加新功能，且分类中的方法会覆盖既有类的同名方法，后一个分类会覆盖前一个分类的同名方法。</li>
<li>为了减少同名函数覆盖的概率，以命名空间来区分各个分类的名称与其中所定义的方法，在Objective-C中实现命名空间的方法就是给分类名和函数名添加专用的前缀。</li>
</ul>
<h4 id="26：勿在分类中声明属性"><a href="#26：勿在分类中声明属性" class="headerlink" title="26：勿在分类中声明属性"></a>26：勿在分类中声明属性</h4><ul>
<li>属性是封装数据的方式，尽管可以通过关联对象的方式合成实例变量，但是建议最好全部在主接口中实现，分类的作用在于扩展类的功能，而非封装数据</li>
<li>除了“class-continuation分类【匿名分类】”之外可以定义属性，其他分类最好只定义方法</li>
</ul>
<h4 id="27：使用“class-continuation分类”隐藏实现细节"><a href="#27：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="27：使用“class-continuation分类”隐藏实现细节"></a>27：使用“class-continuation分类”隐藏实现细节</h4><ul>
<li>匿名分类可以定义方法和实例变量，原因在于“稳固的ABI”机制（详见第6条）</li>
<li>在实现块中添加匿名分类可隐藏实现细节，即私有变量和方法。</li>
<li>编译objective-C++时，在匿名分类中定义c++相关的变量，从而避免了因为在头文件中声明C++变量，进而导致凡是引用该类的其他类都必须改为Objective-C++类。</li>
<li>利用匿名分类扩展头文件中声明为“只读”的属性为“可读写”状态</li>
<li>利用匿名分类隐藏该类遵循的协议。</li>
</ul>
<h4 id="28：通过协议提供匿名对象"><a href="#28：通过协议提供匿名对象" class="headerlink" title="28：通过协议提供匿名对象"></a>28：通过协议提供匿名对象</h4><ul>
<li>使用协议可将具体的对象类型谈化成遵循某种协议的id类型，协议中规定了对象需实现的方法</li>
<li>如果对象类型不重要，重要的是对象是否实现了某些方法，此时可用“匿名对象”来实现这一概念，与Python的“鸭子类型”有点相似。</li>
</ul>
<p>###第5章 内存管理</p>
<h4 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h4><ul>
<li>悬挂指针：对象在release之后，内存被放回“可用内存池”，但是不一定保证马上被回收，此时指针属于悬挂指针，容易导致crash。</li>
<li>为了避免不经意间使用了悬挂指针，在调用完release之后清空指针</li>
<li>autorelease能延长对象生命周期，使其在跨越方法调用边界后依然跨越存活一段时间，释放操作会在清空最外层自动释放池时执行，即在当前线程进入下一次事件循环时释放。</li>
<li>通常采用“弱引用”来避免循环引用发生，从而避免内存泄漏</li>
</ul>
<h4 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h4><ul>
<li>Clang的静态分析器（static analyzer）不但可以指明程序中引用计数出现问题的地方，还能根据需要预先加入适当的retain和release操作以避免这些问题。自动引用计（ARC）数的思路也是源于此。</li>
<li>ARC在执行retain、release和autorelease等操作时，不是通过普通的Objective-C消息派送机制，而是直接调用其对应的C语言版本，这样效率更高。</li>
<li>ARC通过命名约定将内存管理标准化，方法名以下列词语开头，其返回的对象归调用者所有：<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy<br>否则，返回对象会自动释放，即相当于执行autorelease操作.</li>
</ul>
</li>
<li>在编译期和运行期，ARC都把能够相互抵消的retain、release、autorelease操作约简。</li>
<li>运行期，为了优化代码，在方法返回自动释放的对象时，调用objc_autoreleaseReturnValue,此函数会检视当前函数调用的代码是否需要对返回对象执行retain操作，如果是则设置一个全局标志位。而不执行autorelease操作；与只对应的是在调用代码如果要保留对象，则不执行retain操作，而是调用objc_retainAutoreleasedRetuenValue.此函数检测之前设置的全局标志位，如果已经置位，则不执行retain操作。</li>
<li>ARC环境优化方式具体实现由编译器决定，比如将全局标志位存储在STL(Thread Local Storage:线程局部存储，以key-value的形式读写)中，STL只适用于调用和被调用方都是ARC模式的情况，使用__builtin_return_address可以在被调用函数中获得调用函数的栈空间，进而可以推算出调用方后续操作是否调用了objc_retainAutoreleasedReturnValue，如果调用则是ARC环境，反之使用没优化的老逻辑。</li>
<li>变量的内存管理的边界问题，在设置变量值时，需要先保留新值，释放旧值，最后设置实例变量，确保即便是新值与旧值是同一对象也不能引发错误。在ARC情况下，无需考虑这种“边界情况”</li>
<li>ARC下清理实例变量是借用Objective-C++的析构函数实现的，不需要重载dealloc，如果存在CoreFoundation等非Objective-C对象时，只需在dealloc函数中执行CFRetain/CFRelease等释放操作，而不需要调用超类的dealloc方法。</li>
</ul>
<h4 id="第31条：合理使用dealloc方法"><a href="#第31条：合理使用dealloc方法" class="headerlink" title="第31条：合理使用dealloc方法"></a>第31条：合理使用dealloc方法</h4><ul>
<li>在dealloc中只释放对其他对象的引用，解除监听和取消订阅的KVO等，不要做其他事情</li>
<li>不要在dealloc中释放开销大或系统内稀缺资源，如文件描述符、套接字以及大块内存等，因为这些资源可能被其他对象持有，不宜保留过长时间，而是实现一个专门用于清理的函数，如close等</li>
<li>出于优化效率的目的，系统不能保证每一个对象的dealloc都会执行</li>
<li>不应在dealloc中调用执行异步任务的方法或只能在正常状态下执行的方法，因为dealloc所在的线程会执行final release。</li>
</ul>
<h4 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h4><ul>
<li>MRC环境下，在@try中创建的对象应在@finaly中释放而非@try中，以避免因抛出异常导致内存泄漏</li>
<li>ARC环境下，出于对运行期的性能考虑默认情况下是不会处理异常捕获过程中出现的内存泄漏情况。</li>
<li>ARC环境下，可以通过-fobjc-arc-exceptions这个编译标志开启安全处理异常功能，默认情况是关闭的，但是出于Objectve-C++模式下会自动打开。</li>
</ul>
<h4 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h4><ul>
<li>虽然垃圾回收机制可以检测并回收保留环，但是Mac OS X 10.8之后以及iOS平台不支持这个功能</li>
<li>MRC环境下，使用unsafe_unretained（表明属性不安全且不归实例所拥有）或者weak属性来避免保留环，且效果等同</li>
<li>ARC环境下，weak属性在修饰对象被回收后自动清空，更为安全，避免访问悬挂指针。</li>
</ul>
<h4 id="第34条：以“自动释放池块”降低内存峰值"><a href="#第34条：以“自动释放池块”降低内存峰值" class="headerlink" title="第34条：以“自动释放池块”降低内存峰值"></a>第34条：以“自动释放池块”降低内存峰值</h4><ul>
<li>GCD或主线程都默认自带自动释放池。</li>
<li>自动释放池是以栈的形式存在的，对象收到autorelease消息后，会被放入最近的自动释放池的栈顶。</li>
<li>合理运用自动释放池，用以降低应用程序的内存峰值，如for循环中。</li>
<li>ARC环境下的@autoreleasepool比MRC环境下NSAutoreleasepool更为轻便与安全。</li>
</ul>
<h4 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h4><ul>
<li>向已回收的对象发送消息是不安全与不稳当的，如果内存已经被复用且复用的对象不能响应此消息则会crash，如果复用对象能够响应消息也许输出不能达到预期，如果内存部分存活则可能消息可能依然有效。</li>
<li>“僵尸对象”是调试内存管理问题最佳方式。</li>
<li>僵尸类是从名为_NSZombie_的模板类复制而来，通过创建一个名为_NSZombie_原类名的新类，再将已回收对象的指针指向新类，原对象的类变了，但是内存结构不变，便于调试。示例代码：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line"><span class="keyword">if</span> (!zombieCls) {</span><br><span class="line">	<span class="keyword">class</span> baseZomeCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</span><br><span class="line">	zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Perform normal destruction of the object being deallocated</span></span><br><span class="line">objc_destructInstance(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//Set the class of the object being deallocated to the zombie class</span></span><br><span class="line">objc_setClass(<span class="keyword">self</span>, zombieCls);</span><br></pre></td></tr></tbody></table></figure>
<p>代码的关键在于：对象的内存没有释放，因此这块内存不可被其他对象复用，虽然会造成内存泄漏，但是出于调试的目的可以忽略。</p>
<ul>
<li>僵尸类的作用是通过消息转发机制体现，因为僵尸类没有实现任何方法，和Object一样是根类，只有一个实例变量isa。在消息转发机制通过类名检测到当前对象是一个僵尸对象时会进行特殊处理：打印原类的相关信息，然后终止程序。示例代码：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="comment">//If so, this is a zombie</span></span><br><span class="line"><span class="keyword">if</span> (string_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) {</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd));</span><br><span class="line">	</span><br><span class="line">	Log(<span class="string">"*** - [%s %s]: message sent to deallocated instance %p"</span> , originalClsName, selectorName, <span class="keyword">self</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h4><ul>
<li>retainCount返回的保留计数只是某个给定时间点上的值，并未考虑到对象加入自动释放池的情况，因此不能反映真实的保留计数。</li>
<li>有时系统出于优化的目的，retainCount可能永远都不返还0，在保留计数为1的时候就被回收了。</li>
</ul>
<p>###第6章 块与大中枢派发</p>
<p>####第37条 理解“块”这一概念</p>
<ul>
<li>块在定义与使用方面与函数类似，但是块本身是一个对象，有引用计数。</li>
<li>在块中直接访问实例变量，虽没有显性使用self，但是self变量还是会被块捕获。</li>
<li>块的内存结构中，最重要的是invoke函数指针，指向块的实现代码，第一个void *参数指代块，用于访问块对象所捕获的变量。此外descriptor变量指向结构体指针，每个块里都包含此结构体，其中声明了块对象的总大小和copy与dispose两个辅助函数的指针。</li>
<li>根据内存位置分为全局块、栈块和堆块。</li>
<li>栈块只在定义氛围有效，下述代码存在一个比较隐蔽的错误，存在危险：块的内存都分配在if及else范围内，在离开相应范围后如果编译器覆写了分配给块的内存则会导致crash，否则正常运行。</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">	block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); };</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">	block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//解决方式：将块拷贝到堆中，成为堆块</span></span><br><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">	block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">	block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol start="6">
<li>在全局范围声明的块及为全局块，其所使用的内存区域也在编译器全部确定。</li>
</ol>
<h4 id="第38条-为常用的块类型创建typedef"><a href="#第38条-为常用的块类型创建typedef" class="headerlink" title="第38条 为常用的块类型创建typedef"></a>第38条 为常用的块类型创建typedef</h4><ul>
<li>以typedef重新定义块类型，可令块变量用起来更简单</li>
<li>定义新类型时应遵循现有的命名习惯，勿使其名称与别的类型相冲突。</li>
<li>可以为同一个块签名定义多个类型的别名，便于理解类型的用途。</li>
</ul>
<h4 id="第39条-用handler块降低代码分散程度"><a href="#第39条-用handler块降低代码分散程度" class="headerlink" title="第39条 用handler块降低代码分散程度"></a>第39条 用handler块降低代码分散程度</h4><ul>
<li>异步任务执行完成之后，可使用委托协议或者内联块。相比于委托代理，块更为简洁和聚合。</li>
<li>建议使用同一个块来处理成功与失败的情况。</li>
<li>设计API时如果用的了handler块，可以增加一个参数，使调用者可通过此参数来决定块执行的队列。</li>
</ul>
<h4 id="第40条-用块引用其所属对象时不要出现保留环"><a href="#第40条-用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条 用块引用其所属对象时不要出现保留环"></a>第40条 用块引用其所属对象时不要出现保留环</h4><ul>
<li>如果块所捕获的对象直接或者间接地保留了块本身，那么得注意是否存在保留环的问题。</li>
<li>一定要找个适当的时机解除保留环，而不能把责任推给API调用者。</li>
<li>网络下载器可在任务启动时将自己加入全局的容器对象中，在任务结束后移除，从而保证自己在任务执行期间存活的同时不需要API调用方引用，大部分网络通信库都是采用这办法，如Twitter框架的TWRequest对象。</li>
</ul>
<h4 id="第41条-多用派发队列，少用同步锁"><a href="#第41条-多用派发队列，少用同步锁" class="headerlink" title="第41条 多用派发队列，少用同步锁"></a>第41条 多用派发队列，少用同步锁</h4><ul>
<li>同步块@synchronized(obj)会根据给定对象自动创建一个锁，锁在代码块执行完成释放。由于给定对象相同，那么意味着它们使用的同一个锁，代码块需按顺序执行。如果在两个或多个没有逻辑关联的代码块给同一个对象加锁，会影响执行效率。</li>
<li>滥用@synchronized(self)很危险，因为所有同步块都会彼此抢夺同一个锁。示例：使用@synchronized实现属性的原子性（atomic）：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">return</span> _someString;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		_someString = someString;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果有很多属性都是类似写法，那么每个属性的同步块都要等其他同步块执行完成才能执行。理想情况应该是属性各自独立地同步。</p>
<ul>
<li>使用GCD实现属性原子性：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">		localSomeString = _someString;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{  </span><br><span class="line">		_someString = someString;</span><br><span class="line">	});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>GCD版本优化：设置方法不需要返回值，所以并不一定非得同步；获取方法可以并发执行，且设置方法与获取方法之间不能并执行。</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//异步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">	<span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">		localSomeString = _someString;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//异步队列+异步派发（同步派发可能效率更高，原因在于异步派发需要拷贝块，如果拷贝时间超过代码执行时间，则得不偿失。异步派发适合较为复杂的任务）+栅栏块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line">	<span class="comment">//栅栏块会单独执行，执行前会等待当前所有并发块执行完成，避免出现读写竞赛</span></span><br><span class="line">	dispatch_barrier_async(_syncQueue, ^{  </span><br><span class="line">		_someString = someString;</span><br><span class="line">	});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h4 id="第42条-多用GCD，少用performSelector系列方法"><a href="#第42条-多用GCD，少用performSelector系列方法" class="headerlink" title="第42条 多用GCD，少用performSelector系列方法"></a>第42条 多用GCD，少用performSelector系列方法</h4><ul>
<li>performSelector系列方法在内存管理方面容易有疏忽，由于无法确认将要执行的选择子是什么，因而ARC编译器无法插入适当的内存管理方法。</li>
<li>performSelector系列方法所能处理的选择子有局限性，选择子的参数个数与类型以及返回类型都受到限制。</li>
</ul>
<h4 id="第43条-掌握GCD及操作队列的使用时机"><a href="#第43条-掌握GCD及操作队列的使用时机" class="headerlink" title="第43条 掌握GCD及操作队列的使用时机"></a>第43条 掌握GCD及操作队列的使用时机</h4><ul>
<li>对于只需要执行一次的代码来说，GCD的dispatch_once是首选，但是执行后台任务则可以考虑NSOperationQueue。</li>
<li>在iOS4与Mac OSX 10.6开始，操作队列在底层是用GCD来实现的。</li>
<li>GCD是纯C的API，任务使用轻量级数据结构块来表示；操作队列则是Objective-C的对象，采用更为重量级的NSOperation对象执行任务。</li>
<li>使用操作队列的优势：<ul>
<li>可取消还未启动的任务</li>
<li>可指定操作间的依赖关系</li>
<li>可通过键值观测机制监控NSOperation对象的属性</li>
<li>可指定操作的优先级，而GCD只能指定队列的优先级</li>
<li>可重用NSOperation对象</li>
</ul>
</li>
<li>是否使用底层实现方案还是高层API，可通过实际性能测试来确定。</li>
</ul>
<h4 id="第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条 通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第44条 通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul>
<li>一系列的任务可归入一个dispatch group中，开发者可以在所有任务完成后获得通知</li>
<li>利用dispatch group并发地执行多项任务。</li>
<li>dispatch_apply是持续阻塞的，直到所有任务都执行完成。</li>
</ul>
<h4 id="第45条-使用dispatch-once来执行只需要运行一次的线程安全代码"><a href="#第45条-使用dispatch-once来执行只需要运行一次的线程安全代码" class="headerlink" title="第45条 使用dispatch_once来执行只需要运行一次的线程安全代码"></a>第45条 使用dispatch_once来执行只需要运行一次的线程安全代码</h4><ul>
<li>dispatch_once采用“原子访问”来判断块中的代码是否已经执行过，而非使用重量级的同步机制，相比于@sychronized更为高效，如果想了解@synchronized的实现机制可以看看<a target="_blank" rel="noopener" href="http://icebergcwp.com/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html">这篇博客</a>。</li>
<li>标记dispatch_once_t应该声明为static，确保每次调用都复用同一个变量。</li>
</ul>
<h4 id="第46条-不要使用dispatch-get-current-queue"><a href="#第46条-不要使用dispatch-get-current-queue" class="headerlink" title="第46条 不要使用dispatch_get_current_queue"></a>第46条 不要使用dispatch_get_current_queue</h4><ul>
<li>dispatch_get_current_queue已被废弃，只应做调试使用</li>
<li>派发队列是按层级来组织的，子队列是包含于父队列的，所以无法单用某个队列对象来描述“当前队列”这一概念</li>
<li>dispatch_get_current_queue用于解决由不可重入代码所引发的死锁，可以使用“队列特定数据”来解决：dispatch_queue_set_specific(dispatch_queue_t queue,const void *key, void *context, dispatch_function_t destructor);</li>
</ul>
<h3 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h3><ul>
<li>标准根类NSObject属于Foundation框架，而非语言本身。如果不适应Foundation框架，则需要自己实现根类</li>
</ul>
<h4 id="第47条-熟悉系统框架"><a href="#第47条-熟悉系统框架" class="headerlink" title="第47条 熟悉系统框架"></a>第47条 熟悉系统框架</h4><ul>
<li>在众多框架中，Foundation和CoreFoundation这两个框架最为重要，提供了许多核心功能</li>
<li>Objective-C编程经常会使用纯C实现的框架，比如CoreFoundation，里面用到底层C语言级API，这样可以绕过运行时系统，提升速度，但是需要手动管理内存。</li>
</ul>
<h4 id="第48条-多用块枚举，少用for循环"><a href="#第48条-多用块枚举，少用for循环" class="headerlink" title="第48条 多用块枚举，少用for循环"></a>第48条 多用块枚举，少用for循环</h4><ul>
<li>遍历collection有四种方式。最基础的是for循环，其次是NSEnumerator遍历和NSFastEnumeration协议下的快速遍历，最快、最先进的方式是“块枚举发”</li>
<li>“块枚举法”本身能够通过GCD来并发执行遍历，无须另行代码，其他遍历方式则不能做到这一点</li>
<li>如果提前知道遍历collection中的对象，应修改块签名，指出对象的具体对象。</li>
</ul>
<h4 id="第49条-对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条 对自定义其内存管理语义的collection使用无缝桥接"></a>第49条 对自定义其内存管理语义的collection使用无缝桥接</h4><ul>
<li>Foundation框架中的collection类都有与之对应的CoreFoundation框架版的C语言API</li>
<li>桥接符号__bridge表示ARC保留对Objective对象的所有权，而__bridge__retain则刚好相反，需要使用CFRelease释放内存。</li>
<li>使用CoreFoundation框架可以创建出Foundation框架所不具备的功能，比如NSDictionary的键值内存管理语义是“copy”，即键值必须支持Copying协议，使用CoreFoundaition创建一个键值内存管理语义为“Retain”的CFDictionary。</li>
</ul>
<h4 id="第50条-构建缓存时选用NSCache而非NSDictionary"><a href="#第50条-构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第50条 构建缓存时选用NSCache而非NSDictionary"></a>第50条 构建缓存时选用NSCache而非NSDictionary</h4><ul>
<li>实现缓存时应选NSCache而非NSDictionary对象。NSCache提供了优雅的自动删减功能，而且线程安全。此外，它与字典不同，不会拷贝键值，而是retain一次。</li>
<li>可以给Cache对象设置上限：缓存对象总个数和缓存总大小，这些设置定义了缓存删减其中对象的时机。但是这些设置仅对Cache起指导作用，并非一定在系统资源紧张时删减Cache中的某个对象，因此不能通过设置上限来迫使Cache优先删减某个对象。</li>
<li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据功能，也就是说当NSPurgeableData对象所占内存被系统丢弃时，对象也会从缓存中移除。</li>
<li>缓存的设计初衷是为了提高响应速度，只有那些“重新计算起来费劲”的数据才值得放入缓存，比如网络获取或者磁盘读取的数据。</li>
</ul>
<h4 id="第51条-精简-initialize与-load的实现代码"><a href="#第51条-精简-initialize与-load的实现代码" class="headerlink" title="第51条 精简+initialize与+load的实现代码"></a>第51条 精简+initialize与+load的实现代码</h4><ul>
<li>在加载过程中，如果类实现了+load方法，那么系统会通过函数指针调用+load。调用顺序是父类-&gt;子类-&gt;分类。因为程序加载时是使用函数指针调用而非消息机制，所以分类中的+load不会覆盖子类中的+load方法。         </li>
<li>程序启动时，运行期处于“脆弱状态（fragile state）”，如果+load方法中使用了其他非系统库（系统库的类在这之前已经加载好了）的类，那么这些类的+load方法也在此时被调用。如果子类没有实现+load方法，那么各级超类是否实现此方法都不被系统调用。</li>
<li>+load方法务必实现的精简一些，因为整个程序在+load方法时都会阻塞。其真正的用途在于调试程序。</li>
<li>+initialize方法会在程序首次调用该类之前调用，只调用一次，如果某个类未被使用，那么其+initialize方法一直不会被调用。</li>
<li>+initialize方法被调用时，运行期系统已经处于正常状态，理论上可以在其中调用任何类的任意公开方法，且是线程安全的。</li>
<li>+initialize方法与其他消息一样，如果子类未实现它而其超类实现了，那么会子类也会调用一次超类的实现方法。 </li>
<li>无法再编译器设定的全局变量，可以放在+initilize方法中初始化。</li>
</ul>
<h4 id="第52条-别忘了NSTimer会保留其目标对象"><a href="#第52条-别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条 别忘了NSTimer会保留其目标对象"></a>第52条 别忘了NSTimer会保留其目标对象</h4><ul>
<li>NSTimer对象会保留其目标，知道计时器调用invalidate方法后失效为止。另外，一次性的计数器在触发任务后就会立即失效。</li>
<li>反复执行任务的计时器，很容易引入保留环，可通过扩充NSTimer功能，用块来打破保留环。代码如下：</li>
</ul>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats;</span><br><span class="line">+ </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats {</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimerInterval:interval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(eoc_blockInvoke:) userInfo:[block <span class="keyword">copy</span>] repeats:repeats];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eco_blockInvoke:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line">	<span class="keyword">void</span>(^block)() = timer.userInfo;</span><br><span class="line">	<span class="keyword">if</span> (block) {</span><br><span class="line">		block();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```                    </span><br><span class="line">这个方法仍然存在保留环，计时器现在的target是<span class="built_in">NSTimer</span>类对象，但是因为类对象无需回收，所以不用担心。</span><br><span class="line"></span><br><span class="line">* 上述方法本身不能解决问题，但是提供了解决问题的工具。使用分类中的eoc_scheduledTimerWithTimeInterval来创建计时器：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">void</span>)startPolling {</span><br><span class="line">	__<span class="keyword">weak</span> type(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">	_pollTimer = [<span class="built_in">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class="number">1.0</span> block:^{ </span><br><span class="line">	EOCClass *strongSelf = weakSelf;</span><br><span class="line">	[strongSelf p_doPoll]; </span><br><span class="line">	} repeats:<span class="literal">YES</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-08-03T15:50:07.000Z" title="8/3/2017, 11:50:07 PM">2017-08-03</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B9%A6%E8%AF%84/">书评</a></span><span class="level-item">an hour read (About 7445 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/08/03/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《人类简史》第一部分认知革命读书笔记</a></h1><div class="content"><h4 id="人类：只是一种普通的动物"><a href="#人类：只是一种普通的动物" class="headerlink" title="人类：只是一种普通的动物"></a>人类：只是一种普通的动物</h4><p>一直以来，我和很多人一样以为地球同一时期只有一种人类且是独特于其他的物种之外的特殊物种，不然怎么会站在了食物链的顶端。现在我才知道这种想法是错误的，其实我们现代人即智人（human sepiens）只是人属的一种，就像豹属包括狮子，豹子等。人属也包括多个物种，只是现存的人种只有智人，就容易让人造成智人是唯一人种的假象。</p>
<p>早在250万年前人类开始由猿属中的南方古猿开始演化，人类的足迹在200万年前开始从东非欧亚大陆扩散，结合当地的环境各自演化出不同的人种，有匠人、鲁道夫人、尼安德特人、直立人、梭罗人等等。这些人分别先后出现，并在某一段时间同时存在地球的不同地方。其中，直立人出现时间是200万年前到5万年前，存活了将近200万年，是目前所知存续时间最长的人类物种，目前地球上唯一的人种智人已知的是大约15万年前在非洲出现，具体何时、有何种早期人类演化而来无从得知，就目前的发展来看是很难打破直立人存续的记录了。此外，这些人种的演化并不是呈线性发展的，这些人种在大约200万年前到大约一万年前之间同时存在世界各地，各种进化或灭亡，直到一万年前左右，仅剩下智人一种人类。</p>
<p>人类比其他物种有一个共同特征就是脑容量大。然而庞大的大脑也是庞大的负担，大脑不仅结构脆弱且消耗能量巨大，占身体体重约2%~3%却消耗能量占25%。时至今日，大脑发达带来的好处显而易见，但是远古人类为此付出一定的代价，主要包括两种：一是人类需要更多的食物满足热量需求，其次就是为了保证大脑能量供需导致肌肉退化萎缩。至于为什么人类大脑会在200万年间不断演化，无从得知。</p>
<p>人类另外一个共同特征就是直立行走，直立行走将手从移动的功能中分离出来，着重神经发展，进一步演化成可以处理精细任务。与此同时，直立行走也有不利之处。直立行走意味着脊椎需要支撑一个超大的头盖骨，为此需要面对背痛与颈椎脖子疾病。特别对妇女造成的负担更大，直立行走需要让臀部变窄，然而根据人类演化趋势，婴儿的头越来越大，从而导致分娩风险增高。于是，根据自然选择的原理，在婴儿还尚未完全发育之前分娩，这时候头部毕竟小且柔软，风险也会降低很多。所以，相对于其他物种，人类都是早产儿，许多重要的器官都未发育完善，出生之后需要母亲的悉心呵护与培养。这也是导致人类发展出突出的社交技巧的原因之一。正因为小孩出生后需要长时间的抚养，作为母亲必须依赖于家族部落的协助才能获得足够的食物，为此需要一种能够形成强大的社会关系的能力。此外，人类出生后的发育不完善也意味着更好的可塑性，需要外界的教育，这也依托于强大的社会化的背景。正因如此，人类的性格、信仰和价值观等观念才会各种各异，才有基督徒或佛教徒，自由主义者或民族主义者，好战派或和平派。</p>
<p>尽管人类拥有超强的大脑，但是在过去的200万年前，人类一直都是一种弱小、边缘化的物种。直到10万年前，智人这一人类物种崛起，一跃而居于食物链的顶端才结束弱者的命运。然而，这次仓促的跳跃对整个生物链造成了巨大的影响。在此之前其他处于食物链顶端的物种都是经过好几百万年的进化才站上了顶峰，因此生态系统有足够的时间协调各物种之间的平衡。相比之下，智人在很短的时间内一步青云，让生态系统猝不及防，人类本身也不知所措，为此付出的代价就是人类史上众多的灾难。</p>
<p>在人类踏上食物链顶端的路上，火的使用功不可没。早在80万年前部分人类偶然的机会学会使用火，到了30万年前直立人、尼安德特人以及智人的祖先已经能够熟练的使用火。火之于人类有两大主要好处：一是烹饪食物，烹饪食物不仅扩大了食物来源，使原本不可直接使用的食物，比如小麦、马铃薯等食物再烹饪供人类使用。此外烹饪让食物发生化学反应，同时对食物进行高温消毒，大大地减少了人类咀嚼与消化食物的时间。这样不仅让人类的牙齿缩小，肠道缩短，还能提供更多的热量供大脑发育。第二个好处是火可以成为御敌的工具，不同于其他动物经过数百万年进化而来的利爪或翅膀，这些功能都无法突破先天的身体限制，而火是一种可操作且力量无穷的工具，为人类更好的存续提供了保障。</p>
<p>在200万年前<del>1万年前，地球上的还存在多个人类物种，但是随着智人的出现以及扩散，其他物种先后走上了灭绝的道路。每当智人到达某个地方，当地原本的人种就在不久之后消失了。究其原因，有两种大相径庭的理论。一是“混种繁衍理论”，即智人与其他人种混种繁衍，最终形成了现代的人类。另外一种则是“替代理论”，即不同物种之间处于争夺资源与排外的情绪，互相厮杀，最终智人取得了胜利，替代了原有人类。最近数十年，替代理论一直是大致共识，不仅因为有考古证据支持，政治上也更为正确。如果非洲人、欧洲人和亚洲人是智人与不同人类物种的混种后代，那么基因上的差异也会很大，那么在政治、民族等多个方面的理解也会存在差异，从而导致种族间的大冲突，然而现实情况并非如此。然而，混种繁衍理论也并非没有可能。最近的一些研究发现中东和欧洲人有%1</del>%4尼安德特人的基因，澳大利亚原住民和现代美拉尼西亚人有6%的丹尼索瓦人的基因。如果这些发现属实，则说明混种繁衍理论至少是部分正确，有可能在某个时间点，不同人种还属于同一人种的不同族群，即使族群差异到了一定程度，但是仍然可以交配产下后代，再经过进一步演化才彻底切断彼此连接，形成两种不同的物种，也就不能再混种繁衍了。也许在物种分化的某个灰色地带，尼安德特人与智人在即将演化成两个不同的物种之前发生了混种繁衍，并产生了新的人类，导致智人的基因中残存着尼安德特人的DNA。</p>
<p>按照自然选择的规律来说，尼安德特人比智人进化的更完善，有更大的大脑和更发达的肌肉。但是结果却是智人存活了下来，而尼安德特人在地球消失了。智人最终成为最后的人类，战胜了其他人类物种的真实原因不得而知，但是有一个很有说服力的解答，那就是：智人有独特的语言。</p>
<h4 id="知善恶树"><a href="#知善恶树" class="headerlink" title="知善恶树"></a>知善恶树</h4><p>在距今7万~3万年前，智人发生了认知革命，具体原因不得而知，普遍认为是某次基因突变，改变智人大脑内部连接方式，从而改变了智人的思维方式与沟通语言能力。智人的语言并不是世界上第一种语言，每种动物都有其交流的语言，并且有其精密复杂的结构。然而，智人的语言较于其他动物的语言，它更为灵活，通过有限的词汇排列组合，可以产生无限多的句子和含义，从而大幅度提高了交流的效率。另外智人的语言有“八卦”和“虚构”的功能。</p>
<p>智人可以通过“八卦”功能让部落规模变得更大。在一般的动物族群里，成员数量一般在20~50左右。族群的团结依赖于首领的管理与威望。一旦族群扩大，族群内部就会发生动摇，最后造成分列。即便如此，八卦维系的规模也是有限制。社会研究学家指出，借由八卦维持的最大“自然”团体一般是150人。原因在于超过这个数之后，团体之间就不能深入了解和八卦彼此的生活情况。然而，事实是智人突破了这个界限，创造出了城市、国家等这些有成千上万成员的团体。其原因很可能在于智人的语言的“虚构”功能，能够虚构一些现实中不存在的事物，“虚构”这一功能不仅可以让智人拥有想象，更重要的意义在于可以让大家一起想象，共同相信某个虚构的事物，从而可以共同合作。现实生活中，很多的概念都是虚构的，包括国家，民族，宗教，金钱，法律，人权，正义等等。只是我们现代人从出生就接触这些概念，根本没怀疑它们的真实性，更不会发觉它们只是存在我们共同的想象之中。</p>
<p>在没有发生认知革命之前，智人和其他具有社会行为的动物一样，行为有相当的程度是有基因决定的。因此，一旦出现社会结构改变、发明新科技或者移居都是因为基因突变或者环境改变导致的。正因如此，远古人类没有什么革命性的改变。然而，智人出现认知革命之后，可以基于某个虚构的故事让大批互不相识的人有效的进行合作，而且只要改变虚构故事的内容，合作的方式也随之改变。这意味着智人找到了一条绕开基于组的快车道，可以迅速改变社会结构和发展速度。</p>
<p>认知革命通过虚构故事创造了很多想象现实，也发展处许多的行为模式，这成为我们所谓的“文化”的主要成分。文化出现之后，无法停止地继续改变和发展，就成了我们所谓的“历史”。认知革命正是历史从生物学中脱离而独立存在的起点。在此之前，所有人类的行为属于生物学的范畴，因为都是有基因主导的。换言之，智人生存在一个双重现实的社会中，一方面是客观存在的现实，即生物的范畴，另外一方面的虚构的现实，即历史和文化的范畴。生物学与历史的关系可以简化为三点：<br>1、基本上，生物学为智人的行为和能力设下了基本限制，设定了一个活动范围，所有的历史都在这个范围之内发生。</p>
<p>2、然而，这个范围非常大，能让智人有各种惊人的发挥空间，让虚构故事的能力和虚构的故事不断发展精进。</p>
<p>3、想了解智人的行为，就必须描述人类行为的历史演化，而不能只考虑人类在生物上的限制。</p>
<p>智人通过认知革命发展出独特的语言，无异于获得了《圣经》里面那个知善恶树的果实，从此改变了智人的命运，智人摇身一变成为了亚丹和夏娃。</p>
<h4 id="亚丹和夏娃一天"><a href="#亚丹和夏娃一天" class="headerlink" title="亚丹和夏娃一天"></a>亚丹和夏娃一天</h4><p>在智人的历史上，绝大多数时间都是靠采集为生。相比于几万年时长的采集生活，智人已知或者现存的生活方式不足以改变人类的思维方式。换言之，现代人类早在农业时代之前的采集时代就开始塑形，我们的大脑和内心的思维方式仍停留在以狩猎和采集的时代。农业革命之后，人类大脑的进化速度远不及周围生活环境的发展速度，造成了一种物质世界与内心世界脱轨的普遍现象。</p>
<p>这种现象影响这现代人生活的方方面面，狩猎采集时代的思维方式深植于我们的潜意识中。其中包括是已经得到广泛接受的“贪吃基因”理论和颇具争议的“一夫一妻制”。远古人类在那个甜食匮乏的时代为了获得更多的热量会偏爱高热量的甜食，导致物质丰富的现代人不知觉地喜爱甜食，造成肥胖等疾病。</p>
<p>因此，想要更好地了解我们自己、我们的社会和政治，就需要更了解我们祖先的生活条件。然而，我们对于采集者祖先的生活几乎没有可以确定的事实。目前普遍的研究方法有两种，一是考古学研究，通过远古社会遗存的文物进行推断。然而远古的狩猎采集生活用具保存下来的大都是骨骼化石和石器，其他容易腐烂的材料都无从考证，另外远古人类没有固定的生活居住地，而是不断的迁移，所以很少使用人造物品。因此，通过现存文物来还原远古人类的生活必定会有偏差；另外一种研究方式是人类学观察，通过研究现存的采集社会来推测远古采集社会的样貌。首先，现存采集社会多少已经受到周围的农业或者工业社会影响，不可同日而语。其次，现存的采集社会之所以能够存活到现在，是因为它们都位于气候恶劣或者地形险峻的地区，从而逃避了农业与工业社会的侵蚀，这与远古富饶地区的采集社会不论在人口规模和生活方式上都存在差异。再者，狩猎采集社会最显著的特点就是它们彼此之间的差异很大，各有特色。因此，通过人类学方式观察现存的采集社会只能帮助我们了解部分远古采集社会的可能性，而非全貌。</p>
<p>根据现有的证据，我们对远古采集社会虽然只有管中窥豹的认识，但是也能获得一些可靠的推断。首先，他们大部分人都是生活在小部落里面，且所以成员都是人类，而不同于农工社会中，存在家禽家畜的数量超过人类的社会群体。远古采集社会没有家禽家畜，但是有狗的存在，狗是第一种由智人驯化的动物，狗与人类的感情远超过人类与其他动物之间的感情。此外，同属一个部落的成员彼此熟悉，终其一生都生活在一起，没有孤单和隐私。不同的智人部落之间偶尔会有交流与交换物品，大多数时间都是互相独立，各行其是。大多数智人部落都是处于不断迁移的状态，只有很少的部落在食物富饶的地区会选择永久定居。远古智人部落与农业革命以后的人类的生活方式的差异主要有以下几点：<br>1、远古智人有着多样化的饮食结构，不依赖单一的某种食物，饮食结构更灵活，相比之下我们的饮食显得单一固定，容易受自然灾害影响；<br>2、整体而言，现代人类的知识范围远超远古人类，但是个人层面，远古智人是有史以来具备最多知识与生存技能的人类；<br>3、狩猎采集的生活方式更为轻松与舒适，不像现代人那样忙碌；<br>4、远古智人没有像现代人那样饱受传染病的困扰，原因在于多数传染病都是来自家禽家畜，采集社会只有狗是唯一会和人类近距离接触的动物。另外，采集社会人口密度小且分散，疾病不易传播流行。</p>
<p>正因为远古采集者有着比现代人更健康和多样的饮食结构，更短的工作时间，更少的传染病困扰。因此被定义为“最初的富裕社会”。但是这并不表示远古采集社会是理想与美好的，它们同样存在着残酷的一面，存在物资匮乏、族群相杀、时节难过以及儿童死亡率高等问题。有时候，他们会杀害儿童、病人和老人，但是他们的想法其实和现在许多人赞同堕胎和安乐死没有区别。远古的狩猎采集者和我们一样，都是人类。</p>
<p>除了生活方式与环境上的差别，远古采集者的心理和精神世界又是如何？多数学者都同意，远古采集者普遍信奉泛神论的信仰（animism，源自拉丁文anima，意为灵魂或精神）。泛神论相信，几乎任何一个地点、任何一只动物或植物、任何一种自然现象，都有其意识和情感，并且与人类之间没有障碍，可以直接通过语言、歌曲、舞蹈和仪式沟通。泛神论的一个特点在于所有的灵都只限于当场当地，某个具体的事物，而非万能的神。泛神论不是特定的宗教，而是数千种不同宗教、邪教或信仰的统称，这些宗教对于世界的看法、对于人类的定位都大同小异。然而，远古采集者是否一定都是泛神论我们无从得知。此外，采集社会是否存在政治，这一点也无法确定。尽管有考古发现一些具有“阶级”意味的表象，虽然具体原因不得而知，但是仍能说明3万年前的智人已经发明了一些社会政治规范，不仅超出了DNA的设定，也超越了其他人类和动物的行为模式。</p>
<p>最后，“战争”在远古采集社会扮演什么样的角色？有学者认为战争是出现在农业革命之后，伴随着私有财产而生。而另外一种主张则认为采集社会已经有各种残忍的暴力事件。然而不管是通过考古学研究还是人类观察学推测，都是无法还原远古采集社会的真实面貌，所以不能一概而论。采集社会可能有许多不同的宗教和社会结构，不同的地区和不同时段的生活情况也大相径庭，或存在暴力或平静祥和。</p>
<p>由于证据的缺乏，远古采集社会的很多事情都无法确定，我们也就无法重建出一副当时的宏观景象，更不用说重塑特定的事件。关于远古采集社会的很多问题，我们都只能沉默以对。这幅沉默的帷幕笼罩了几万年的人类历史，也许会一直尘封，也许未来出现新的研究工具可以揭开这幅厚重的帷幕。我也不能因为对远古采集社会知之甚少便否定远古智人对人类历史的贡献，不能对于7万年人类历史中的六年视而不见。他们做了很多重要的事情，特别是形塑了我们现有的世界，程度之大出乎意料，他们的足迹早已遍布全世界。整个动物界从古至今，最重要也是最具破坏性的力量，就是这群四处游荡、讲着故事的智人。</p>
<h4 id="毁天灭地的人类洪水"><a href="#毁天灭地的人类洪水" class="headerlink" title="毁天灭地的人类洪水"></a>毁天灭地的人类洪水</h4><p>在认知革命前，所有的人类物种都只住在亚非大陆。那时候地球不同的洲都有自己独特的生态系统和物种，但是随着智人在认知革命之后掌握了航海技术，智人的足迹开始遍布全球各地，对当地的生态与物种来说是致命的灾难，很多物种遭受灭绝，智人就如同毁天灭地的洪水一般“征服”全球。其中，澳洲大陆与美洲大陆都是血淋淋的例子。</p>
<p>大约在45000年前，智人首次抵达与亚非大陆相遇深远且隔海相望的澳洲大陆绝对是一件跨时代的大事，重要性不亚于哥伦布发现美洲大陆或是人类首次登月。这意味着海洋这个阻挡智人扩张最大的障碍也被征服了。随着智人来到澳洲大陆的那一刻起，曾经在这块土地生活了数万年甚至上百万年的物种都消失殆尽。其中澳大利亚当时24中50公斤以上的动物有23中都惨遭灭绝，许多比较小的物种也从此消失，整个澳大利亚的生态系统食物链重新洗牌，这也是澳大利亚生态系统数百万年来最重大的一次转型。</p>
<p>有些学者试着以气候变迁为借口为人类脱罪，然而有三大证据显示智人难辞其咎。</p>
<p>证据一：虽然澳大利亚气候确实在45000年前有一场改变，但是规模幅度不大。更何况在此之前，地球早就经历过许多次更为严重的冷却和暖化循环，在过去百万年间，平均每10万年就有一场冰河时期。换句话说，澳大利亚上的物种在45000年前早就经历过多次气候变迁，并且大多数都存活下来了。然后，45000年以后，全澳大利亚超过90%的巨型动物都从历史消失。如果说智人所有的巨型动物都恰巧死于严寒之后来到澳大利亚，实在很难令人信服。</p>
<p>证据二：如果是气候变迁导致物种灭绝，那么海洋生物受到的冲击通常不亚于陆地生物。然而，我们没有找到任何证据显示在45000年前海洋生物有显著的灭绝情形。如果假设智人的罪魁祸首，那么也很容易解释这波灭绝浪潮只席卷了陆地生物，而放过了附近的海洋生物。因为那时候智人虽然航海技术有大幅度提升，但是人类毕竟还是主要生活在陆地。</p>
<p>证据三：类似澳大利亚这种物质大面积灭绝的案例在接下来的几千年在不同的地点不断上演，而时间点都是在人类首次抵达的时候。</p>
<p>通过上面列出的三个证据，智人对与类似澳大利亚这样物种大灭绝的惨案的频繁上演难辞其咎。当时智人的生活与狩猎工具还是以石器为主，那么他们是如何主导这次生态浩劫的？以下有三种解释：</p>
<p>第一种解释：一般来说大型动物繁殖缓慢，孕期长，胎数少，怀孕周期长。因此就算智人猎杀不频繁，也可能会导致某个物种的死亡率高于出生率，最后导致这个物种的灭绝。</p>
<p>第二种解释：认为智人抵达澳大利亚的时候已经掌握了火耕技术。面对陌生而危险的环境，他们会刻意地烧毁难以跨越的森林，将地貌变成开阔的草原以适合人类的需求。他们在短短的几千年就彻底改变了澳大利亚大部分地区的生态系统。这种说法有植物化石记录为佐证。在45000年前，桉属植物在澳大利亚只是少数，智人的到来开创了桉属植物的黄金时代，因为桉属植物特别耐火。</p>
<p>第三种解释：这种解释不排除智人狩猎与火耕有显著影响，但是强调不能忽视气候因素。45000年前的气候变迁让澳大利亚的整个生态系统失衡，变得特别脆弱。正常情况下，系统会慢慢调整并适应恢复。智人在这个时候到来，将已经脆弱的生态系统推进了无底深渊。</p>
<p>与澳大利亚类似的还有美洲大陆，大约在14000年前，智人通过当时西伯利亚与阿拉斯加相连的陆地抵达美洲大陆。在此之前，美洲大陆的物种远比今天丰富，各种在亚非大陆未曾得见的物种都在此繁衍茁壮。然而在人类抵达后的两千年内，大多数独特物种都惨遭毒手。</p>
<p>回归智人历史，第一波物种灭绝浪潮是由于智人的扩张，第二波物种浪潮是因为农业革命，现在我们正面临第三波物种灭绝的浪潮：由工业革命所造成的物种灭绝。有些环保人士声称我们的祖先智人总是和自然和谐相处，殊不知智人就是造成最多动植物灭绝的元凶。也许，这场人类洪水的唯一幸存者可能只剩下人类自己，其他登上诺亚方舟的也只可能是作为人类盘中佳肴的家禽家畜罢了。</p>
<div align="center">
[思维导图](https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png)

<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png" alt="思维导图"></p>
</div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-06-11T14:28:07.000Z" title="6/11/2017, 10:28:07 PM">2017-06-11</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">28 minutes read (About 4143 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/11/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">剖析@synchronizd底层实现原理</a></h1><div class="content"><p>@synchronizd是Objective-C中的一个语法糖，用于给某个对象加锁，因为使用起来简单方便，所以使用频率很高。然而，滥用@synchronizd很容易导致代码效率低下。本篇博客旨在结合@synchronizd底层实现源码并剖析其实现原理，这样可以更好的让我们在适合的情景使用@synchronizd。</p>
<p>@synchronizd本质上是一个编译器标识符，在Objective-C层面看不其任何信息。因此可以通过clang -rewrite-objc指令来获得@synchronizd的C++实现代码。示例代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"Iceberg"</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) {</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello,world! =&gt; %@"</span> , obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>{</span><br><span class="line">    </span><br><span class="line">    NSString *obj = (NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_0;</span><br><span class="line">    </span><br><span class="line">    {</span><br><span class="line">        id _rethrow = <span class="number">0</span>;</span><br><span class="line">        id _sync_obj = (id)obj;</span><br><span class="line">        <span class="built_in">objc_sync_enter</span>(_sync_obj);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">	            <span class="keyword">struct</span> <span class="title class_">_SYNC_EXIT</span> {</span><br><span class="line">	                _SYNC_EXIT(id arg) : <span class="built_in">sync_exit</span>(arg) {}</span><br><span class="line">	                ~_SYNC_EXIT() {</span><br><span class="line">	                    <span class="built_in">objc_sync_exit</span>(sync_exit);</span><br><span class="line">	                }</span><br><span class="line">	                id sync_exit;</span><br><span class="line">	            } _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_1 , obj);</span><br><span class="line">                </span><br><span class="line">            } <span class="built_in">catch</span> (id e) {</span><br><span class="line">                _rethrow = e;</span><br><span class="line">            }</span><br><span class="line">        </span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_FIN</span> {</span><br><span class="line">                _FIN(id reth) : <span class="built_in">rethrow</span>(reth) {}</span><br><span class="line">                ~_FIN() {</span><br><span class="line">                    <span class="keyword">if</span> (rethrow)</span><br><span class="line">                        <span class="built_in">objc_exception_throw</span>(rethrow);</span><br><span class="line">                }</span><br><span class="line">                id rethrow;</span><br><span class="line">            } _fin_force_rethow(_rethrow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过分析C++代码可以看到@sychronized的实现主要依赖于两个函数：objc_sync_enter和objc_sync_exit。此外还有try{}catch{}语句用于捕捉@sychronized{}语法块中代码执行过程中出现的异常。</p>
<p>我们发现objc_sync_enter函数是在try语句之前调用，参数为需要加锁的对象。因为C++中没有try{}catch{}finally{}语句，所以不能在finally{}调用objc_sync_exit函数。因此objc_sync_exit是在_SYNC_EXIT结构体中的析构函数中调用，参数同样是当前加锁的对象。这个设计很巧妙，原因在_SYNC_EXIT结构体类型的_sync_exit是一个局部变量，生命周期为try{}语句块，其中包含了@sychronized{}代码需要执行的代码，在代码完成后，_sync_exit局部变量出栈释放，随即调用其析构函数，进而调用objc_sync_exit函数。即使try{}语句块中的代码执行过程中出现异常，跳转到catch{}语句，局部变量_sync_exit同样会被释放，完美的模拟了finally的功能。</p>
<p>接下来，在<a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm">苹果公开的源代码文件objc-sync.mm</a>中找到objc_sync_enter和objc_sync_exit这两个函数的实现，一窥其中的奥秘。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncData</span> {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SyncData</span>* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">//当前加锁的对象</span></span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">//使用对object加锁的线程个数</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex; <span class="comment">//递归互斥锁</span></span><br><span class="line">} SyncData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockCount;  <span class="comment">//表示当前线程对object对象加锁次数</span></span><br><span class="line">} SyncCacheItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncCache</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocated;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> used;</span><br><span class="line">    SyncCacheItem list[<span class="number">0</span>];</span><br><span class="line">} SyncCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SyncList</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SyncList</span>() : <span class="built_in">data</span>(nil) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码是一些相关的数据结构，下面分别进行介绍：</p>
<p>SyncData结构体中有四个成员变量，其中object指针变量指向当前加锁对象，threadCount表示对object加锁的线程个数，mutex是一个递归互斥锁，意味着可以对object进行多次加锁，其具体作用后面会提到。</p>
<p>SyncCacheItem结构体中有两个成员变量，其中data是SyncData结构体类型的指针，lockCount表示当前线程对当前结构体对象加锁次数，其实就是对加锁对象object的加锁次数。我们可以看到SyncCacheItem与SyncData是一对一关系，SyncCacheItem只是对SyncData进行了再次封装以便于缓存，具体使用见后文。</p>
<p>SyncCache结构体中有三个成员变量，其中维护了一个SyncCacheItem类型的数组，allocated和used则分别表示当前分配的SyncCacheItem数组中的总个数和已经使用的个数。这个结构体与线程是一对一的关系，用于存储当前线程已加锁对象对应的SyncCacheItem结构体，因为一个线程可以对同一个对象多次加锁，所以通过引入缓存SyncCache可以提高效率，具体使用见后文。</p>
<p>SyncList结构体中有两个成员变量和一个构造函数，其中data是SyncData结构体类型的指针，lock是一个自旋锁。</p>
<p>sDataLists是一个全局StripedMap哈希列表，其中value为SyncList对象，key为加锁对象object指针进行hash后的值。StripedMap是一个C++模板类，其实现代码如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> { CacheLineSize = <span class="number">64</span> };</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_EMBEDDED</span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">8</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">64</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> {</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) { </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() {</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">assert</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，由于自己对C++模板类不熟悉，所以只能看个大概。其中有两个值得注意的地方，其中StripeCount表示哈希数组的长度，如果是嵌入式系统值为8，否则值为64，也就意味着哈希数组最大长度为64；函数indexForPointer为散列函数，算法不难，但是很巧妙，值得学习。</p>
<p>下面开始分析相关的函数实现，首先找到@sychronized直接调用的两个函数：objc_sync_enter和objc_sync_exit，代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, ACQUIRE);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) {</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">objc_sync_nil</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) {</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.<span class="built_in">tryUnlock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!okay) {</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不难发现，上述代码都调用了id2data函数来获取一个与obj对应的SyncData对象，然后使用该对象中的递归互斥锁分别进行加锁与解锁。至此@sychronized的大致实现过程已经很清晰了，本质上是为一个对象分配一把递归互斥锁，可以也是为什么可以反复使用@sychronized对同一个对象进行加锁的原因。那么@sychronized是如果管理这把互斥锁，以及是如何处理多个线程对同一个对象进行多次加锁的情况？很明显，一切奥秘都藏在id2data函数中，其代码如下所示：</p>
<ul>
<li>注：为了描述方便，下面将id2data函数的形参object描述为同步对象obejct。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//从全局哈希表sDataLists中获取object对应的SyncList对象</span></span><br><span class="line">	<span class="comment">//lockp指针指向SyncList对象中自旋锁</span></span><br><span class="line">	<span class="comment">//listp指向一条SyncData链表，因为C++ STL中的哈希表处理地址冲突的方法是链地址法</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lockp = &amp;<span class="built_in">LOCK_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData **listp = &amp;<span class="built_in">LIST_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class="line">	<span class="comment">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class="line">	<span class="comment">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="comment">//用于标识当前线程的是否已使用fastCache</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    <span class="comment">//直接调用tls_get_direct函数获取SyncData对象</span></span><br><span class="line">    SyncData *data = (SyncData *)<span class="built_in">tls_get_direct</span>(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) {</span><br><span class="line">    	 <span class="comment">//标识fastCache已被使用</span></span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line">		 <span class="comment">//比较fastCache中的SyncData对象中的object与当前同步对象object是否为同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) {</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">   			  <span class="comment">//fastCache中的对象恰好是当前同步对象object，则后续处理直接使用fastCache中SyncData对象</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            <span class="comment">//获取当前线程对应当前SyncData对象已经加锁的次数</span></span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)<span class="built_in">tls_get_direct</span>(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data fastcache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">			  <span class="comment">//判断当前操作的加锁还是解锁</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: {</span><br><span class="line">                <span class="comment">//加锁一次</span></span><br><span class="line">                lockCount++;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                <span class="comment">//解锁一次</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="comment">//已加锁次数为0，表示当前线程对当前同步对象object达到锁平衡，因此不需要再持有当前同步对象。</span></span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    <span class="comment">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class="line">                    <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="comment">//此函数为原子操作函数，用于对32位的threadCount整形变量执行减一操作，且确保线程安全。因为可能存在同一时间多个线程对一个threadCount进行加减操作，避免出现多线程竞争。不同于lockCount，threadCount是多个线程共享的一个变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能。而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁。</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">//这是第二章缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class="line">    <span class="comment">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class="line">    SyncCache *cache = <span class="built_in">fetch_cache</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) {</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) {</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="comment">//当前同步对象object已存在的SyncCache中</span></span><br><span class="line">            <span class="comment">//获取对应的SyncData对象</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//后续操作同fastCache一样，参考fastCache的注释</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">			  </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class="line">    <span class="comment">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class="line">    lockp-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) {</span><br><span class="line">        	  <span class="comment">//哈希表中存在对应的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) {</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                <span class="comment">//此函数为原子操作函数，确保线程安全，用于对32位的threadCount整形变量执行加一操作，表示占用当前同步对象的线程数加1。</span></span><br><span class="line">                <span class="built_in">OSAtomicIncrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//用于标记一个空闲的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="comment">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="comment">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) {</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="comment">//关联当前同步对象</span></span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            <span class="comment">//重置占用线程为1</span></span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到这一步说明需要新建一个SyncData对象</span></span><br><span class="line">    result = (SyncData*)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(SyncData), <span class="number">1</span>);</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建递归互斥锁</span></span><br><span class="line">    <span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="built_in">recursive_mutex_t</span>();</span><br><span class="line">    <span class="comment">//以“入栈”的方式加入当前同步对象object对应的SyncData链表</span></span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line"> 	 <span class="comment">//对全局哈希表的操作结束，解锁</span></span><br><span class="line">    lockp-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="comment">//只有ACQUIRE才需要新建SyncData对象</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) {</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line"></span><br><span class="line">		 <span class="comment">//fastCache缓存模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) {</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            <span class="comment">//直接缓存新建的SyncData对象</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            <span class="comment">//设置加锁次数为1</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		 <span class="comment">//SyncCache缓存模式，则直接加入SyncCacheItem数组中</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = <span class="built_in">fetch_cache</span>(YES);</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上述代码的注释，id2data函数的功能已经大致清晰。id2data函数主要是用于管理同步对象object与线程之间的关联。不论是ACQUIRE、RELEASE还是CHECK操作，都会先从当前线程的缓存中去获取对应的SyncData对象。如果当前线程的缓存区中不存在，那么再从全局的哈希数组中查找，查看其它线程是否已经占用过当前同步对象object。如果还是没有，那么就新建一个与之对应的SyncData对象，分别加入全局哈希表和当前线程缓存中。</p>
<p>至此，@synchronized的实现原理已经剖析结束，其有一个最大的特点是：不论是多个线性同一时间内对一个对象进行多次同步还是一个线程对同一个对象同步多次，一个对象只分配一把递归互斥锁。也就意味着对同一个对象而言，当执行某一次同步操作时，其他线程或同一线程的其他同步操作都会被阻塞，不言而喻，这种加锁方式的效率是很低的。</p>
<p>下面代码展示了@synchronized经典的使用案例之一：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject1:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember1 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject2:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember2 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject3:(<span class="keyword">id</span>)value {</span><br><span class="line">	<span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">		<span class="keyword">self</span>.instanceMember3 = value;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码，调用其中一个设置函数时，另外两个成员变量的设置函数在同一时间被调用都会被阻塞。这里@synchronized同步的代码很简单，所以不会效率差别不大。如果是同步的代码需要执行较长的时间，且被多个线程并发调用，那么效率变得很低。如果不清楚@synchronized的实现原理，可能很难排查出来导致效率低下的问题所在。我建议使用GCD取代@synchronized实现同步功能，GCD不仅是线程安全，且其由底层实现，效率会好很多。我们发生@synchronized的底层实现有捕获异常的功能，因此适合在需要确保发生错误时代码不会死锁，而是抛出异常时使用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-06-07T15:33:07.000Z" title="6/7/2017, 11:33:07 PM">2017-06-07</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/%E7%BF%BB%E8%AF%91/">翻译</a></span><span class="level-item">11 minutes read (About 1678 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/07/JavaScript%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/">JavaScript的this关键字</a></h1><div class="content"><p>这是一篇翻译文章，原文地址*<a target="_blank" rel="noopener" href="http://davidshariff.com/blog/javascript-this-keyword/#first-article">点击这里</a>*。</p>
<p>JavaScript中一个常用的语法特征就是this关键字，同时这也是JavaScript最容易被误解和造成困惑的特征。this关键字的含义是什么且决定其含义的依据是什么？</p>
<p>这篇文章试着解开这个的疑惑并给出一个简单清晰的解释。</p>
<p>对于有其他语言编程经验的人来说应该也使用过this关键字，且多数情况下this指向的是一个通过构造函数创建的新对象。举例来说，假设有一个Boat类，里面包含一个成员方法moveBoat()，我们可以在moveBoat()方法中通过this关键字访问当前的对象实例。</p>
<p>在JavaSctript中，当使用new关键字创建一个新对象后，在构造函数中可以通过this关键字访问当前对象。然而，JavaScript中的this关键字指向的对象是随着函数调用的上下文变化而变化的。如果你不是很了解关于JavaScript执行上下文的知识，我推荐你看看我的另外一篇关于这个话题的<a target="_blank" rel="noopener" href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article">文章</a>。好了，讲得够多了，让我们看几个代码实例：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global scope</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">'abc'</span>;</span><br><span class="line"><span class="title function_">alert</span>(foo); <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">'def'</span>;</span><br><span class="line"><span class="title function_">alert</span>(foo); <span class="comment">//def</span></span><br></pre></td></tr></tbody></table></figure>

<p>无论何时，只要是在全局上下文而非函数体内使用this关键字，那么this总是指向全局对象的（JavaSctript中的全局对象一般是Windows，NodeJS中是global）。接下来看看在函数中使用this关键字的情景：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boat = {</span><br><span class="line">    <span class="attr">size</span>: <span class="string">'normal'</span>,</span><br><span class="line">    <span class="attr">boatInfo</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === boat);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">size</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">boat.<span class="title function_">boatInfo</span>(); <span class="comment">// true, 'normal'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bigBoat = {</span><br><span class="line">    <span class="attr">size</span>: <span class="string">'big'</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">bigBoat.<span class="property">boatInfo</span> = boat.<span class="property">boatInfo</span>;</span><br><span class="line">bigBoat.<span class="title function_">boatInfo</span>(); <span class="comment">// false, 'big'</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中的this关键字指向是如何判断的？上述代码中有一个boat对象，包含了一个size属性和boatInfo方法。在boatInfo方法中有两条输出语句，分别是判断this关键字是否指向boat对象和输出this关键字指向的对象的size属性。因此，当执行代码boat.boatInfo()时，输出结果分别是true和normal。</p>
<p>随后我们创建了另外一个对象bigBoat，里面同样有一个值为big的size属性。然而，bigBoat对象没有boatInfo方法，因此通过语句bigBoat.boatInfo = boat.boatInfo拷贝一个boatInfo方法。现在，当我们执行语句bigBoat.boatInfo()时，输出的结果分别是false和big。为什么会输出false? boatInfo方法中的this指向的对象是如何发生变化的？</p>
<p>首先你得明白任何函数中的this关键字指向的值都不是定值，它根据你每次调用函数前的上下文来决定，这个上下文就是函数被调用时所作的生命周期。更为重要的是函数具体的调用语句。</p>
<p>当一个函数被调用时，如果函数是被某个对象调用时，那么函数中this关键字指向的是调用该函数的对象，否则指向的全局对象。下面举例说明：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// global - because the method bar() belongs to the global object when invoked</span></span><br><span class="line"><span class="comment">//this指向全局对象</span></span><br><span class="line"><span class="title function_">bar</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// foo - because the method baz() belongs to the object foo when invoked</span></span><br><span class="line"><span class="comment">//this指向foo对象</span></span><br><span class="line">foo.<span class="title function_">baz</span>(); </span><br></pre></td></tr></tbody></table></figure>
<p>如果事情有这么简单，那么上述代码显然解决了我们的疑惑。但是还有更为复杂的情况，看似同一个的函数，调用的语句不同也会导致this关键字的指向不同。如下所示：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// foo - because baz belongs to the foo object when invoked</span></span><br><span class="line"><span class="comment">//this指向foo对象</span></span><br><span class="line">foo.<span class="title function_">baz</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherBaz = foo.<span class="property">baz</span>;</span><br><span class="line"><span class="comment">// global - because the method anotherBaz() belongs to the global object when invoked, NOT foo</span></span><br><span class="line"><span class="comment">//this指向全局对象，即使anotherBaz是由foo.baz赋值而来，但是this的指向最终还是由调用的方式决定。</span></span><br><span class="line"><span class="title function_">anotherBaz</span>(); </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>通过上述代码我们看到由于调用语句的不同，baz方法中的this关键字指向的对象也不一样。现在我们来看看this关键字处于内嵌时的指向是如何的：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">anum</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">baz</span>: {</span><br><span class="line">        <span class="attr">anum</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">bar</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">anum</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 20 - because left side of () is bar, which belongs to baz object when invoked</span></span><br><span class="line"><span class="comment">//输出的值是20，因为bar方法是通过baz对象调用的</span></span><br><span class="line">foo.<span class="property">baz</span>.<span class="title function_">bar</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = foo.<span class="property">baz</span>.<span class="property">bar</span>;</span><br><span class="line"><span class="comment">// 0 - because left side of () is hello, which belongs to global object when invoked</span></span><br><span class="line"><span class="comment">//输出的是0，因为hello函数没有显示的调用对象，缺省调用对象为全局对象global</span></span><br><span class="line"><span class="title function_">hello</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>另外一个被常问到的问题是：如何判断事件监听函数中的this关键字指向？答案是处于事件监听函数中的this关键字通常指向触发该事件的DOM元素。下面举例说明：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"test"</span>&gt;I am an element <span class="keyword">with</span> id #test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doAlert</span>(<span class="params"></span>) { </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>); </span><br><span class="line">} </span><br><span class="line"><span class="comment">//指向全局对象，但是因为全局对象没有相应的属性，因此输出undefined</span></span><br><span class="line"><span class="title function_">doAlert</span>(); <span class="comment">// undefined </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'test'</span>); </span><br><span class="line">myElem.<span class="property">onclick</span> = doAlert; </span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(myElem.<span class="property">onclick</span> === doAlert); <span class="comment">// true </span></span><br><span class="line"><span class="comment">//this指向myElem对象</span></span><br><span class="line">myElem.<span class="title function_">onclick</span>(); <span class="comment">// I am an element</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，第一次调用doAlert函数，输出的是undefined，因此此时this指向的是全局对象global。当我们将doAlert函数设置为myElem元素对象的click消息监听函数时，意味着每次触发click消息时，doAlert等价于被myElem对象直接调用，因此this关键字指向的就是myElem对象。</p>
<p>最后，我想提醒大家的是this关键字的指向是可以通过call()和apply()函数手动修改的，这将导致我们上面讨论的内容都不再适用。另外一点是，在某个对象的构造函数中的this关键字默认是指向当前新建的对象，因为构造函数是使用new关键字调用的，系统会将构造函数中的this关键字指向即将创建的对象。</p>
<p><strong>总结</strong></p>
<p>希望今天的博客能够清除你对this关键字的疑惑，并且以后都能正确地判断this关键字的指向。现在我们知道了this关键字的指向的动态变化的且具体的值取决于this所在函数的调用方式。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-05-05T09:06:07.000Z" title="5/5/2017, 5:06:07 PM">2017-05-05</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Cocoa/">Cocoa</a></span><span class="level-item">6 minutes read (About 857 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/05/05/cocoa%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E5%89%8D%E5%8F%91%E9%80%81Request%E8%AF%B7%E6%B1%82/">Cocoa程序退出前发送HttpRequest请求</a></h1><div class="content"><p>最近在视频投送项目中遇到一个奇葩问题，花费了一整天时间才得以解决。这个问题比较隐晦，值得记录一下。</p>
<p>根据功能需要，需要在cocoa程序退出前，发送一个关闭设备的指令，本质上就是post一个Http请求，用于中止当前出于投送状态的设备。</p>
<p>具体代码如下：</p>
<p>在回调函数- (void)applicationWillTerminate:中调用停止投送API</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">NSNotification</span> *)aNotification {</span><br><span class="line">    	<span class="comment">// Insert code here to tear down your application</span></span><br><span class="line">    	</span><br><span class="line">    	[[CastHelper sharedInstance] stopCast];</span><br><span class="line">    </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">将stop指令集成到URL里面，加入投送队列castOperationQueue中，然后通过HttpRequest发送出去。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"></span><br><span class="line">		- (<span class="keyword">void</span>)stopCast</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">dispatch_async</span>(castOperationQueue, ^{</span><br><span class="line">        </span><br><span class="line">	       		 <span class="keyword">for</span> (ZDCastDevice * device <span class="keyword">in</span> <span class="keyword">self</span>.connectedDeviceInfo.allValues )</span><br><span class="line">	        	{</span><br><span class="line">	            	<span class="comment">//发送stop请求</span></span><br><span class="line">					[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line">	            </span><br><span class="line">	        	}</span><br><span class="line">        </span><br><span class="line">    		});</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//异步请求</span></span><br><span class="line">		- (<span class="keyword">void</span>)sendRequestURL:(<span class="built_in">NSURL</span> *)url HTTPMethod:(<span class="built_in">NSString</span> *)httpMethod</span><br><span class="line">	{</span><br><span class="line">	    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] init];</span><br><span class="line">	    [request setURL:url];</span><br><span class="line">	    [request setHTTPMethod:httpMethod];</span><br><span class="line">	    [request setValue:<span class="string">@"application/json;charset=UTF-8"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">	    [request setHTTPBody:<span class="literal">nil</span>];</span><br><span class="line">	 </span><br><span class="line">	    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) {</span><br><span class="line">	        </span><br><span class="line">	        <span class="comment">//Error</span></span><br><span class="line">	        <span class="keyword">if</span> (error)</span><br><span class="line">	        {</span><br><span class="line">	            </span><br><span class="line">	            </span><br><span class="line">	        }<span class="keyword">else</span></span><br><span class="line">	        {</span><br><span class="line">	            <span class="built_in">NSInteger</span> statusCode = [(<span class="built_in">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class="line">	         </span><br><span class="line">	            <span class="comment">//successed</span></span><br><span class="line">	            <span class="keyword">if</span> ( statusCode == <span class="number">200</span>)</span><br><span class="line">	            {</span><br><span class="line">	                </span><br><span class="line">	            <span class="comment">//failed</span></span><br><span class="line">	            }<span class="keyword">else</span></span><br><span class="line">	            {</span><br><span class="line">	                </span><br><span class="line">	            }</span><br><span class="line">	            </span><br><span class="line">	        }</span><br><span class="line">	  </span><br><span class="line">	    }] resume];</span><br><span class="line">	 </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在程序正常运行期间，使用上述代码能够正常的执行stop指令，并接受相应的响应。但是，如果在applicationWillTerminate这一函数中调用，通过断点调试发现Request并未成功发送出去，程序就退出了。</p>
<p>一开始以为是异步发送请求的原因，于是使用dispatch_semaphore_t信号量进行同步，执行结果一样，未解锁之前程序就退出了。代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">		<span class="comment">//异步请求</span></span><br><span class="line">		- (<span class="keyword">void</span>)sendRequestURL:(<span class="built_in">NSURL</span> *)url HTTPMethod:(<span class="built_in">NSString</span> *)httpMethod</span><br><span class="line">	{</span><br><span class="line">	    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] init];</span><br><span class="line">	    [request setURL:url];</span><br><span class="line">	    [request setHTTPMethod:httpMethod];</span><br><span class="line">	    [request setValue:<span class="string">@"application/json;charset=UTF-8"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">	    [request setHTTPBody:<span class="literal">nil</span>];</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//创建信号量</span></span><br><span class="line">	    dispatch_semaphore_t semp = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">	    </span><br><span class="line">	    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) {</span><br><span class="line">	        </span><br><span class="line">	        <span class="comment">//Error</span></span><br><span class="line">	        <span class="keyword">if</span> (error)</span><br><span class="line">	        {</span><br><span class="line">	            </span><br><span class="line">	            </span><br><span class="line">	        }<span class="keyword">else</span></span><br><span class="line">	        {</span><br><span class="line">	            <span class="built_in">NSInteger</span> statusCode = [(<span class="built_in">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class="line">	         </span><br><span class="line">	            <span class="comment">//successed</span></span><br><span class="line">	            <span class="keyword">if</span> ( statusCode == <span class="number">200</span>)</span><br><span class="line">	            {</span><br><span class="line">	                </span><br><span class="line">	            <span class="comment">//failed</span></span><br><span class="line">	            }<span class="keyword">else</span></span><br><span class="line">	            {</span><br><span class="line">	                </span><br><span class="line">	            }</span><br><span class="line">	            </span><br><span class="line">	        }</span><br><span class="line">	        </span><br><span class="line">	        dispatch_semaphore_signal(semp);</span><br><span class="line">	        </span><br><span class="line">	    }] resume];</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//等待接受到请求响应才执行后续代码</span></span><br><span class="line">	    dispatch_semaphore_wait(semp, DISPATCH_TIME_FOREVER);</span><br><span class="line">   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>同步请求方式的方式也试过，结果同样达不到预期效果。代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSURLResponse</span>* response = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) {</span><br><span class="line">        </span><br><span class="line">        HTTPLogInfo(<span class="string">@"%s:%d - Error: %@"</span> , __func__ , __LINE__ , [error localizedDescription]);</span><br><span class="line">        </span><br><span class="line">    }<span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        HTTPLogInfo(<span class="string">@"%s:%d - response: %@"</span> , __func__ , __LINE__ , [response description]);</span><br><span class="line">    }</span><br><span class="line">   </span><br></pre></td></tr></tbody></table></figure>

<p>思来想去，觉得可能是程序退出去前，只有主线程有效，其他线程均被释放了。于是，把调用stop指令的代码放入主线程队列：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopCast</span><br><span class="line">{</span><br><span class="line">	<span class="comment">//加入主线程队列</span></span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{</span><br><span class="line">      </span><br><span class="line">      		 <span class="keyword">for</span> (ZDCastDevice * device <span class="keyword">in</span> <span class="keyword">self</span>.connectedDeviceInfo.allValues )</span><br><span class="line">       	{</span><br><span class="line">           	<span class="comment">//发送stop请求</span></span><br><span class="line">			[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line">           </span><br><span class="line">       	}</span><br><span class="line">      </span><br><span class="line">  		});</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>执行结果还是同之前一样。最后，仔细回想了一下RunLoop的执行过程，很可能是RunLoop在执行了applicationWillTerminate函数所在的任务之后就直接退出了，也就不会执行主线程队列后续的任务了。</p>
<p>于是，直接把调用stop指令的函数放在与applicationWillTerminate同一个任务中，代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopCast</span><br><span class="line">{</span><br><span class="line">	<span class="comment">//发送stop请求</span></span><br><span class="line">	[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>果然不出所料，Request执行成功，并获得相应的Response。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述言论都是基于我的猜测，我暂时没有去验证。这个问题比较隐晦，有点违背习惯性的思维。改天抽空结合Apple源代码进行分析验证，此处留坑。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-14T14:30:07.000Z" title="4/14/2017, 10:30:07 PM">2017-04-14</time></span><span class="level-item"><a class="link-muted" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></span><span class="level-item">14 minutes read (About 2133 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/14/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/">关于读书无用论的一些想法</a></h1><div class="content"><p>关于最近流行的“读书无用论”观点的一些个人看法</p>
<p>通过反复揣摩这句话，大概可以总结为以下五点（如有歧义，欢迎指正）：</p>
<p>一、在需要的时候，读技能书学习相应的技能即可<br>二、选择什么样的生活，取决于性格，而非读书能够左右<br>三、读书不能弥补先天的差距</p>
<p>我觉得，所谓的读书无用，其中“读书”是指阅读，而非指代“寒窗苦读十余载，金榜题名望今朝”这样功利性的读书，另外“无用”是指阅读不会对一个人的生活带来太大的改变。所以，后面用“阅读”来取代“读书”。</p>
<p>首先，我的立场是：“阅读很有用，不仅完善人格，还能深化思想，甚至可以改变一个人的命运。”书有好书和差书之分，一本好书是作者耗费了大量精力，基于自身知识底蕴，结合个人思想，经过岁月打磨出来的。从某个角度来说，读者只需要几十块钱就能获得作者几十年甚至一生的心血，实在是再廉价不过了。当然，读者能否完全理解作者的思想那就另当别论。阅读一本好书，读过就会留下印象，并且受其影响，只是深浅之分罢了。至于差书，确实没有阅读的必要，不仅无用，浪费时间不说，可能还会造成负面影响。</p>
<p>以下是我的具体想法。</p>
<p>一、在需要的时候，读技能书学习相应的技能即可。</p>
<p>作为一个理科生，读技能类的书差不多是每天的日常。书分很多种，技能书则属于自然科学类。特点就是其内容是依据人类目前已经公认或者证实的客观事实提炼或者推导出来的。同一个主题，不同的作者可能表述方式不一样，但是阐述的观点或者得出结论总是一样的。这样的书，讲究实用性，尊重客观事实，不会随着个人意志改变，主要功能在于传授一种技能，对人的三观（人生观，价值观，世界观）不会有太大的影响。</p>
<p>我想你认可读技能书就是因为它的实用性，能解决实际问题。这也是你认为阅读还算有价值的地方。这一点我同意你的观点。对于不是专业的技能，需要的时候，能解决问题就行。</p>
<p>二、选择什么样的生活，取决于性格，而非读书能够左右</p>
<p>首先，现实生活中，大多数人都没有选择自己想要的生活的资本，而是迫于生计和负担，过着不如意的生活。所以，选择什么样的生活与物质条件也有关系。所以，应该是选择什么样的生活态度更为准确。</p>
<p>都说“内心是怎样的，你看到的世界就是怎样的。”我们看到的或者听到的，都不一定是真实客观的，而是经过大脑过滤，在主观思想的作用下，变成我们愿意相信的“事实”。至少，我们大多数时候都会信以为真。</p>
<p>那么你的思考问题的角度是否足够全面，思维方式是否是辩证的，以及你大脑的知识储量是否足够充实，就确定了过滤后的结果与真相偏离度的大小。能够影响上述三个方面的因素大致两个，一是外界环境影响，包括家庭环境，成长环境，教育环境。在我们还没有独立学习能力之前，我们对世界的认知都是被动地接受外界影响，最终构成了性格的一部分，这属于先天条件差异造成的个体差异，即所谓的天赋。另外一个因素就是主动学习，这也是人类特有的能力。而最有效也是最廉价的途径莫非就是阅读。一个人成年之后并非不可以改变自己的性格，只是会比较难，这一点已经有科学依据。阅读，既然能改变你的主观思想，也就会影响你对于这个世界的认知，对人生的理解，对自身价值的认可。阅读也许不能改变一个人的物质生活，但是改变一个人看待生活的方式。因此，阅读至少可以改善我们的精神生活。</p>
<p>因为性格是先天性的，所以会在最开始影响我们的生活方式。但是阅读可以改变一个人看待生活的态度，进而去追求自己想要的生活。</p>
<p>三、阅读不能弥补先天的差距</p>
<p>你说有人毕生的追求也许就是别人与生俱来的。没错，确实普遍存在这样的情况。就拿阅读这个习惯来说吧，有些“书香门第”出身的孩子，从小就养成了阅读的习惯，而且从小就阅读很多的书籍，从而比一般的同龄人有更渊博的知识和更出色的思维方式。这些天赋在他们看来都是自然而然的事情，先天的优势不言而喻。对比出身贫穷的孩子，很多人都没有阅读的习惯，思考问题也很浅显和片面。而且，一旦成年，即便有条件和时间来重新塑造自己，也需要付出很大代价，需要将推翻原有的思维方式和改正不良的习惯。</p>
<p>从这个角度来说，阅读确实很难弥补先天的差距。人生本就是不公平的，坦然接受这个事实是树立正确地人生观的前提。另外，即便如此也不能因为这个原因就否定阅读的作用。</p>
<p>每个人都有自己的局限性。而人生的意义就在于突破自己的局限性，给自己的生活带来更多可能性，这是每一个精彩人生的主旋律。而阅读无非就是这样的一把利刃。</p>
<p>最后，我上面叽里呱啦说这些并不是想改变你对阅读的看法。而是，我想和你交流一下我对阅读的看法。我从小在农村长大，身边的人几乎没有看书的习惯，除了干活就是看电视聊家常，童年的记忆根本没有书的影子。我们村很多同龄人都是初中毕业就去广东打工。我是整个村子为数不多的大学生。即便如此，我直到上大学都没有真正明白为什么要读书，意义是什么？难道就是为了找一份谋生的工作？阅读的习惯是我大二之后开始培养的，因为我意识到了自己的局限性以及和别人的先天性差距。从那时候起，我就开始培养自己的阅读习惯，一开始确实很难，因为应试教育的原因很排斥读书。后面反反复复折腾，慢慢对阅读有了一点感觉，也尝到了阅读带来的一点甜头。就我个人经历来说，阅读给我生活带来的改变还是挺大的，不管是精神上还是物质上都有改变，让我更好地把握机遇，更好的去对待生活中的困境。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-02-22T17:58:07.000Z" title="2/23/2017, 1:58:07 AM">2017-02-23</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a></span><span class="level-item">9 minutes read (About 1400 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/23/JS-%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%B6%88%E6%81%AF/">原生JS代码模拟鼠标点击消息</a></h1><div class="content"><p>近两天都忙于更新之前做的一个关于国外某知名音乐网站项目，因为自己一直做iOS开发并没有系统的学习过JS，所以属于半吊子水平。</p>
<p>由于该音乐网站对网页进行了全新的改版，导致之前注入的JS代码全部失效，且原网站中使用的第三方JQuery库也被去掉了。意味着只能使用原生JS重写注入代码。</p>
<p>期间遇到了一个“棘手”的问题：使用原生JS代码模拟鼠标点击消息来改变音量，不同于普通的鼠标点击的是消息里面需要附带鼠标坐标。在各种尝试之后，耗费了大半天时间才得以解决，个人觉得有点价值，记录下解决思路以供参考。</p>
<p>以下是解决思路流程：</p>
<p>ps：以下调试和代码均在Chrome浏览器的控制台执行。</p>
<h4 id="分析DOM元素结构"><a href="#分析DOM元素结构" class="headerlink" title="分析DOM元素结构"></a>分析DOM元素结构</h4><p>页面样式</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-1.png" alt="页面样式"></p>
<p>DOM结构</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-2.png" alt="DOM结构"></p>
<p>由上图可知，DIV元素VolumeSlider作为父元素，其下有四个子元素，分,包括显示音量的slider和控制音量的handle元素。</p>
<p>对音量相关的DOM结构有一个大致了解，便于后面消息派发时选择触发的目标元素。如果说网站将响应鼠标消息的js绑定在父元素，那么选择任意一个子元素或者父元素本身作为触发对象都可以，因为消息会自动传递，最终会作用于父元素VolumeSlider。但是如果响应鼠标消息的js是绑定在四个子元素中的其中一个，则需要一一尝试。这个例子中只有4个子元素，所以很快就能有结果，但是如果需要测试的元素很多，那就效率太低下了。文章后面会介绍一种方法，快速定位响应鼠标消息的元素。</p>
<h4 id="模拟鼠标点击消息"><a href="#模拟鼠标点击消息" class="headerlink" title="模拟鼠标点击消息"></a>模拟鼠标点击消息</h4><p>该音乐网站改版之前，因为支持jQuery，借助于jQuery库提供的API很方便获取元素坐标和模拟鼠标点击消息。而新的版本只能用原生js编写相关代码。</p>
<p>第一步：获取元素的坐标位置</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//递归获取元素的纵坐标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">e</span>){</span><br><span class="line">    <span class="keyword">var</span> offset=e.<span class="property">offsetTop</span>;</span><br><span class="line">    ／／累加父元素的坐标值</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">offsetParent</span>!=<span class="literal">null</span>) </span><br><span class="line">    	／／递归</span><br><span class="line">    	offset+=<span class="title function_">getTop</span>(e.<span class="property">offsetParent</span>);</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//递归获取元素的横坐标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLeft</span>(<span class="params">e</span>){</span><br><span class="line">    <span class="keyword">var</span> offset=e.<span class="property">offsetLeft</span>;</span><br><span class="line">    ／／累加父元素的坐标值</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">offsetParent</span>!=<span class="literal">null</span>) </span><br><span class="line">    	／／递归</span><br><span class="line">    	offset+=<span class="title function_">getLeft</span>(e.<span class="property">offsetParent</span>);</span><br><span class="line">    <span class="keyword">return</span> offset; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>第二步：模拟鼠标消息</p>
<p>原生js的Event对象有很多属性，但是创建Event的时并不是每一个属性都需要赋值。在网上找到了一篇博客<a target="_blank" rel="noopener" href="http://marcgrabanski.com/simulating-mouse-click-events-in-javascript/">Simulating Mouse Events in JavaScript</a>讲的比较详细。以下是我使用的示例代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">／／offset是通过音量值转换过来的：音量level（<span class="number">0</span>-<span class="number">1</span>）* targetElement的长度</span><br><span class="line"><span class="keyword">var</span> clientX = <span class="title function_">getLeft</span>(targetElement) + offset;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> clientY = <span class="title function_">getTop</span>(targetElement);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">'click'</span>, {</span><br><span class="line">								<span class="string">'view'</span>: <span class="variable language_">window</span>,</span><br><span class="line">								<span class="string">'bubbles'</span>: <span class="literal">true</span>,</span><br><span class="line">								<span class="string">'cancelable'</span>: <span class="literal">true</span>,</span><br><span class="line">								<span class="string">'clientX'</span>:clientX,</span><br><span class="line">								<span class="string">'clientY'</span>:clientY</span><br><span class="line">                                       });</span><br><span class="line">            </span><br><span class="line">targetElement.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>第三步：获取响应鼠标消息的元素</p>
<p>如果是普通的鼠标消息，比如点击按钮消息或者不带坐标值的消息，一般很容易触发成功。但是如果是带来坐标位置的鼠标消息则很可能触发成功之后但是达不到预期效果。在这个问题上我困惑了蛮久，明明代码执行之后，返回触发消息成功，但是音量值并没有改变。</p>
<p>我在想有没有办法将真实的鼠标点击消息内容输出到终端，这样通过对比真实的鼠标消息就能找到模拟的鼠标消息的差异所在。</p>
<p>于是，在控制台输入了以下代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> windowClickEvent = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">ev</span>){</span><br><span class="line">	<span class="keyword">var</span> oEvent = ev||event;</span><br><span class="line">	／／获取当前鼠标消息对象</span><br><span class="line">	windowClickEvent = oEvent;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码能获得当前鼠标消息对象。使用鼠标点击音量条，在控制台获得如下结果：</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-3.png" alt="DOM结构"></p>
<p>对比真实的鼠标消息，确定模拟的鼠标消息中的坐标值是吻合的。但是二者的target元素不同，这也正是原因所在。修改了target元素之后，代码执行结果达到了预期的结果。通过这个方法可以快速定位响应鼠标消息的目标元素。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在刚开始要使用原生js模拟鼠标消息的时候，感觉一片茫然。在网上查了很多资料，没有找到满足需求的代码。最后只能硬着头皮自己写，期间各种不确定性都需要一一测试，折腾了大半天，好在最终达到预期的结果。与此同时，对模拟鼠标消息也有了新的体会，至少以后能够比较轻松的完成类似的功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-02-12T14:28:07.000Z" title="2/12/2017, 10:28:07 PM">2017-02-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Cocoa/">Cocoa</a></span><span class="level-item">8 minutes read (About 1160 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/12/%E8%A7%A3%E9%99%A4NSTimer%E6%BD%9C%E5%9C%A8%E7%9A%84%E2%80%9C%E4%BF%9D%E7%95%99%E7%8E%AF%E2%80%9D%E9%97%AE%E9%A2%98/">解除NSTimer潜在的“保留环”问题</a></h1><div class="content"><p>NSTimer是Foundation框架中的一个使用频率很高的类，然而其调用过程中很容易引入潜在的“保留环“问题。可能是因为NSTimer的提供的API足够便利与顺手，以至于这个问题不容易被察觉到。这篇博客旨在阐述这个问题并提供解决方法。</p>
<p>以下的NSTimer提供的三个常用的创建或者初始化的API：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)t selector:(SEL)s userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)ui repeats:(<span class="built_in">BOOL</span>)rep <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这三个API有一个共同的点，即都需要提供一个target参数。这个target参数会被创建的NSTimer实例对象强引用一次，直到NSTimer实例对象调用invalidate方法后失效才释放。API文档原文如下：</p>
<blockquote>
<p>target: The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. </p>
</blockquote>
<p>多数情况，我们都会将创建后NSTimer实例对象保存为当前类的实例变量，然后NSTimer的target参数设置为self指针。我写代码的习惯就是这样的。实例代码如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>{</span><br><span class="line">    <span class="built_in">NSTimer</span> *mTimer;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init {</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) {</span><br><span class="line">      	<span class="comment">//此处参数repeats = YES;</span></span><br><span class="line">        mTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFiredFun) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        [mTimer setFireDate:[<span class="built_in">NSDate</span> distantPast]];</span><br><span class="line">     </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc {</span><br><span class="line">    [mTimer invalidate];</span><br><span class="line">    mTimer = <span class="literal">nil</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerFiredFun{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span> , __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc , <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    </span><br><span class="line">    MyObject *myObjcet = [MyObject new];</span><br><span class="line">    <span class="comment">//self只是一个空消息，避免编译器发出myObjcet未使用的警告</span></span><br><span class="line">    [myObjcet <span class="keyword">self</span>];</span><br><span class="line">  	<span class="comment">//NSTimer依赖于RunLoop而存活，手动激活RunLoop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码就是典型的计时器使用情景之一。如果计时器只是一次执行而非反复触发，那么计时器会在执行后自动失效，也就不会有“保留环”的问题。但是如果是设置反复触发的计时器类型，那么NSTimer对象会强引用MyObject对象，而当前类也一直持有NSTimer对象，因此，如果NSTimer不调用invalidate设置无效，MyObject对象不会背释放，其dealloc函数也一直被调用，然而NSTimer的invalidate恰好是MyObject对象的dealloc函数中调用。这样两个对象都不会释放。</p>
<p>出现“保留环”的根本原因在于NSTimer对象在创建的API隐性地强引用一次target，因此，解除“保留环”的关键在于避开NSTimer对象对self指针的强引用。以下是提供的一种解决方案：</p>
<p><strong>NSTimer+BlockSupported分类</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ICETimerScheduleBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">"NSTimer+BlockSupported.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo {</span><br><span class="line">    <span class="comment">//Timer会对target强引用，但是此处target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:ti target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(ice_timerFiredFun:) userInfo:block repeats:yesOrNo];</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)ice_timerFiredFun:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line">    ICETimerScheduleBlock block = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span> (block) {</span><br><span class="line">        block();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用方式</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">mTimer = [<span class="built_in">NSTimer</span> zd_scheduledTimerWithTimeInterval:<span class="number">1.0</span>f block:^{</span><br><span class="line">    <span class="comment">//添加一次局部强引用，确保即使在block执行过程中外部的self被释放了也能顺利完成。局部变量strongSelf的生命周期只限于当前block，不会一直持有self，所以不影响外部self对象的引用计数平衡。</span></span><br><span class="line">    <span class="comment">//如果局部强引用，weakSelf可能会在block执行过程中因为外部self释放而被设置为nil。</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf timerFiredFun];</span><br><span class="line">} repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>上述解决方案使用了NSTimer+BlockSupported分类对NSTimer原生函数进行了二次封装，将调用方需要的执行的函数转移到block中执行，再结合__weak指针解除NSTimer对self的强引用。NSTimer原生API调用照样会对target强引用，但是此时的target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</p>
<p>这种类型的“保留环”问题很隐蔽，因此很有分析与记录价值，与君共享。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/icebergcwp1990/ICBTimerWithoutRetainCycle">GitHub Demo</a></p>
<p><em>注：这个解决方案参考了Effective Objective-C 2.0一书中第52条，有兴趣的同学可以自行查阅。</em></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-01-08T09:58:07.000Z" title="1/8/2017, 5:58:07 PM">2017-01-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></span><span class="level-item">10 minutes read (About 1544 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/01/08/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1/">关于爱的一点想法</a></h1><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前不久又翻读了《少有人走得路》这本书，并将其置于枕边，每天晚上睡觉之前或是蹲马桶的时候看上几个章节，那种感觉妙不可言。这本书从来没有让我失望过，每看一次都收获不少，确实是一本值得读一辈子的好书。</p>
<h3 id="爱的定义"><a href="#爱的定义" class="headerlink" title="爱的定义"></a>爱的定义</h3><p>这次的阅读有一个论点让我深以为然，就是关于爱的定义。作者斯科特·派克是这样定义的：“爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。“ 爱，是一种神秘的现象，我个人觉得很难言明爱是什么，如何定义。如果有人问我：”你觉得爱是什么？“ 我很可能回答：”它是一个很奇妙的东西。“ 然而，当我在书中看到作者给出的定义时，觉得他完整的表达了我对于爱的理解。</p>
<p>爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。当我在付出爱的努力，不仅能让他人的心智成熟，自己也同样获益。真正意义上的爱，既是爱自己，也是爱他人。我始终坚信一个不爱自己的人是不可能爱别人的。一个缺乏自律的父母，不可能让孩子懂得什么是自我完善；一个自私的伴侣，不可能察觉另一半情绪细微变化和顾忌另一半的心理感受。显然，自私和缺乏自律就是一种心智不成熟的表现，换言之就是不自爱的结果。这也许和大多数人理解的爱不太一样，以为爱就只是给予和付出。殊不知，真正的爱是自我完善，也是帮助他人完善。它意味着持续地努力，超越自我界限。</p>
<p>对于爱最大的误解，莫过于将男女恋爱理解为爱。我以前也是这样理解，其实我错了。</p>
<h3 id="坠入情网"><a href="#坠入情网" class="headerlink" title="坠入情网"></a>坠入情网</h3><p>提及爱这个字眼，相信很多人都会想到男女恋爱，尤其是把坠入情网当成爱。坠入情网的人，时常会把”我爱你“这样的句子挂在嘴边，以此表达爱意。然而，这只是一种主观愿望罢了。要了解坠入情网的本质，首先理解心理学上的”自我界限“。</p>
<p>何为”自我界限“？在新生婴儿的眼里，一切移动或静止的事物之间，他和周围的人之间，在单个个体和整个世界之间，没有任何界限和区别。随之年龄和认识的增长，他会发现他和世界不是一回事。他感觉饥饿，母亲不见得立刻出现；他想玩耍的时候，母亲未必能及时配合。他渐渐地意识到自己的意愿和母亲的行为完全是截然不同的两回事，这也就是自我意识的形成。通常，婴儿的自我意识能否健康发展，取决于同母亲的关系是否融洽。当婴儿意识到自己是一厢情愿的，不能主宰其他人的意愿，于是开始在自己和周围世界之间做出区分。慢慢地我们能区分出自己和外在世界更多的不同，认识到自己的局限性。这样的认知就是”自我界限“。</p>
<p>永远活在”自我界限“中，只会给人带来孤寂。对他们而已，世界充满险恶，自我界限是保护伞，孤独和寂寞反而能带来安全感。但是大部分人还是渴望摆脱寂寞，冲出自我界限的牢笼。坠入情网，就是表现之一，暂时性地摆脱寂寞。坠入情网意味着”自我界限“的某部分崩溃，使我们的自我与他人的自我合二为一。情感就像决堤的洪流，声势浩大地涌向所爱的人，于是寂寞消失了，取而代之的是难以言喻的狂喜。</p>
<p>显然，坠入情网是情感和心灵退化现象。与心爱的人在一起，跟童年时和父母相伴的记忆彼此呼应，让我们体会到幼年时无所不能的快感，似乎没有什么能够阻止我们实现愿望。然而，残酷的现实会像击溃两岁小孩的幻想一样击溃我们的爱情之梦。日常琐事和难题，容易让双方产生矛盾和冲突，对这种”爱“造成威胁甚至击溃。我们必须面对现实，学会真正的相知和相爱，以此来避免上述这种虚幻的爱。</p>
<p>坠入情网是自我界限暂时性崩溃的现象，只要客观条件允许，就会发生。而真正的爱是需要彼此付出努力的，是一种主观意愿。坠入情网的经历终结，自我界限会恢复原样。而真正的爱是对自我界限的扩充，而不是使其恢复原状。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>真正的爱不是过度依赖，也不是自我牺牲，更不是一种感觉，而是实际行动，是心智上地成长。在爱一个人之前，首先成为一个自爱的人，一个有趣的人，再和另外一半一起有趣下去。</p>
<p>如何成为一个有趣的人？还在努力中…</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-11-23T09:32:07.000Z" title="11/23/2016, 5:32:07 PM">2016-11-23</time></span><span class="level-item"><a class="link-muted" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></span><span class="level-item">16 minutes read (About 2406 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/11/23/StartFucks%20Coffee%20-%20%E6%93%8D%E8%9B%8B%E7%9A%84%E5%92%96%E5%95%A1/">StartFucks Coffee - 操蛋的咖啡</a></h1><div class="content"><blockquote>
<p>写了一天的代码，看着桌上冒着热气的白开水，想到第一次去星巴克的情景：傻傻地在柜台面子，看着各种咖啡名词，踌躇许久，最终点了一份中杯柠檬茶。那位服务员小胖妞无语中掺杂点鄙视的眼神，至今记忆犹新…</p>
</blockquote>
<p>身边的朋友喝咖啡的不少，咖啡这个词汇也经常萦绕耳旁：美剧中，喝咖啡已是日常；朋友聚会，问及他（她）们最爱的饮料，也是拿铁和卡布奇诺居多；特别的大学期间的坐我对面的师姐，感觉她对于喝咖啡跟喝水已经没多大区别，每一次浓浓的咖啡香从她的书桌散发出来，很难说我没有一丝要来一杯的冲动，不过，最终还是忍住了。</p>
<p>究其原因，一是我个人对咖啡的印象并不好，普遍观点认为长期喝咖啡对于身体健康和健身有不良影响，这种观点是否属实尚不能下定论。在此之前，我选择敬而远之。二是我狭隘的以为咖啡只有一种：苦咖啡，殊不知咖啡也是大有学问。其实我早该想到西方的咖啡应该和东方的茶一样，种类繁多，口味各异。只是先入为主的观念让我对咖啡已经失去了进一步了解的兴趣。</p>
<p>如今，终究是因为自尊心受到了伤害，决定整理一下关于咖啡的基本知识。更何况即便是不喝咖啡，也至少对它有一个基本的认识，这样才算得上公平。</p>
<p>网上已经有很多接受咖啡种类的文章，我只是顺手牵羊，秉着拿来主义，自己总结一下，加深印象。</p>
<p>咖啡大体上可以分为12种，其中浓缩咖啡（Espresso）最为根本，其他11种都是在Espresso的基础上添加其他的配料演变而成的花式咖啡。</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-0.jpg" alt="12种咖啡的恩怨情仇"></p>
<p>通过上图，可以比较直观地感受这12种咖啡直接的关联。以下分别介绍：</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-1.jpg" alt="浓缩咖啡-玛奇朵-美式咖啡"></p>
<h3 id="浓缩咖啡（Espresso）"><a href="#浓缩咖啡（Espresso）" class="headerlink" title="浓缩咖啡（Espresso）"></a>浓缩咖啡（Espresso）</h3><p>浓缩咖啡，英文名为Espresso，Espresso是一个意大利单词，所以也叫意式浓缩咖啡，指的是一种用咖啡机在短时间内急速萃取的浓烈咖啡，几乎称得上是所有花式咖啡的基础，也是全世界咖啡馆的必备。Espresso很小杯，通常只有30毫升左右，味道很苦，表面浮着一层厚厚的油脂，会与一杯清水同上，可以选择加糖。这款是真正的咖啡爱好者和急需提神者的首选。</p>
<h3 id="玛奇朵（Espresso-Macchiato）"><a href="#玛奇朵（Espresso-Macchiato）" class="headerlink" title="玛奇朵（Espresso Macchiato）"></a>玛奇朵（Espresso Macchiato）</h3><p>Macchiato原文为意大利语，代表“印记、烙印”的意思，发音为“玛奇雅朵”，习惯称呼为玛奇朵。玛奇朵是在浓咖啡上加上薄薄一层热奶泡以保持咖啡温度，细腻香甜的奶泡能缓冲浓缩咖啡带来的苦涩冲击，想喝咖啡但又无法舍弃甜味的你，可以选择玛奇朵。经常会听到“焦糖玛奇朵”，据说这是星巴克的独创，其做法是在牛奶中加入香草糖浆，与Espresso咖啡混合，再于奶泡上覆盖一层焦糖，口味层次很丰富。</p>
<h3 id="美式咖啡（Americano）"><a href="#美式咖啡（Americano）" class="headerlink" title="美式咖啡（Americano）"></a>美式咖啡（Americano）</h3><p>很多咖啡馆的“当日咖啡”其实就是美式咖啡，这通常也是咖啡馆菜单上最便宜的一种。美式咖啡说白了，就是小半杯Esprssso兑上大半杯白开水，也有咖啡馆会使用滴滤式咖啡壶冲泡。美式咖啡味道淡、颜色浅，微酸微苦，但因为萃取时间长，所以咖啡因含量高。</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-2.jpg" alt="拿铁-白咖啡-康宝蓝"></p>
<h3 id="拿铁（Caffe-Latte）"><a href="#拿铁（Caffe-Latte）" class="headerlink" title="拿铁（Caffè Latte）"></a>拿铁（Caffè Latte）</h3><p>拿铁是Espresso与牛奶的经典混合，杯底先倒入少量Espresso，然后加入大量牛奶，顶端是浓密的一层泡沫，可以在奶泡上拉出各种各样的图案。经典的拿铁是70%牛奶+20%奶沫+10%咖啡，受法国人喜爱的欧蕾咖啡，是将牛奶和咖啡同时倒入杯中，两者在第一时间碰撞、混合，上加两勺打成泡沫的奶油，这在法国人的早餐中十分常见，几乎是国民饮料。</p>
<h3 id="白咖啡（Flat-White）"><a href="#白咖啡（Flat-White）" class="headerlink" title="白咖啡（Flat White）"></a>白咖啡（Flat White）</h3><p>关于白咖啡网上有两种说法：</p>
<ol>
<li><p>白咖啡并不是马来西亚的那个特产，而是没有奶泡的拿铁。</p>
</li>
<li><p>马来西亚土特产，约有100多年的历史。白咖啡并不是指咖啡的颜色是白色的，而是采用特等咖啡豆及特级脱脂奶精原料，经特殊工艺加工后得到的咖啡，甘醇芳香不伤肠胃，保留了咖啡原有的色泽和香味，颜色比普通咖啡更清淡柔和，故得名为白咖啡。</p>
</li>
</ol>
<h3 id="康宝蓝（Espresso-Con-Panna）"><a href="#康宝蓝（Espresso-Con-Panna）" class="headerlink" title="康宝蓝（Espresso Con Panna）"></a>康宝蓝（Espresso Con Panna）</h3><p>意大利语中，Con是搅拌，Panna是生奶油，康宝蓝即意式浓缩咖啡加上鲜奶油。有一种说法是，正宗的康宝蓝要配一颗巧克力或太妃糖，先将巧克力或太妃糖含在嘴里，再喝咖啡，让美味一起在口中绽放。</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-3.jpg" alt="布雷维-卡布奇诺-摩卡"></p>
<h3 id="布雷维-x2F-半拿铁（Cafe-Breve）"><a href="#布雷维-x2F-半拿铁（Cafe-Breve）" class="headerlink" title="布雷维/半拿铁（Cafe Breve）"></a>布雷维/半拿铁（Cafe Breve）</h3><p>很像拿铁，不同是加入了的不是牛奶，而是半牛奶、半奶油的混合物，有时会再加少许奶泡。公认的配方是：1份浓缩咖啡+0.75份热牛奶+0.75份鲜奶油+0.5份奶泡。</p>
<h3 id="卡布奇诺（Cappuccino）"><a href="#卡布奇诺（Cappuccino）" class="headerlink" title="卡布奇诺（Cappuccino）"></a>卡布奇诺（Cappuccino）</h3><p>卡布奇诺和拿铁咖啡的成分一样，都是Espresso+牛奶+奶泡，不同之处仅在于卡布奇诺奶泡比牛奶多，拿铁则是牛奶比奶泡多。传统的卡布奇诺咖啡是三分之一浓缩咖啡，三分之一蒸汽牛奶和三分之一泡沫牛奶。同等价位的卡布奇诺，通常比拿铁要小杯，但咖啡味更浓郁。<br>卡布奇诺是意大利咖啡与牛奶的经典之作，咖啡的颜色就像卡布奇诺教会修士深褐色外衣上覆的头巾一样，咖啡因此得名。可根据自己口味调整牛奶与咖啡的比例，牛奶味重称为湿卡布奇诺，咖啡味重称为干卡布奇诺。</p>
<h3 id="摩卡（Caffe-Mocha）"><a href="#摩卡（Caffe-Mocha）" class="headerlink" title="摩卡（Caffè Mocha）"></a>摩卡（Caffè Mocha）</h3><p>一种最古老的咖啡，得名于著名的摩卡港。摩卡的配方成分就相对比较复杂，在Espresso和牛奶的基础上，还有巧克力酱，顶端不是奶泡，而是打发的鲜奶油，还往往会挤上巧克力酱，或者撒上可可粉、肉桂粉，别有一番风味。由于“内容丰富”，通常售价较高，也比较大杯。巧克力和奶油都有甜味，因此摩卡咖啡是苦甜结合的典范。</p>
<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-4.jpg" alt="焦糖玛奇朵-爱尔兰咖啡-维也纳咖啡"></p>
<h3 id="焦糖玛奇朵（Caramel-Macchiato）"><a href="#焦糖玛奇朵（Caramel-Macchiato）" class="headerlink" title="焦糖玛奇朵（Caramel Macchiato）"></a>焦糖玛奇朵（Caramel Macchiato）</h3><p>即加了焦糖的玛奇朵，是在香浓热牛奶上加入浓缩咖啡、香草，最后淋上纯正焦糖而制成的饮品，特点是在一杯饮品里可以喝到三种不同的口味。</p>
<h3 id="爱尔兰咖啡（Irish-Coffee）"><a href="#爱尔兰咖啡（Irish-Coffee）" class="headerlink" title="爱尔兰咖啡（Irish Coffee）"></a>爱尔兰咖啡（Irish Coffee）</h3><p>爱尔兰咖啡（Irish Coffee）是一款鸡尾酒，是以爱尔兰威士忌为基酒，配以咖啡为辅料，调制而成的一款鸡尾酒。据说爱尔兰咖啡背后还有一段浪漫的爱情故事，不过我觉得就像卡农背后的爱情故事一样，不必较真。</p>
<h3 id="维也纳咖啡（Viennese-Coffee）"><a href="#维也纳咖啡（Viennese-Coffee）" class="headerlink" title="维也纳咖啡（Viennese Coffee）"></a>维也纳咖啡（Viennese Coffee）</h3><p>奥地利最著名的咖啡，是一个名叫爱因·舒伯纳的马车夫发明的，也许是由于这个原因，今天，人们偶尔也会称维也纳咖啡为“单头马车”。在温热的咖啡杯底部撒上薄薄一层砂糖或细冰糖，接着向杯中倒入滚烫而且偏浓的黑咖啡，最后在咖啡表面装饰两勺冷的新鲜奶油，一杯维也纳咖啡就做好了。</p>
<p>综上，发现除了浓缩咖啡和美式咖啡之外，其他咖啡的含糖量都不低。公司附近就有一家星巴克，实践是检验真理的唯一标准。一个星期上一种咖啡，也够我玩三个月了。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">Previous</a></div><div class="pagination-next"><a href="/page/4/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Mark Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mark Cao</p><p class="is-size-6 is-block">程序的世界让我着迷</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ChangSha</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/industriousonesoft" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/industriousonesoft"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">December 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">August 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">May 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">August 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">June 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">May 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">November 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">October 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/09/"><span class="level-start"><span class="level-item">September 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/08/"><span class="level-start"><span class="level-item">August 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">May 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">April 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/03/"><span class="level-start"><span class="level-item">March 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">February 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">January 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-06-27T13:34:07.000Z">2019-06-27</time></p><p class="title"><a href="/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/">初识汇编-知识点摘记</a></p><p class="categories"><a href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-12-01T03:33:07.000Z">2018-12-01</time></p><p class="title"><a href="/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/">《三体》系列第一部读后感之生存还是死亡？</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E8%AF%84/">书评</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-14T14:37:07.000Z">2018-11-14</time></p><p class="title"><a href="/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/">需求第三定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-13T14:13:07.000Z">2018-11-13</time></p><p class="title"><a href="/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/">需求第二定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-11T01:18:07.000Z">2018-11-11</time></p><p class="title"><a href="/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/">需求第一定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/Objective-C/"><span class="level-start"><span class="level-item">Objective-C</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/"><span class="level-start"><span class="level-item">专业</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/OSX/"><span class="level-start"><span class="level-item">OSX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/%E7%BF%BB%E8%AF%91/"><span class="level-start"><span class="level-item">翻译</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E8%AF%84/"><span class="level-start"><span class="level-item">书评</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BD%B1%E8%AF%84/"><span class="level-start"><span class="level-item">影评</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">汇编</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARC/"><span class="tag">ARC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Category/"><span class="tag">Category</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cocoa/"><span class="tag">Cocoa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coffee/"><span class="tag">Coffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaSctript/"><span class="tag">JavaSctript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KVO/"><span class="tag">KVO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OSX/"><span class="tag">OSX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Objective-C/"><span class="tag">Objective-C</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PlistBuddy/"><span class="tag">PlistBuddy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RunLoop/"><span class="tag">RunLoop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%89%E4%BD%93/"><span class="tag">三体</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"><span class="tag">人物传记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"><span class="tag">人类简史</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%B1/"><span class="tag">爱</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a><p class="is-size-7"><span>&copy; 2022 Mark Cao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>