<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MarkCao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MarkCao"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MarkCao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="MarkCao"><meta property="og:url" content="http://naivertc.top/"><meta property="og:site_name" content="MarkCao"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://naivertc.top/img/og_image.png"><meta property="article:author" content="Mark Cao"><meta property="article:tag" content="WebRTC, C++, iOS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://naivertc.top"},"headline":"MarkCao","image":["http://naivertc.top/img/og_image.png"],"author":{"@type":"Person","name":"Mark Cao"},"publisher":{"@type":"Organization","name":"MarkCao","logo":{"@type":"ImageObject","url":"http://naivertc.top/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="MarkCao" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-10-15T04:16:07.000Z" title="10/15/2016, 12:16:07 PM">2016-10-15</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a></span><span class="level-item">2 minutes read (About 298 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/10/15/Objective-C%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/">Objective-C中布尔类型</a></h1><div class="content"><p> Objective-C中的BOOL类型在iWatch和64位iOS上的原始类型为bool，而在其它情况下是signed char。</p>
<p>用@encode去看看BOOL的类型串：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 64位iOS系统："B"</span></span><br><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 32位iOS系统，32/64位OS X："c"</span></span><br></pre></td></tr></tbody></table></figure>

<p>众所周知，在C\C++语言中bool类型中的两个常量false为0，true为1，且非0值都被认为true。Objective-C是建立在C++基础的面相对象的语言，因此bool的定义应该也是如此。</p>
<p>下面对两种情况分别讨论：</p>
<p><strong>typeof BOOL bool</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：This is YES。说明变量被赋值为1，而非数字7。</p>
<p><strong>typeof BOOL signed char</strong></p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：This is NO。说明变量被赋值为数字7。</p>
<p>综上所述，在Objective-C中进行布尔比较时，不建议直接将布尔变量和YES或者true做比较，即：if( a == YES )。但是可以和NO或者false做比较，即：if( a != NO )，也可以写成if( a )或者if( !a )的形式。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-10-15T04:16:07.000Z" title="10/15/2016, 12:16:07 PM">2016-10-15</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a></span><span class="level-item">4 minutes read (About 568 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/10/15/%E4%BD%BF%E7%94%A8PlistBuddy%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9APP%E5%90%8D%E7%A7%B0/">使用PlistBuddy命令动态修改APP名称</a></h1><div class="content"><p>当一个工程里面包含多个target且每个target都有本地化的名称，一般做法是为每个target配备一个InfoList.strings文件。随着target数量和支持的语种增多，InfoList.strings文件数量也增加，更改和管理target名称也会变得复杂。</p>
<p>我们可以在工程里面只保留一个InfoList.strings文件用于显示当前编译的target本地化名称，并且将所有target的本地化名称用一个plist文件统一管理，然后使用shell脚本和PlistBuddy命令在编译阶段动态修改target名称。以下是具体实现：</p>
<p>假设工程中有4个target，本地化需求为英语（en）和西班牙语言（es）。</p>
<p>1、在Xcode中创建一个名为ProductName.plist文件，并保存至工程根目录。注意：这个文件不需要和任何target关联。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_1<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_1_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_1_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_2<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_2_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_2_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_3<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_3_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_3_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_4<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_4_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_4_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>2、Info.plist中有个叫CFBundleDisplayName的key决定APP的名称，创建一个InfoList.string文件并关联所有的target。在InfoList.string文件修改CFBundleDisplayName即可更改APP名称,格式如下所示：</p>
<p>CFBundleDisplayName=”xxxxxxxxxx”;</p>
<p>3、在project的“Build Settings”中新建一个“Use_Defined Setting”命名为MY_PRODUCTID，然后为每一个target设置对应的ID。此处分别为四个target命名为：ProductId_1、ProductId_2、ProductId_3、ProductId_4。</p>
<p>4、在工程的“build Phases”界面中新建一个脚本块，脚本内容如下：</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#PRODUCT_NAEMS_FILE_PATH的路径</span></span><br><span class="line">PRODUCT_NAEMS_FILE_PATH=<span class="string">"<span class="variable">${SRCROOT}</span>/PRODUCT_NAEMS_FILE_PATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取对应ProductId的plist</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"print <span class="variable">${MY_PRODUCTID}</span>"</span> -x <span class="string">"<span class="variable">${PRODUCT_NAEMS_FILE_PATH}</span>"</span> &gt; <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取ProductId.plist对应的本地化名称</span></span><br><span class="line">EN_NAME=$(/usr/libexec/PlistBuddy -c <span class="string">"print en"</span> <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span> )</span><br><span class="line">ES_NAME=$(/usr/libexec/PlistBuddy -c <span class="string">"print es"</span> <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置InfoPlist.strings对应的本地化文件中的CFBundleDisplayName字段值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CFBundleDisplayName=\"<span class="variable">${EN_NAME}</span>\";"</span> &gt; <span class="string">"<span class="variable">${SRCROOT}</span>/en.lproj/InfoPlist.strings"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CFBundleDisplayName=\"<span class="variable">${ES_NAME}</span>\";"</span> &gt; <span class="string">"<span class="variable">${SRCROOT}</span>/es.lproj/InfoPlist.strings"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>5、编译target，即可在InfoPlist.strings看到对应的本地化名称。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-09-24T15:10:07.000Z" title="9/24/2016, 11:10:07 PM">2016-09-24</time></span><span class="level-item"><a class="link-muted" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></span><span class="level-item">8 minutes read (About 1127 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/09/24/%E5%89%AF%E8%AF%8D%E8%83%BD%E5%90%A6%E4%BF%AE%E8%BE%9E%E5%90%8D%E8%AF%8D/">副词能否修辞名词？</a></h1><div class="content"><blockquote>
<p>之前知乎上看到一提问，大意是：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？最近恰好在旋元佑先生的《文法俱乐部》一书中找到了合理的解释，借此机会梳理一下这个知识点。</p>
</blockquote>
<p>结合上述问题：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？，可以从两个方面进行解答：</p>
<ol>
<li><p>The Lamb Astray中的Astray是形容词词性，属于形容词后置的情况</p>
</li>
<li><p>副词可以修辞名词</p>
</li>
</ol>
<h3 id="形容词后置"><a href="#形容词后置" class="headerlink" title="形容词后置"></a>形容词后置</h3><p>形容词常见的所处位置包括名词片语、表语、主【宾】语补语，此外还有一个位置：名词后面，属于形容词后置的情况。</p>
<p>在以下三种情况，形容词需要后置：</p>
<ol>
<li><p>复合名词后面：</p>
<p> 类似someone这样的符合名词，因为限定词 some 和 名词 one 组合成一个词，原本名词片语中在限定词和名词之间存放形容的位置被挤压掉了，因此只能把形容词置于名词之后。</p>
<p> 比如：</p>
<ul>
<li>someone else //其他人</li>
<li>someone important //某些重要的人</li>
</ul>
</li>
<li><p>一部分a-开头的形容词：</p>
<p> 有一部分a-开头的形容词通常放在补语或者表语的位置，也可以放在名词片语后面。</p>
<p> 比如：</p>
<ul>
<li>Jane and her mother alike are teather. //珍和她妈妈一样是老师</li>
<li>Tom alone is coming. //只有汤姆要来</li>
<li>wood adrift //漂流的木头</li>
</ul>
</li>
<li><p>外来词或者惯用法：</p>
<p> 英语中习惯把形容词放在名词前面，但是有些语言中例如法文，形容词是放在名词后面的。因此一些外来语或者惯用语，都要把形容词放在名词后面。</p>
<p> 比如：</p>
<ul>
<li>Secretary General //秘书长</li>
<li>Poet Laureate //桂冠诗人</li>
<li>Aisa Minor //小亚细亚</li>
<li>heir apparent //合法继承人</li>
</ul>
</li>
</ol>
<h3 id="副词修辞名词"><a href="#副词修辞名词" class="headerlink" title="副词修辞名词"></a>副词修辞名词</h3><p>正如一般文法书上所说，一般情况下形容词修辞名词而副词则用于修辞除了名词以外的其他词类，包括形容词、动词和副词。这种说法基本上成立，但是也有特殊情况。</p>
<p>存在一类表示强调功能的副词，可以修辞名词、动词、形容词和副词，修辞范围很广。也正因为如此，所以这类副词只能放在修饰词前面，确保修辞对象在其后面，以免出现歧义。</p>
<p>这一类副词又可以细分为三种：</p>
<ol>
<li><p>强调范围的副词</p>
<p> 典型代表：only, merely, also, especially, particularly, even等</p>
<p> 以Only举例：</p>
<ul>
<li>I heard about the accident yesterday.  //我昨天听说了这件意外</li>
<li>Only I heard about the accident yesterday. //只有我听说了…</li>
<li>I only herad about the accident yesterday. //只是听说，并没有看到</li>
<li>I heard about only the accident yesterday. //昨天全在听人在谈论这件意外</li>
<li>I heard about the accident only yesterday. //直到昨天才听说</li>
</ul>
<p> 这几个句子里only分别修饰了代名词I、动词heard、名词the accident和时间副词yesterday，都是当副词使用。</p>
</li>
<li><p>强调语气的副词</p>
<p> 这是最典型的副词，同样也可以修饰名词在内的四种主要词类。</p>
<p> 举例如下：</p>
<ul>
<li>He is very much his father’s son.  //他和他爸爸一个调调</li>
<li>You’re utterly insane! //你是完完全全疯了</li>
<li>I badly need a drink.  //我急需来一杯</li>
</ul>
</li>
<li><p>程度副词</p>
<p> 这一类副词和加强语气的副词很像，但是程度副词是用来做有几成的表示，而非加强语气。所以，如果把加强语气的副词，只是语气变弱，意思不会变。但是如果拿掉程度副词，意思就可能发生改变。</p>
<p> 举例：</p>
<ul>
<li>The project is almost finished. //项目已经完成的差不多了。<br> ps:上面的句子如果去掉almost，这句话的意思完全变了</li>
</ul>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>旋元佑先生的《文法俱乐部》是一本不可多得的文法书，它区别于传统文法书的教条式+填鸭式的讲解方式，而是追本溯源，从理解本质和语言使用的角度为读者拨开文法的迷雾。    </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-08-08T14:25:07.000Z" title="8/8/2016, 10:25:07 PM">2016-08-08</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">38 minutes read (About 5693 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/08/08/%E6%8F%AD%E7%A7%98dispatch_once/">揭秘dispatch_once的内部实现</a></h1><div class="content"><p>这是一篇译文，原文<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html">Secrets of dispatch</a>的作者是Mike Ash大神。在拜读这篇文章之后，颇有收获，不得不感叹Mike Ash专业知识的深度与广度。因此，我想试着进行翻译以加深理解。</p>
<p><strong>以下是原文</strong></p>
<p>一位名为Paul Kim的读者向我推荐了Micheal Tsai的一篇关于“让dispatch_once执行更快”的博客。虽然dispatch_once源代码中的注释精彩且详实，但是它并没有深入剖析那些让人着迷的细节。因为这是我最喜欢研究的方面之一，所以今天的文章我将进行深入地探究dispatch_once内部逻辑和实现原理。</p>
<h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p>dispatch_once函数顾名思义，它只执行一次且唯一的一次。函数接收两个参数，第一个参数是一个predicate，用于跟踪和保证函数的“一次性”；第二个参数是一个block，在函数第一次被调用时执行。调用方式如下所示：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate , ^{</span><br><span class="line">	<span class="comment">//执行一次性的任务</span></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这个函数很适用于共享状态的“懒初始化”，适用范围包括全局字典、单例实体、缓存或者其他任何需要在第一次执行时进行配置的地方。</p>
<p>在只有单线程的环境中，这种调用方式显得有些繁琐，用一个简单的if语句就能取而代之。然而，我们现在面临的都是多线程的运行环境，且diaspatch_once是线程安全的。这就保证了即使多个线程同时调用dispatch_once函数，函数也只执行一个block，并且所有线程直到block中的任务执行结束且dispatch_once退出之前都会处于阻塞状态。尽管你自己实现一个类似的函数不是很难，但是dispatch_once函数执行速度相当之快，并且实现的难度很大。</p>
<h4 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h4><p>让我们先看一个这个函数精简后的单线程版本。虽然这个版本没有实用性，但是让我们对这个函数有一个具体的视觉感官。注意到dispatch_once_t只是一个long整型，且初始化为0，根据实现被赋予不同的含义。以下是实现：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SimpleOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!*predicate)</span><br><span class="line">	{</span><br><span class="line">		block();</span><br><span class="line">		*predicate = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现很简单：如果predicate是0，执行block且更新predicate的值为1。后续的函数调用会发现predicate未非0值便不会重复执行block。如果不是因为在多线程环境是不安全的，这完全就是我们想要的结果。糟糕的是，如果两个线程可能同时访问if语句，会导致block被调用两次。很不幸，这种情况时有发生，因此，让这份代码变成线程安全意味着一次实质性的成功。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>当谈及dispatch_once的性能时，主要有以下三种不同的情景：</p>
<p>1、第一次调用dispatch_once时，指定一个predicate，并执行block.<br>2、在第一次调用dispatch_once之后且block未执行完之前，后续调用线程必须等待直到block执行完成。<br>3、在第一次调用dispatch_once且执行完成之后，后续调用不需要等待而是立即执行。</p>
<p>情景1基本上不影响性能，毕竟只执行一次，只要block执行速度不是太慢。</p>
<p>情景2同样不太影响性能。这个情况可能潜在地发生好几次，但是只有在block未执行完才会发生。大多数情况，这种情况几乎不会发生。如果发生了也可能是仅仅出现一次。甚至在极端测试下：很多线程同时调用dispatch_once并且block执行时间很长，后续处于等待的调用也局限在几千个以内。这些后续调用线程全都必须等待block执行完成，所以即使这些线程在等待过程中耗费了一些不必要的CPU时间也是无关紧要的。</p>
<p>情景3则是性能高低的关键所在。这种性质的调用可能在程序中潜在发生成千上万次。我们想通过dispatch_once来保护那些一次性运算，运算结果被作为调用的返回值。理想情况下，dispatch_once的性能应该可以与直接读取一个提前初始化好的全局变量的性能媲美。换言之，一旦你面临情景3，我们想让下面两个代码块执行的效率是一样的。</p>
<p>代码段1：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> gObject;</span><br><span class="line"><span class="keyword">void</span> Compute(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	gObject = ....;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> Fetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> gObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码段2：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> DispatchFetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">id</span> object;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;predicate, ^{</span><br><span class="line">            object = ...;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在被编译器内联处理和优化之后，SimpleOnce函数的执行效率接近DispatchFetch函数。在我电脑上测试，DispatchFetch函数执行时间为0.5纳秒。这无疑是线程安全版本中的黄金标准。</p>
<p>如何自己实现一个的dispatch_once版本，关键在于确保线程安全，以下列出几种方式：</p>
<h4 id="使用线程锁"><a href="#使用线程锁" class="headerlink" title="使用线程锁"></a>使用线程锁</h4><p>常规的线程安全的做法是在共享数据访问前后添加锁。因为是示例代码，我决定只用一个单一的全局锁变量来做。代码中使用一个静态线程锁变量pthread_mutex_t来保护predicate的线程安全。在实际的项目中，随着函数被多个不同的类调用，伴随着很多不同的predicate变量，这将会是一个糟糕的设计。因为每一个互不关联的predicate变量必须一直等待当前被保护的predicate解锁才能获得执行机会。作为一个快速测试，这里我仅仅只测试一个predicate的情况。这份代码除了加了锁之外与前面的SimpleOnce函数没有区别：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LockedOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">            block();</span><br><span class="line">            *predicate = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码是线程安全的，但不幸的是执行速度太慢。在我的电脑上测试结果为每次调用需要30纳秒，相较于上述0.5纳秒的版本实在差太远。线程锁已经算很快的了，但不属于纳秒级别的。</p>
<h4 id="使用自旋锁"><a href="#使用自旋锁" class="headerlink" title="使用自旋锁"></a>使用自旋锁</h4><p>自旋锁是一种试图将额外的开销降到最低的锁。顾名思义，自旋锁在处于需要等待的时候拥有“自旋”的功能，不断地轮询临锁的状态查看是否已经解锁。一般的锁都会配合操作系统休眠正在等待的线程，等解锁之后再唤醒所在的线程。这种锁虽然节省了CPU时间，但是这种协调休眠的机制也是有代价的。自旋锁不会休眠等待线程，因此在处于等待解锁的情况下节省了很多时间，付出的代价则是当多个线程试图获得自旋锁时效率会比较低。</p>
<p>MacOS X提供了<a target="_blank" rel="noopener" href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/spinlock.3.html">一套便利的自旋锁API</a>名为OSSpinLock.使用OSSinLock实现LockedOnce只需要在原有的基础修改几个名称：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpinlockOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">       <span class="keyword">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line">       OSSpinLockLock(&amp;lock);</span><br><span class="line">       <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">           block();</span><br><span class="line">           *predicate = <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">       OSSpinLockUnlock(&amp;lock);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<p>这次有了相当大的提升。在我电脑上测试结果为每次调用需要6.5纳秒，远好于pthread_mutex版本的每次调用30纳秒。然而于dispatch_once比起来还是太慢了。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作是底层CPU级别的操作且即使没有锁也一直都是线程安全。从技术层面来说，它们使用的硬件锁。使用锁会带来额外的开销，直接使用原子操作可以带来性能上的提升。多线程编程没有锁可能会显得很别捏，所以除非你真的需要原子操作，否则这不是明智的选择。我们现在讨论的是一个可能会被频繁使用的系统库，因此也许值得添加原子操作。</p>
<p>原子操作创建锁的过程是“比较并交换”。这是一个类似于下面代码的简单操作：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> CompareAndSwap(<span class="keyword">long</span> *ptr, <span class="keyword">long</span> testValue, <span class="keyword">long</span> newValue) {</span><br><span class="line">	<span class="keyword">if</span>(*ptr ==  testValue) {</span><br><span class="line">		*ptr = newValue;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>总而言之，函数CompareAndSwap的功能用来测试内存的一个地址是否存储着一个特定的值，如果是则用新的值替换原有的值，返回结果表示匹配成功与否。因为“比较并交换”是一个CPU级的原子指令，所以即使有多个线程都试着对同一个内存区域进行“比较并交换”的操作都能确保其中只有一个操作能够成功。</p>
<p>LockedOnce的这个版本的实现策略是对predicate赋予三个不同的值。0表示函数还未被调用过；1表示函数block正处于执行状态，后续调用线程则处于等待状态；2表示block执行完成且释放阻塞的等待线程并返回结果。</p>
<p>“比较并交换”原子操作将被用于检测predicate的值是否为0，如果是则自动更新predicate为1。一旦原子操作返回的是YES，意味着当前线程是第一个调用线程，并开始唯一一次地block执行。在block执行完成后更新predicate的值为2作为标识.</p>
<p>如果“比较并交换”原子操作执行失败意味着当前线程不是第一个调用者，然后线程进入一个循环，不断地检测predicate的值是否更新为2，直到predicate更新为2才退出循环。这将导致线程在block执行结束之前一直处于等待状态。</p>
<p>以下是这个版本的函数的具体：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">	<span class="comment">//将predicate指针转换成volatile指针，</span></span><br><span class="line">	<span class="comment">//以告知编译器这个变量的值可能在函数执行过程中被其他线程更改，</span></span><br><span class="line">	<span class="comment">//必须每次从内存地址取值，而非寄存器</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用“比较并交换”原子操作。</span></span><br><span class="line">	<span class="comment">//Gcc编译器和clang编译器均提供了各种以_sync开头的内置函数以实现原子操作。</span></span><br><span class="line">	<span class="comment">//下面的函数对predicate执行了“比较并交换”的原子操作，</span></span><br><span class="line">	<span class="comment">//检测predicate的值是否为0，如果是则更新为1</span></span><br><span class="line">	<span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">		<span class="comment">//执行block</span></span><br><span class="line">		block();</span><br><span class="line">		<span class="comment">//一旦block执行完成，更新predicate的值为2用以告知当前正在等待的调用线程以及未来的调用者block已经执行完成。</span></span><br><span class="line">		<span class="comment">//然而，考虑到CPU的优化机制，我们使用内存屏障以确保volatilePredicate值的读书顺序是正确的。</span></span><br><span class="line">		<span class="comment">//使用内置函数__sync_synchronize在此出设置内存屏障，</span></span><br><span class="line">		<span class="comment">//确保volatilePredicate在block执行完后立即更新为2，且在此之前不可读。</span></span><br><span class="line">		__sync_synchronize();</span><br><span class="line">		<span class="comment">//更新</span></span><br><span class="line">		*volatilePredicate = <span class="number">2</span>;</span><br><span class="line">	}<span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">//等待线程循环检测</span></span><br><span class="line">		<span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>);</span><br><span class="line">		<span class="comment">//线程返回之前设置内存屏障，匹配if语句中的内存屏障设置，保证volatilePredicate读取一致性</span></span><br><span class="line">		__sync_synchronize();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码满足需求且是线程安全的，但是性能一般。在我电脑上每次调用时间为20纳秒，明显高于自旋锁版本。</p>
<h4 id="提前预判"><a href="#提前预判" class="headerlink" title="提前预判"></a>提前预判</h4><p>这里有一个显而易见的优化可以添加到原子操作的版本中。因为通常情况下都是predicate的值已经是2，在函数最开始的地方加一个判断语句，可以在大多数情况下加快函数执行速度：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>) {</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>这个版本的执行效率有相当大的提升，大约是调用一次11.5纳秒。然而，对比与dispatch_once版本还是相去甚远，甚至不如自旋锁版本。</p>
<p>设置内存屏障有额外的开销，这也是为什么这个版本的执行速度比dispatch_once慢的原因所在。至于为什么会比自旋锁版本慢，是因为代码中设置了不同类型的内存屏障。__sync_synchronize函数会产生一个mfence的指令，这个指令是可能是最耗费资源的指令之一，然而OSSpinLock使用的是一个效率更高的指令。我们可以尝试不同的内存屏障以到达更好的效果，但是很明显代码最终的执行速度未达到我们预期结果，因为我打算弃用这种方法。</p>
<h4 id="非线程安全的提前预判"><a href="#非线程安全的提前预判" class="headerlink" title="非线程安全的提前预判"></a>非线程安全的提前预判</h4><p>这个版本与上面的版本很类似，只不过将内存屏障移除了：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UnsafeEarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>不出意外，这个版本的执行速度与SimpleOnce一样都是0.5纳秒。因为*predicate == 2的适用于大多数情况，差不多每次调用都是检测predicate的值并返回。这个版本除了第一次执行block之外，几乎与SimpleOnce函数一样。</p>
<p>正如函数名所示，这是一个非线程安全版本，缺少了内存屏障导致线程不安全。原因何在？</p>
<h4 id="CPU流水线执行方式"><a href="#CPU流水线执行方式" class="headerlink" title="CPU流水线执行方式"></a>CPU流水线执行方式</h4><p>我们可以将CPU想象成一个简单的机器，我们告诉它做什么，它就做什么。如此反复直到天荒地老。</p>
<p>曾经有一段时间确实如此。老版的CPU的工作方式很简单，一眼一板。不幸的是，这种方式简单，容易且成本低，但是执行效率低。根据摩尔定律，CPU内置的晶体管成指数增长。8086CPU内置了大约29000个晶体管。一个英特尔处理器CPU集成了超过十亿的晶体管。</p>
<p>根据市场需求决定了CPU拥有更好的效率，现在的CPU集成了越来越多的晶体管旨在让电脑运行速度更快。</p>
<p>这里面有很多技巧让CPU执行的更快。其中一种就是流水线。执行单一的CPU指令，分成多个小步骤：</p>
<ol>
<li>从内存加载指令</li>
<li>指令解码（分析指令解析包含哪些运算操作）</li>
<li>加载输入数据</li>
<li>结合输入执行运算</li>
<li>保存输出数据</li>
</ol>
<p>在一个早期的CPU，上述流程执行步骤如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加载指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">加载下一个指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>在一个流水线型的CPU，执行步骤则如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加载指令  </span><br><span class="line">解码				加载指令		</span><br><span class="line">加载数据			解码				加载指令</span><br><span class="line">运算				加载数据			解码</span><br><span class="line">保存输出			运算				加载数据</span><br><span class="line">					保存输出			运算</span><br><span class="line">										保存输出</span><br></pre></td></tr></tbody></table></figure>
<p>这种方式执行速度快很多。随着CPU中的晶体管数量越来越多，CPU内部结构也越来越复杂，同步执行的指令也越来越多。<br>更有甚者，如果可以让速度更快，指令的执行顺序会被完全打乱。不同于上述简单的例子，真实情况下，指令更为复杂以及变量更多。</p>
<p>代码执行的顺序并不以总是与代码本身的顺序一致的，比如下面的代码：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>CPU可能会先写入Y变量的值。有些情况下编译器也会对语法重新排序，即便你屏蔽了编译器的行为，CPU仍然会乱序执行。如果是多核CPU，在其他的CPU看了写入的顺序是乱序的。即使是按代码顺序写入的，其他的CPU也会乱序读取。综合考虑，其它的线程在读取x和y的值时会发现y的值已经改变而x还是原来的值。</p>
<p>在你需要这些值必须按照既定的顺序写入的时候，内存屏障就派上用场了。设置内存屏障以确保上述代码中x的值先被更新：</p>
<ul>
<li>x = 1;</li>
<li>memory_barrier();</li>
<li>y = 2;</li>
</ul>
<p>同样地，内存屏障可以确保读的顺序：</p>
<ul>
<li>use(x);</li>
<li>memory_barrier();</li>
<li>use(y);</li>
</ul>
<p>然而，因为内存屏障的主要功能导致CPU的执行速度，所以自然而然影响性能。</p>
<p>对于dispatch_once来说，代码必须按照既定的顺序执行，因此必须设置内存屏障。但是，内存屏障会导致代码效率低下，所以为了避免额外的开销，我们想办法避免设置内存屏障。</p>
<h4 id="CPU的分支预测和推测性执行"><a href="#CPU的分支预测和推测性执行" class="headerlink" title="CPU的分支预测和推测性执行"></a>CPU的分支预测和推测性执行</h4><p>流水线和乱序工作模式适用于一系列线性执行的指令，但是对于添加分支语句则变得麻烦。CPU在分支语句执行完之前不知道下一步该执行什么指令，因此不得不停止运行等待前面的分支语句结束再重新运行。这就是所谓的pipeline stall，在一定程度上影响CPU性能。</p>
<p>为了弥补pipeline stall带了的性能损失，CPU加入了推测性执行。当CPU遇到一个分支语句则会进行分支预测判断哪一个分支可能被执行。现在的CPU配置精密的分支预判硬件，准确率在90%以上。在做出预判之后，CPU开始执行假设的分支中的代码块，而不是等待分支语句的结果。如果分支预判是正确的则继续后续执行。如果预判错误则清空推测执行结果重新执行另外一个分支代码块。</p>
<p>这种情况被用在了dispatch_once的读取端，这也是我们期望执行速度越快越好的地方。dispatch_once中有一个判断predicate的值得分支语句。CPU应该会预判并执行else分支，因为这个大多数情况下会执行的分支，即绕过block执行然后立即返回结果。在推测性执行过程中，CPU可能会从内存中加载那些后续需要但是还未被其他线程初始化的变量。如果分支预判是正确的，CPU会使用未初始化的值进行推测性执行。</p>
<h4 id="非对称屏障"><a href="#非对称屏障" class="headerlink" title="非对称屏障"></a>非对称屏障</h4><p>内存屏障一般都是需要对称的：在写的一端确保按照正确的顺序写入，在读的一端确保按照正确的顺序读取。然而，我们需要非对称屏障来满足我们的性能需求：我们可以容忍写入端的速度缓慢，但是让读的速度越快越好。</p>
<p>这个技巧用来防范推测性执行导致的问题。当分支预判是错误的，推测性执行的结果会被弃用。如果dispatch_once可以在初始化完成之后强制确定CPU的分支预判，这个问题则可以被避免。</p>
<p>此处有一个间隔时间，即最初的推测性执行到条件语句执行结束之间的间隔时间。间隔具体的时间因CPU而异，但是最多几十个CPU周期的时间。</p>
<p>在英特尔CPU中，dispatch_once使用spuid指令到达上述目的。cpuid指令主要是用于获取CPU的ID和功能等信息，但是也可以强行序列化指令流并需要耗费几百个CPU周期的时间。</p>
<p>在dispatch_once的源代码中，你会发现在读的一端没有使用内存屏障：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_<span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) {</span><br><span class="line">        <span class="built_in">dispatch_once</span>(predicate, block);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></tbody></table></figure>
<p>这段代码位于头文件中，并内联只调用者的代码块。DISPATCH_EXPECT宏告诉编译器去告知CPU：*predicate = ~0l是更有可能发生的分支。这可以提高分支预判的准确性，继而提升执行效率。基本上，这里只有一个普通的if语句，没有设置任何屏障。调用dispatch_once的执行速度接近0.5纳秒的黄金标准。</p>
<p>在dispatch_once实现文件中可以看到写入端的实现，在block执行后立即执行了下面的宏：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_atomic_maximally_synchronizing_barrier();</span><br></pre></td></tr></tbody></table></figure>
<p>在英特尔的CPU中，这个宏使用了cpuid指令，在其他的CPU框架中也会产生类似的指令。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>多线程是最奇怪和复杂的地方，现代的CPU在背后做了很多不为认知的事情。内存屏障允许你告知硬件按照你需要的顺序执行代码，但是相应的需要在性能上做出牺牲。dispatch_once有着独一无二的需求，让CPU不走寻常路：在相关的内存写入完成之前牺牲足够多的等待时间，但是确保每一次读取都是高效安全的且不需要额外的内存屏障。            </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-05-10T15:50:07.000Z" title="5/10/2015, 11:50:07 PM">2015-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Cocoa/">Cocoa</a></span><span class="level-item">11 minutes read (About 1723 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/05/10/KVO%E7%9A%84%E7%BC%BA%E9%99%B7/">KVO的缺陷</a></h1><div class="content"><blockquote>
<p>最近在学习和研究Cocoa库的KVO特性，期间发现大神Mike Ash的一篇关于讲述KVO缺陷的博客，觉得很有学习价值，遂想试着翻译以加深理解。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html">原文地址</a></p>
<h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>Cocoa的KVO特性强大和实用。可惜它的API真的有点糟糕，一些实现方式存在着固有的缺陷。我想探讨一下缺陷所在以及提供一套完善的方案。</p>
<h5 id="缺陷何在？"><a href="#缺陷何在？" class="headerlink" title="缺陷何在？"></a>缺陷何在？</h5><p>KVO的API中存在三个主要的问题，全部都与类的多重继承结构注册监听器相关。这很重要，因为即便是基类NSObject（通过实现函数-bind:toObject:withKeyPath:options:）也会创建监听。</p>
<p>1、-addObserver:forKeyPath:options:context:函数不接受一个自定义的回调函数</p>
<p>如果你查阅过相似的APIs，比如NSNotificationCenter，你会发现在为一个指定的消息注册监听器时通常涉及到传入一个回调函数作为注册函数的参数。这样可以很容易将当前类的监听事件与父类进行区分，因为你可以直接将消息导向你自己的回调方法。然而，你使用KVO则不得不重载-observeValueForKeyPath:ofObject:change:context:函数，然后在其中处理你监听的事件或者调用父类实现。判断是否需要处理一个消息或是传递给继承链的上一层处理是个复杂的问题，事实上父类也有可能监听了同样的键值路径或者对象。</p>
<p>2、上下文指针变成鸡肋</p>
<p>这个是上一个问题的推论。因为你不能自定义监听的回调函数，也无法通过检测键值路径或者对象来判断父类是否也监听了某个消息。你需要采取其他途径来区分一个消息对象是否属于当前类或是其父类。上下文指针就是为此而生的。你必须创建一个唯一的指针且不会被父类使用，然后做完上下文参数传入函数-addObserver:forKeyPath:options:context:中。随后，你必须在回调函数-observeValueForKeyPath:ofObject:change:context:中检测参数context是否属于当前类。因此，你不能用上下文指针指向一个上下文，也意味着失去了其本该有的功能。</p>
<p>3、-removeObserver:forKeyPath:接受的参数不完善</p>
<p>这个函数不能传入上下文指针。这意味着如果当前类和父类在不同时期都监听了同样的对象或是键值路径，你没办法移除你自己的监听。调用这个函数可能注销你的监听，也可能是注销父类的，或是甚至同时注销两者。</p>
<p>很可惜一个如此强大的工具会有这么严重的缺陷。尤其Apple开始在新的APIs中弱化NSNotification和代理回调的功能，取而代之的是KVO。一个典型的例子是NSOperation：获知一个NSOperation任务完成的唯一途径是通过使用KVO监听它的“isFinished”属性。</p>
<h5 id="完善方案"><a href="#完善方案" class="headerlink" title="完善方案"></a>完善方案</h5><p>那么我们能为此做点什么？我不想一味地抱怨，所以我写了一个类来解决这个问题。你可以从我的<a target="_blank" rel="noopener" href="https://github.com/mikeash/mikeash.com-svn/tree/master/">public svn repository</a>获取它，使用如下方式：</p>
<p>svn co <a target="_blank" rel="noopener" href="http://www.mikeash.com/svn/MAKVONotificationCenter/">http://www.mikeash.com/svn/MAKVONotificationCenter/</a></p>
<p>你也可以点击上面的链接查看源代码。</p>
<p>那么这个类具体实现是怎么样的？它利用了一个可以保证唯一性的指针：self指针。它不再直接使用目标对象注册某个监听通知（键值路径或者对象），取而代之的是为每个通知创建一个唯一的helper对象并且注册消息监听。随后，这个helper对象接收消息并派发给原有的监听者。因为helper对象对每一个监听者而言是唯一的，所以它可以以实例变量的方式持有关于监听者的元数据，而不需要依赖于上下文指针，至此上下文指针也完全作为函数所需的唯一指针。由于helper对象的职责就是监听KVO通知，监听者持有helper对象的生命周期，我们可以假设父类，NSObject，要么没有注册任何监听，要么监听同样持有一个helper作为监听助手。</p>
<p>MAKVONotificationCenter避开了上述的三个缺陷：</p>
<p>1、函数-addObserver:…中接受自定义回调函数作为参数，当被监听的键值路径发生变化时，自定义的回调函数会被调用。由于父类的回调函数是另外一个不同的函数，所以确保二者的监听不会互相干扰。</p>
<p>2、注册监听的函数中提供一个userinfo参数。可以是一个包含监听者任意信息的对象。</p>
<p>3、函数-removeObserver:…不再仅仅接受监听者和键值路径，还可以接受一个回调函数。这样即便子类和父类注册了同一键值路径或者同样的对象，二者都可以通过指定的回调函数注销监听，而不会影响彼此。</p>
<p>代码中一些值得注意的特征：</p>
<p>函数+defaultCenter中使用了<a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/late-night-cocoa.html">a simple lockless atomic call</a>保证了单例模式的线程安全，不需要每次访问时进行加锁处理。这是一个不错的技术，创建一个安全的单例对象，不需要在每次被访问时提前初始化或是进行加解锁处理。</p>
<p>以NSObjct分类的方式提供一组更为轻便和更优的API。这是一个相比于直接访问MAKVONotificationCenter类的单例更好的方式。在一个极端的情况，MAKVONotificationCenter类可能会从头文件移除，留下的只有NSObject的分类实现。</p>
<p>这份代码压根没有被测试过。我所做过的测试都在代码Tester.m中。在你使用之前不要轻易相信这份代码。150行代码并不算多，但是使用的后果自负。</p>
<p>如果你希望在你的项目里使用它，你也许只要注明代码出处就可以了。如果发现了代码的不足欢迎提供补丁。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-04-01T15:50:07.000Z" title="4/1/2015, 11:50:07 PM">2015-04-01</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">15 minutes read (About 2266 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/04/01/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0+load%E5%92%8C+initialize/">两个特殊函数+load和+initialize</a></h1><div class="content"><p>记得还在上一家公司任职的时候，在研发部的探讨会会上就“+load的加载过程”这一议题有过激烈的讨论，大家各执一词，争得面红耳赤。最终是部门老大专门做了一期讲解，才平息了这场争执。但是那时候的讲解并未涉及到源代码分析，而是基于测试代码做的分析，故我并没有完全理解。</p>
<p>在苹果开发文档中提及到：+load是在类或者分类被添加到runtime的时候被调用，而+initialize则是在类的用实例方法或者类方法第一次被调用之前调用。</p>
<p>上面的说明只是说明了这两个函数调用时机，但是并没有涉及父类、子类和分类之间的调用顺序和相互影响，于是试着结合<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">apple公司的开源代码</a>objc4-532.2试着分析这两个函数的加载过程，以加深理解。</p>
<h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>首先在objc-os.mm文件中找到函数_objc_load_image_objc_load_image：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class="line">{</span><br><span class="line">    prepare_load_methods(hinfo);</span><br><span class="line">    call_load_methods();</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>
<p>根据参数判断，这个函数应该是在加载镜像文件的时候由系统直接调用，且里面就两行代码，分别是对+load函数的预处理与加载</p>
<p>接着在objc-runtime-new.mm文件找查看prepare_load_methods的函数实现：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> prepare_load_methods(header_info *hi)</span><br><span class="line">{</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">	<span class="comment">//获取头文件中所有的类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="comment">//先处理类中的+load方法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="comment">//处理类与父类中的+load函数    schedule_class_load(remapClass(classlist[i]));</span></span><br><span class="line">    }</span><br><span class="line">	 <span class="comment">//再处理分类中的+load方法</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    	 <span class="comment">//初始化分类</span></span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(isRealized(cls-&gt;isa));</span><br><span class="line">        <span class="comment">//将可加载的（存在+load函数）分类归类</span></span><br><span class="line">        add_category_to_loadable_list((Category)cat);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(isRealized(cls));  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//递归调用，优先处理父类</span></span><br><span class="line">    schedule_class_load(getSuperclass(cls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也就意味着父类中的+load方法先被加入列表</span></span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, <span class="number">0</span>); </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>由上述函数可以推断出：父类的+load方法先于子类被加入待处理列表，分类与类中的+load方法是区分对待的。</p>
<p>接着，在objc-loadmethod.mm文件中查看call_class_loads函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> more_categories;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_assert_locked(&amp;loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先调用类中的+load方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) {</span><br><span class="line">        	<span class="comment">//先入先出处理+load函数列表</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        }</span><br><span class="line">			</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">//再调用分类中的+load函数</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    } <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = <span class="literal">NULL</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="comment">//先入先出的遍历顺序，调用父类函数先于子类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">//获得+load的函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">   		  <span class="comment">//注意：是通过函数指针直接调用，而非使用objc_msgSend，因此不会走runtime调用过程。</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) _free_internal(classes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  _class_isLoadable(cls)) {</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             _class_getName(cls), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//直接通过函数指针进行调用，而非通过objc_msgSend调用</span></span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中，先调用了类的+load函数列表，再处理分类中的+load函数，且都是直接通过函数指针调用。又因为父类的+load函数先于子类加入列表，因此+load函数的调用顺序是：父类-&gt;子类-&gt;分类</p>
<p>在上一篇博客<a target="_blank" rel="noopener" href="http://icebergcwp.com/2015/03/25/Objective-C%20Category%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Objective-C Category 深入浅出系列之实现原理</a>中结合源代码分析了Category的实现原理。其中有一个重要的知识点就是分类Category中函数会覆盖主类中同名的函数。然而这种情况发生的前提是函数必须是通过runtime机制（使用objc_msgSend发送消息）调用，因为这样才会通过遍历类的方法列表去获得方法对应的实现。</p>
<h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p>既然+initialize函数是在类的实例方法或者类方法第一次被调用之前触发，而类的实例方法或者类方法正常的调用方式是通过objc_msgSend函数。那么+initialize很有可能是在objc_msgSend函数中进行判断和触发，于是，在objc-msg-x86_64.s文件找到了objc_msgSend的汇编实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line">	</span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">	.private_extern __objc_tagged_isa_table</span><br><span class="line">__objc_tagged_isa_table:</span><br><span class="line">	.fill 16, 8, 0</span><br><span class="line"></span><br><span class="line">	ENTRY	_objc_msgSend</span><br><span class="line">	DW_START _objc_msgSend</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		// r11 = self-&gt;isa</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend  // r11=method, eq set (nonstret fwd)</span><br><span class="line">	jmp	*method_imp(%r11)	// goto *imp</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport	NORMAL</span><br><span class="line"></span><br><span class="line">// cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">	DW_MISS _objc_msgSend</span><br><span class="line">	GetIsa	NORMAL			// r11 = self-&gt;isa</span><br><span class="line">	MethodTableLookup %a1, %a2, _objc_msgSend	// r11 = IMP</span><br><span class="line">	cmp	%r11, %r11		// set eq (nonstret) for forwarding</span><br><span class="line">	jmp	*%r11			// goto *imp</span><br><span class="line"></span><br><span class="line">	DW_END 		_objc_msgSend, 1, 1</span><br><span class="line">	END_ENTRY	_objc_msgSend</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	DW_START _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	SaveRegisters _objc_msgSend_fixup</span><br><span class="line">	</span><br><span class="line">	// Dereference obj/isa/cache to crash before _objc_fixupMessageRef</span><br><span class="line">	movq	8(%a2), %a6		// selector</span><br><span class="line">	GetIsa	NORMAL			// r11 = isa = *receiver</span><br><span class="line">	movq	cache(%r11), %a5	// cache = *isa</span><br><span class="line">	movq	mask(%a5), %a4		// *cache</span><br><span class="line"></span><br><span class="line">	// a1 = receiver</span><br><span class="line">	// a2 = address of message ref</span><br><span class="line">	movq	%a2, %a3</span><br><span class="line">	xorl	%a2d, %a2d</span><br><span class="line">	// __objc_fixupMessageRef(receiver, 0, ref)</span><br><span class="line">	call	__objc_fixupMessageRef</span><br><span class="line">	movq	%rax, %r11</span><br><span class="line"></span><br><span class="line">	RestoreRegisters _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	// imp is in r11</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	cmp	%r11, %r11		// set nonstret (eq) for forwarding</span><br><span class="line">	jmp 	*%r11</span><br><span class="line"></span><br><span class="line">	NilTestSupport	NORMAL</span><br><span class="line">	</span><br><span class="line">	DW_END 		_objc_msgSend_fixup, 0, 1</span><br><span class="line">	END_ENTRY 	_objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	// Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>汇编基本就是大一水平，很有限。初略发现在调用指令_objc_msgSend之前，先调用了_objc_fixupMessageRef函数。</p>
<p>接着在objc-runtime-new.mm文件中找到_objc_fixupMessageRef函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXTERN IMP </span><br><span class="line">_objc_fixupMessageRef(<span class="keyword">id</span> obj, <span class="keyword">struct</span> objc_super2 *supr, message_ref_t *msg)</span><br><span class="line">{</span><br><span class="line">    IMP imp;</span><br><span class="line">    class_t *isa;</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">    msg-&gt;sel = sel_registerName((<span class="keyword">const</span> <span class="keyword">char</span> *)msg-&gt;sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(msg-&gt;sel)) {</span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        msg-&gt;imp = (IMP)&amp;vtable_ignored;</span><br><span class="line">        imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_VTABLE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;imp == (IMP)&amp;objc_msgSend_fixup  &amp;&amp;  </span><br><span class="line">        (vtableIndex = vtable_getIndex(msg-&gt;sel)) &gt;= <span class="number">0</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// vtable dispatch</span></span><br><span class="line">        msg-&gt;imp = vtableTrampolines[vtableIndex];</span><br><span class="line">        imp = isa-&gt;vtable[vtableIndex];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ordinary dispatch</span></span><br><span class="line">        <span class="comment">//常规的消息派发，遍历类的函数列表</span></span><br><span class="line">        imp = lookUpMethod((Class)isa, msg-&gt;sel, <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, obj);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在上述函数中调用了lookUpMethod函数，其中调用了prepareForMethodLookup函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IMP prepareForMethodLookup(Class cls, SEL sel, <span class="built_in">BOOL</span> init, <span class="keyword">id</span> obj)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRealized(newcls(cls))) {</span><br><span class="line">        rwlock_write(&amp;runtimeLock);</span><br><span class="line">        realizeClass(newcls(cls));</span><br><span class="line">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用_class_initialize对类进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init  &amp;&amp;  !_class_isInitialized(cls)) {</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, obj));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在objc-initialize.mm函数中，找到_class_initialize函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">{</span><br><span class="line">    assert(!_class_isMetaClass(cls));</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">BOOL</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">//递归，保证父类先于子类初始化</span></span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) {</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: calling +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//通过objc_msgSend调用+initialize函数</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: finished +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Done initializing. </span></span><br><span class="line">        <span class="comment">// If the superclass is also done initializing, then update </span></span><br><span class="line">        <span class="comment">//   the info bits and notify waiting threads.</span></span><br><span class="line">        <span class="comment">// If not, update them later. (This can happen if this +initialize </span></span><br><span class="line">        <span class="comment">//   was itself triggered from inside a superclass +initialize.)</span></span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>通过上述函数可知两点：一是父类的+initialize函数先于子类调用，二是+initialize不同于+load函数的采用函数指针调用，而是通过objc_msgSend函数调用，如果分类实现了+initialize函数，那么类（包括子类和父类）的+initialize函数就会被覆盖。</p>
<p>因此，+initialize的调用顺序是父类-&gt;子类，且分类的实现覆盖类的实现，因此分类中的+initialize可能会被多次调用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，对于+load和+initialize的调用规则和方式有了进一步的认识。在日后的编程过程中也可以根据二者的特点，更好的使用它们的功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-03-25T02:48:07.000Z" title="3/25/2015, 10:48:07 AM">2015-03-25</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A/">专业</a></span><span class="level-item">13 minutes read (About 2010 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/03/25/Objective-C%20Category%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Objective-C Category 深入浅出系列-第1话</a></h1><div class="content"><p>Objective-C Category（分类）之于我而言有种神秘感，虽然自己已经在实际开发过程中已经多次使用它，且感受到了它带来的便利与高效。但是我却仅仅是停留在对它的基本使用层面，除此之外一无所知。我能感觉它的强大，心中也一直有种对它内部实现一探究竟的冲动，奈何迟迟没有行动。时间愈久，这种情绪愈发浓烈，今天终究是按耐不住了…</p>
<h3 id="知其然"><a href="#知其然" class="headerlink" title="知其然"></a>知其然</h3><p>对于苹果应用开发者来说，开发者想要快速地了解或是回顾某个知识点，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">Apple开发者文档</a>往往是不二首选。</p>
<p>文档上如是说：你可以使用Category为一个已经存在的类添加额外的方法，比如Cocoa库中的类，即便是这个类的源代码是不可见的-不能子类化。使用Category给类添加的方法能被其子类继承，且在Runtime下其与类原有的方法是无差别的。</p>
<p>分类的使用场景：</p>
<ul>
<li>在不改变某个类源文件和不使用继承的前提下，为该类添加先的方法</li>
<li>声明类的私有方法</li>
<li>将一个类的实现拆分为多个独立的源文件</li>
</ul>
<p>很明显，Category其实就是设计模式之一的装饰者模式的具体实现。</p>
<p> <em>注意，Category是一个类的拓展，为不是一个新类。</em></p>
<p>借助Apple开发者文档了解到Category的“知其然”，然后就是基于<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Apple Opensource</a>来解决“知其所以然”的问题？</p>
<h3 id="知其然所以然"><a href="#知其然所以然" class="headerlink" title="知其然所以然"></a>知其然所以然</h3><p> 此处使用的源码版本是objc4-532.2。与本文相关的代码都在源文件objc-runtime-new.mm中，接下来就结合关键的代码与注释进行分析。</p>
<p> Catrgory的定义</p>
 <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> category_t {</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">} category_t;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p> 通过Category的定义可以看出，Category与Class存在很相似。不过Category没有isa指针，这也说明Category不是一个类，只能作为一个类的拓展存在。</p>
<p> 关键Method-1: _read_images()</p>
 <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACH_HEADER \</span></span><br><span class="line"><span class="meta">hIndex = 0;         \</span></span><br><span class="line"><span class="meta">crashlog_header_name(NULL) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); \</span></span><br><span class="line"><span class="meta">hIndex++</span></span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Discover categories.</span></span><br><span class="line">    <span class="comment">//遍历工程中所有的头文件</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) {</span><br><span class="line">        <span class="comment">//Category列表</span></span><br><span class="line">        category_t **catlist =</span><br><span class="line">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//遍历Category列表</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="comment">//Category拓展的类的指针</span></span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!cls) {</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line">            <span class="comment">// the class is realized.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//检测目标类是否已实现</span></span><br><span class="line">            <span class="built_in">BOOL</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            {</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls)) {</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = <span class="literal">YES</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Categoty存在方法列表或者协议列表</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                <span class="comment">/* ||  cat-&gt;classProperties */</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//关键函数块</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//添加Category到目标类</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//重构目标类的方法列表</span></span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls-&gt;isa)) {</span><br><span class="line">                	<span class="comment">//关键函数！</span></span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Category discovery MUST BE LAST to avoid potential races</span></span><br><span class="line">    <span class="comment">// when other threads call the new category code before</span></span><br><span class="line">    <span class="comment">// this thread finishes its fixups.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> EACH_HEADER</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p> _read_images()是赋值读取镜像文件的函数，函数末尾就是处理Category的代码块。其中将工程中所有的Category分别与其目标类建立关联，然后调用了remethodizeClass()对目标类的进行重构。</p>
<p> 关键Method-2: remethodizeClass()</p>
 <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> remethodizeClass(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="built_in">BOOL</span> isMeta;</span><br><span class="line">    </span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//识别目标类是否为元类</span></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="comment">//重构目标类的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls))) {</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        <span class="keyword">const</span> protocol_list_t **newprotos;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>,</span><br><span class="line">                         getName(cls), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Update methods, properties, protocols</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> vtableAffected = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加Category中的方法到目标类</span></span><br><span class="line">        <span class="comment">//关键函数！</span></span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Category中的属性插入属性链表的头部，只有匿名Category才能额外添加属性</span></span><br><span class="line">        newproperties = buildPropertyList(<span class="literal">NULL</span>, cats, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (newproperties) {</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Category中的协议加入目标类</span></span><br><span class="line">        <span class="comment">//查看buildProtocolList函数得知，新的协议的加入目标类原有协议的尾部</span></span><br><span class="line">        newprotos = buildProtocolList(cats, <span class="literal">NULL</span>, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) {</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        }</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line">        </span><br><span class="line">        _free_internal(cats);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Update method caches and vtables</span></span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        <span class="keyword">if</span> (vtableAffected) flushVtables(cls);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p> remethodizeClass()函数的功能比较简单，进一步细化了对Category中的方法列表、协议列表和属性列表的处理。其中，属性列表的处理则是直接插入原属性链表头部，协议列表则是附加到原协议列表的尾部。接下来，重点分析处理Category方法列表的attachCategoryMethods函数。</p>
<p>关键Method-3: attachCategoryMethods()</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                      <span class="built_in">BOOL</span> *inoutVtablesAffected)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> isMeta = isMetaClass(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为每个Category分配函数列表</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">    _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="built_in">BOOL</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//汇总所有Category的拓展方法</span></span><br><span class="line">    <span class="keyword">while</span> (i--) {</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) {</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键函数!</span></span><br><span class="line">    <span class="comment">//将Category中的拓展方法加入到目标类</span></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, inoutVtablesAffected);</span><br><span class="line">    </span><br><span class="line">    _free_internal(mlists);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>attachCategoryMethods()函数的功能也比较简单，对与目标类的Category中所有方法进行汇总，然后调用attachMethodLists函数进行处理。</p>
<p>关键Method-4: attachMethodLists()</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> attachMethodLists(class_t *cls, method_list_t **addedLists, <span class="keyword">int</span> addedCount,</span><br><span class="line">                  <span class="built_in">BOOL</span> baseMethods, <span class="built_in">BOOL</span> methodsFromBundle,</span><br><span class="line">                  <span class="built_in">BOOL</span> *inoutVtablesAffected)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method list array is NULL-terminated.</span></span><br><span class="line">    <span class="comment">// Some elements of lists are NULL; we must filter them out.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法列表以NULL作为结束符，因此需要过滤掉目标类中的NULL函数</span></span><br><span class="line">    method_list_t *oldBuf[<span class="number">2</span>];</span><br><span class="line">    method_list_t **oldLists;</span><br><span class="line">    <span class="keyword">int</span> oldCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY) {</span><br><span class="line">        oldLists = cls-&gt;data()-&gt;method_lists;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        oldBuf[<span class="number">0</span>] = cls-&gt;data()-&gt;method_list;</span><br><span class="line">        oldBuf[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        oldLists = oldBuf;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (oldLists) {</span><br><span class="line">        <span class="keyword">while</span> (oldLists[oldCount]) oldCount++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> newCount = oldCount;</span><br><span class="line">    <span class="comment">//同上，过滤掉Category方法列表中的NULL函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addedCount; i++) {</span><br><span class="line">        <span class="keyword">if</span> (addedLists[i]) newCount++;  <span class="comment">// only non-NULL entries get added</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新的方法列表</span></span><br><span class="line">    method_list_t *newBuf[<span class="number">2</span>];</span><br><span class="line">    method_list_t **newLists;</span><br><span class="line">    <span class="keyword">if</span> (newCount &gt; <span class="number">1</span>) {</span><br><span class="line">        newLists = (method_list_t **)</span><br><span class="line">        _malloc_internal((<span class="number">1</span> + newCount) * <span class="keyword">sizeof</span>(*newLists));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        newLists = newBuf;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add method lists to array.</span></span><br><span class="line">    <span class="comment">// Reallocate un-fixed method lists.</span></span><br><span class="line">    <span class="comment">// The new methods are PREPENDED to the method list array.</span></span><br><span class="line">    </span><br><span class="line">    newCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先将Category加入到新的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addedCount; i++) {</span><br><span class="line">        method_list_t *mlist = addedLists[i];</span><br><span class="line">        <span class="keyword">if</span> (!mlist) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Fixup selectors if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (!isMethodListFixedUp(mlist)) {</span><br><span class="line">            mlist = fixupMethodList(mlist, methodsFromBundle, <span class="literal">true</span><span class="comment">/*sort*/</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Fill method list array</span></span><br><span class="line">        newLists[newCount++] = mlist;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Copy old methods to the method list array、</span></span><br><span class="line">    <span class="comment">//再将目标类原方法加入新的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; oldCount; i++) {</span><br><span class="line">        newLists[newCount++] = oldLists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NULL-terminate</span></span><br><span class="line">    newLists[newCount] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新目标类的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> (newCount &gt; <span class="number">1</span>) {</span><br><span class="line">        assert(newLists != newBuf);</span><br><span class="line">        cls-&gt;data()-&gt;method_lists = newLists;</span><br><span class="line">        changeInfo(cls, RW_METHOD_ARRAY, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        assert(newLists == newBuf);</span><br><span class="line">        cls-&gt;data()-&gt;method_list = newLists[<span class="number">0</span>];</span><br><span class="line">        assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>attachMethodLists才是最关键的函数。函数中为目标类分配了一个新的函数列表，先加入Category中的方法，再加入目标类原有方法。这也就是为什么如果Category中的函数与目标类中的函数重名，那么目标类的函数会被覆盖的原因。因为Runtime在遍历方法列表时会先发现Category中的函数。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇博客基于源代码对Category与目标类的组合过程进行了分析，明白了Category中的方法、协议和属性的处理流程。因此，我们可以更加高效和准确地使用Category，甚至利用其中存在的“漏洞”实现一些小魔法。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-02-25T15:45:07.000Z" title="2/25/2015, 11:45:07 PM">2015-02-25</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">10 minutes read (About 1515 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/02/25/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC3%E8%AF%9D/">揭开ARC的神秘面纱系列-第3话</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="http://www.galloway.me.uk/2012/02/a-look-under-arcs-hood-episode-3/">原文地址</a></p>
<p>“揭开ARC的神秘面纱系列”的这篇续集全都是关于@autoreleasepool这一新指令的。<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool">LLVM提及到</a>autorelease pools（自动释放池）的语义已经在LLVM3.0版本中发生变化，尤其是，我觉得探究ARC模式更新之后是如何实现的会很有意思。</p>
<p>因此，思考一下下面的函数：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() {</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>显然，这完全是不和谐的代码段，但是它能让我看到发生什么。在非ARC模式下，我们可能会假设：number将会在numberWithInt:函数中被分配内存，并返回的是一个自动释放的对象。因此当自动释放池随后被销毁时，number对象将会被释放。所以让我们看看是否如上所述（一如往常，使用的是ARMv7指令集）：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>不错，答案是肯定的。正是这样的。我们可以看到函数先将自动释放池入栈，然后调用numberWithInt:函数，然后将自动释放池出栈。正如我们所预料的。现在我们看看完全相同的代码在ARC模式编译出来是怎么样的：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#8</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>留意上述代码中objc_retainAutoreleasedReturnValue函数和objc_release的调用。ARC已经为我们做了决定，完全不必担心自动释放池，因为ARC可以直接不然自动释放池生效，通过调用objc_retainAutoreleasedReturnValue函数对number对象进行retain一次，然后在后面在调用objc_release函数释放它。这意味着自动释放池的逻辑不一定执行，让人满意的结果。</p>
<p>注意到自动释放池一直需要入栈和出栈，是因为ARC无法知晓numberWithInt函数和NSLog函数中会发生什么，不知道在函数中是否有对象会被加入释放池。如果说ARC知道这两个函数不会自动释放任何东西则实际上可以移除自动释放池的入栈和出栈操作。也许这种逻辑在ARC未来的版本中出现，尽管我不是很确定那时候ARC的语义会如何实现。</p>
<p>现在让我思考另外一个例子，在这个例子中我们想要在自动释放池的作用域之外使用number对象。这应该告诉我们为什么ARC是一个神奇的工具。思考下面的代码：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() {</span><br><span class="line">    <span class="built_in">NSNumber</span> *number;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>你可能会认为上述这段看似很和谐的代码会出问题。问题在于number对象将在自动释放池中创建，在自动释放池初衷时被释放，但是却在释放之后继续使用。噢！让我们通过在非ARC模式下编译上述代码来看看我们的猜想是否是正确的：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>很明显，正如我们所期望的那样没有调用retain,release或者autorelease，因为我们没有显式调用这些函数以及使用ARC。编译的结果也正如我们之前推理的那样。接下来让我们在ARC的帮助下会是什么样：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>此处应该有掌声！ARC识别出我们在自动释放池作用域之外使用了number对象，因此它如上一段代码一样对numberWithInt:函数的返回值进行了retain，但是这一次它将release操作放在了bar函数末尾而不是自动释放池出栈的时候。这一举措避免在一些代码中出现崩溃，我们可能会认为这些代码是正确的，但实际上却潜在着内存管理的bug。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-02-20T15:16:07.000Z" title="2/20/2015, 11:16:07 PM">2015-02-20</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a><span> / </span><a class="link-muted" href="/categories/iOS/Objective-C/">Objective-C</a></span><span class="level-item">6 minutes read (About 957 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/02/20/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC2%E8%AF%9D/">揭开ARC的神秘面纱系列-第2话</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-2/">原文地址</a></p>
<p>以下是正文：</p>
<p>写完第一篇关于<a target="_blank" rel="noopener" href="http://icebergcwp.com/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/">揭开ARC神秘面纱</a>的博客，我想和大家分享另外一些有趣的片段。这一次我好奇当你通过函数返回一个存在数组中的对象时会发生什么。非ARC模式，你可能会对这个对象retain一次再返回一个自动释放的对象。ARC模式下，我们虽然可以免去这些内存管理的操作，但还是不放心，觉得别扭。因此，我决定检测一下ARC是否做到位了。</p>
<p>考虑一下这个类：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)popObject {</span><br><span class="line">    <span class="keyword">id</span> lastObject = [array lastObject];</span><br><span class="line">    <span class="keyword">if</span> (lastObject) {</span><br><span class="line">        [array removeLastObject];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lastObject;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在非ARC模式下，调用函数removeLastObject将会释放数组对对象的持有，如果这是对象的最后一个引用则对象的内存将会被释放，意味着返回的对象是一个已经被回收的对象。所以，我们应当retain一次lastObject并在返回前添加autorelease属性（加入自动释放池）。</p>
<p>尽管我完全明白ARC应该会完成这些工作，但是我还是担忧没有自己添加这些操作。我天真地以为ARC会一行行地解析函数中的代码。如果是这样，我觉得ARC也许没必要在我们引用lastObject对象的时候为它添加一次引用计数，此时ARC并不知道lastObject需要进行retain，所以ARC没必要非得做这些操作。</p>
<p>这就是我错误所在。显然，ARC在我们引用lastObject对象的时候为其添加一次引用计数，并在对象立刻作用域的时候进行了一次release操作，在我们这个例子中，由于我们是通过函数返回这个对象且函数名不是已关键字new或者copy开头，因此需要将对象加入自动释放池。</p>
<p>让我们看看上述代码编译之后的样子：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.thumb_func</span>     <span class="string">"-[ClassA popObject]"</span></span><br><span class="line"><span class="string">"-[ClassA popObject]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">cbz</span>     <span class="built_in">r5</span>, LBB0_2</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line"><span class="symbol">LBB0_2:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleaseReturnValue</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>好吧，事实如此。ARC已经为我们考虑周全了。ARC在代码中插入了objc_retainAutoreleaseReturnValue调用，这意味着ARC已经觉察到需要给一个已经加入自动释放池的返回值增加引用计数，这个操作属于ARC的一种优化处理，它仅仅是把对象从自动释放池中移除而并非真的添加一次引用计数。接下来在函数结尾处，ARC调用了objc_autoreleaseReturnValue，这个函数将即将返回的对象加入自动释放池。</p>
<p>这仅仅是关于揭开ARC神秘面纱系列的另外一个例子。随着使用ARC的次数增多，我愈发意识它的实用性。ARC减少代码中内存管理相关的错误，并将上述的代码片段进行最佳优化处理。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2015-02-05T15:16:07.000Z" title="2/5/2015, 11:16:07 PM">2015-02-05</time></span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">12 minutes read (About 1754 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/">揭开ARC的神秘面纱系列-第1话</a></h1><div class="content"><p>这个系列一共有四篇博客，是Matt Galloway大神关于ARC的内部实现的一些探索，看完之后觉得收获不少。因此尝试着翻译出来和大家分享，一定会翻译不当之处，希望大家及时指正。<br><a target="_blank" rel="noopener" href="http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/">原文地址</a></p>
<p>以下是正文：</p>
<p>在Twitter上和<a target="_blank" rel="noopener" href="https://twitter.com/jacobrelkin">@jacobrelkin</a>进行了一次<a target="_blank" rel="noopener" href="https://twitter.com/mattjgalloway/status/154478264537194496">交流</a>之后，我决定写几篇博客关于ARC在神秘的面纱之下是如何运转和如何窥视其内部机制的方法。这篇博客我将解释ARC如何处理retain、release和autorelease这三个关键字对应的内部实现。</p>
<p>我们通过定义一个类作为开始，如下：</p>
<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSNumber</span> *foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> foo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)changeFooDirect:(<span class="built_in">NSNumber</span>*)inFoo {</span><br><span class="line">    foo = inFoo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)changeFooSetter:(<span class="built_in">NSNumber</span>*)inFoo {</span><br><span class="line">    <span class="keyword">self</span>.foo = inFoo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span>*)newNumber {</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span>*)getNumber {</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span>	</span><br><span class="line">	</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述代码覆盖了ARC的几个重要的方面，包括直接访问成员变量与通过setter访问这两种方式的比较，以及当不同的函数名的函数返回某个对象时ARC将会如何添加autorelease属性。</span><br><span class="line"></span><br><span class="line">让我们首先关注直接访问成员变量与通过setter访问这两种方式的比较。如果我们编译上述代码并查看其汇编代码将会洞悉其中的奥秘。我决定使用ARMv7指令集而非x86指令集是因为前者更容易理解（纯属个人见解！）。我们可以使用编译参数-fobjc-arc和-fno-objc-arc来开启或关闭ARC。在这些实例中我使用的是优化等级是第3级，也就意味着编译器将会移除多余的代码，这些代码我们既不感兴趣同时还会阻碍我们理解核心代码（读者做一个练习，在不设置优化等级的前提下编译上述代码，看看结果是怎样的）。</span><br><span class="line"></span><br><span class="line">在非ARC的模式下采用如下指令进行编译上述代码：</span><br><span class="line"></span><br><span class="line">	$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fno-objc-arc -O3 -S -o - test-arc.m</span><br><span class="line"></span><br><span class="line">然后，查看changeFooDirect:和changeFooDirect:这个两个函数的汇编码：</span><br><span class="line"></span><br><span class="line">``` arm</span><br><span class="line"></span><br><span class="line">	.align  2</span><br><span class="line">	    .code   16</span><br><span class="line">	    .thumb_func     "-[ClassA changeFooDirect:]"</span><br><span class="line">	"-[ClassA changeFooDirect:]":</span><br><span class="line">	    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))</span><br><span class="line">	    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))</span><br><span class="line">	LPC0_0:</span><br><span class="line">	    add     r1, pc</span><br><span class="line">	    ldr     r1, [r1]</span><br><span class="line">	    str     r2, [r0, r1]</span><br><span class="line">	    bx      lr</span><br><span class="line">	</span><br><span class="line">	    .align  2</span><br><span class="line">	    .code   16</span><br><span class="line">	    .thumb_func     "-[ClassA changeFooSetter:]"</span><br><span class="line">	"-[ClassA changeFooSetter:]":</span><br><span class="line">	    push    {r7, lr}</span><br><span class="line">	    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))</span><br><span class="line">	    mov     r7, sp</span><br><span class="line">	    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))</span><br><span class="line">	LPC1_0:</span><br><span class="line">	    add     r1, pc</span><br><span class="line">	    ldr     r1, [r1]</span><br><span class="line">	    blx     _objc_msgSend</span><br><span class="line">	    pop     {r7, pc}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>继续向前，看看在ARC模式下又是怎样的一副景象。采用如下所示的指令进行编译：</p>
<pre><code>$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fobjc-arc -O3 -S -o - test-arc.m
</code></pre>
<p>同样，此刻我们只关注changeFooDirect:和changeFooDirect:这两个函数：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA changeFooDirect:]"</span></span><br><span class="line"><span class="string">"-[ClassA changeFooDirect:]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r2</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_storeStrong</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA changeFooSetter:]"</span></span><br><span class="line"><span class="string">"-[ClassA changeFooSetter:]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>我们可以一目了然地看到两段汇编代码的不同之处。函数changeFooSetter:完全一样，而函数changeFooDirect:已经发生了变化：调用了一次objc_storeStrong函数。有意思的地方就是这里。如果我们查阅<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#runtime.objc_storeStrong">LLVM文档中objc_storeStrong函数的说明</a>将会看到objc_storeStrong函数里完成一个典型的变量交换，释放旧变量然后持有新变量。然而在非ARC模式下，这个变量仅仅是赋值，并没有任何释放或者持有操作。这就是我们期望的结果，感谢ARC！</p>
<p>接下来是更有趣的地方，newNumber函数对比getNumber函数。这两个函数在非ARC模式下都返回一个引用计数为1的NSNumber对象，也就是说函数调用者持有返回对象。根据Cocoa的命名约定，这个结果似乎符合函数newNumber而不符合函数getNumber。我们期望看到函数getNumber中有调用autorelease。因此，让我们查看非ARC模式下的代码是怎样的：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA newNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA newNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC2_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA getNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA getNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC3_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>然后是ARC模式下：</p>
<figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA newNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA newNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC2_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA getNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA getNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC3_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">blx</span>     _objc_autorelease</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>查看上述两段代码唯一不同点：ARC模式下getNumber:函数中调用了objc_autorelease。这也是我们所期望的，因为ARC模式能自动觉察到函数名是以关键字new还是关键字copy开头的，并为不属于这两种的情况的Get类函数的返回对象自动添加一次autorelease调用。棒极了！</p>
<p>这里仅仅只展示了关于ARC在两种模式下如何工作的一小部分奥秘，与此同时，我希望这能激励读者能自己去探索ARC的内部实现而不是理所当然的接受现有的知识点。作为一个程序员，理解自己使用的工具的内部实现是很重要的。
 </p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">Previous</a></div><div class="pagination-next"><a href="/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Mark Cao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mark Cao</p><p class="is-size-6 is-block">程序的世界让我着迷</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ChangSha</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/industriousonesoft" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/industriousonesoft"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">December 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">September 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">August 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">May 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/08/"><span class="level-start"><span class="level-item">August 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">June 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">May 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">February 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/11/"><span class="level-start"><span class="level-item">November 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/10/"><span class="level-start"><span class="level-item">October 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/09/"><span class="level-start"><span class="level-item">September 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/08/"><span class="level-start"><span class="level-item">August 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/05/"><span class="level-start"><span class="level-item">May 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">April 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/03/"><span class="level-start"><span class="level-item">March 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">February 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/01/"><span class="level-start"><span class="level-item">January 2015</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-06-27T13:34:07.000Z">2019-06-27</time></p><p class="title"><a href="/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/">初识汇编-知识点摘记</a></p><p class="categories"><a href="/categories/%E6%B1%87%E7%BC%96/">汇编</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-12-01T03:33:07.000Z">2018-12-01</time></p><p class="title"><a href="/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/">《三体》系列第一部读后感之生存还是死亡？</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E8%AF%84/">书评</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-14T14:37:07.000Z">2018-11-14</time></p><p class="title"><a href="/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/">需求第三定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-13T14:13:07.000Z">2018-11-13</time></p><p class="title"><a href="/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/">需求第二定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-11-11T01:18:07.000Z">2018-11-11</time></p><p class="title"><a href="/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/">需求第一定律</a></p><p class="categories"><a href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/">闲言碎语</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/iOS/Cocoa/"><span class="level-start"><span class="level-item">Cocoa</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/Objective-C/"><span class="level-start"><span class="level-item">Objective-C</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/"><span class="level-start"><span class="level-item">专业</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/OSX/"><span class="level-start"><span class="level-item">OSX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%93%E4%B8%9A/%E7%BF%BB%E8%AF%91/"><span class="level-start"><span class="level-item">翻译</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E8%AF%84/"><span class="level-start"><span class="level-item">书评</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BD%B1%E8%AF%84/"><span class="level-start"><span class="level-item">影评</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">汇编</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"><span class="level-start"><span class="level-item">闲言碎语</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ARC/"><span class="tag">ARC</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Category/"><span class="tag">Category</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cocoa/"><span class="tag">Cocoa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coffee/"><span class="tag">Coffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaSctript/"><span class="tag">JavaSctript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KVO/"><span class="tag">KVO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OSX/"><span class="tag">OSX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Objective-C/"><span class="tag">Objective-C</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenCV/"><span class="tag">OpenCV</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PlistBuddy/"><span class="tag">PlistBuddy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RunLoop/"><span class="tag">RunLoop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%89%E4%BD%93/"><span class="tag">三体</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0/"><span class="tag">人物传记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"><span class="tag">人类简史</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%88%B1/"><span class="tag">爱</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MarkCao" height="28"></a><p class="is-size-7"><span>&copy; 2022 Mark Cao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>