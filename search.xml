<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识汇编-知识点摘记</title>
      <link href="/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/"/>
      <url>/2019/06/27/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h4 id="汇编语言的由来"><a href="#汇编语言的由来" class="headerlink" title="汇编语言的由来"></a>汇编语言的由来</h4><ul><li>汇编语言是基于机器语言（由0或1组成）而产生的一种助记符</li><li>汇编语言介于机器语言和高级语言之间</li><li>汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令</li><li>汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言</li><li>高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。</li></ul><span id="more"></span><h4 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h4><p><strong>优点</strong></p><ul><li>汇编语言可直接访问或控制硬件：存储器、CPU，能最大限度的发挥硬件功能</li><li>目标代码少，占位内存少，执行速度快</li><li>不同厂商的CPU都有对应的机器指令集和汇编指令集合</li><li>大小写不敏感</li></ul><p><strong>缺点</strong></p><ul><li>不易于编写、维护、调试</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>CPU由寄存器、运算器和控制器组成，其中最主要部件是寄存器，通过改变寄存器的内容来实现对CPU的控制</li><li>不同的CPU，寄存器个数和结构存在差异</li></ul><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul><li>arm64寄存器有31个64位的通用寄存器x0-x30，这些寄存器通常用来存放一般数据</li><li>w0-w28是32位寄存器，是x0-x28寄存器的低32位，即64位的CPU是兼容32位的</li><li>CPU会先将内存中的数据存储到通用寄存器中，然后在对通用寄存器中的数据进行运算，原因在于寄存器的执行速度比内存快</li><li>arm64架构下，函数参数都是保存在x0-x7（32位下即w0-w7）这8个寄存器，超过8个参数入栈</li><li>函数返回值是存放在x0寄存器中</li><li>函数的局部变量都是保存在栈中</li></ul><h5 id="PC寄存器：program-counter-register"><a href="#PC寄存器：program-counter-register" class="headerlink" title="PC寄存器：program counter register"></a>PC寄存器：program counter register</h5><ul><li>指令指针寄存器，指向CPU当前要执行的指令地址</li><li>内存中指令和数据无区别，都是二进制数据。CPU将PC寄存器指向的内存单元的内容看作指令</li></ul><h5 id="sp与fp寄存器"><a href="#sp与fp寄存器" class="headerlink" title="sp与fp寄存器"></a>sp与fp寄存器</h5><ul><li>sp寄存器会在任意时刻保存栈顶地址</li><li>fp寄存器即为x29寄存器，有时也用于保存栈低的地址</li></ul><h5 id="lr寄存器"><a href="#lr寄存器" class="headerlink" title="lr寄存器"></a>lr寄存器</h5><ul><li>lr寄存器就是0x30通用寄存器</li><li>0x30寄存器存放函数返回地址，执行ret指令时会读取这个寄存器的值，实现函数返回</li></ul><h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><h5 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h5><blockquote><p>arm64架构中取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp；ldp/stp是ldr/str的衍生，可同时读写两个寄存器，而ldr/str只能读写一个</p></blockquote><ul><li>str指令：store register指令，将数据从寄存器中读出，写入内存</li><li>ldr指令：load register指令，将数据从内存读出，存入寄存器</li></ul><p>eg：利用栈将x0和x1寄存器中的值互换</p><blockquote><p>arm64架构中，栈是16字节内存对齐的，即一次读写至少是16（0x10）个字节</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub sp,sp,#0x10 ;栈顶指针下移0x10个字节，两个64位的寄存器共16个字节</span><br><span class="line">stp x0,x1,[sp,0x10] ;寄存器x0,x1先后的值入栈</span><br><span class="line">ldp x1,x0,[sp,0x10] ;出栈，先后写入x0,x1寄存器</span><br><span class="line">add sp,sp,0x10 ;栈还原，stp、ldp指令不会改变sp指针位置，且都是由高地址向低地址读写</span><br></pre></td></tr></tbody></table></figure><h5 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h5><ul><li>CPU执行的指令是由PC寄存器决定的，因此可以通过修改PC寄存器的内容来控制CPU的指令执行</li><li>传送指令用于操作通用寄存器，比如mov指令；此外是转移指令，用于修改PC的值，最简单的就是bl指令</li><li>bl指令跳转前将当前指令的下一条指令存放到lr(0x30)寄存器：链接寄存器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《三体》系列第一部读后感之生存还是死亡？</title>
      <link href="/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/"/>
      <url>/2018/12/01/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B9%8B%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1/</url>
      
        <content type="html"><![CDATA[<p>《三体》是我看的第一本科幻小说，与很多在学生时期就接触了这本书的朋友比起来，即将三十而立的我觉得有点相见恨晚。书中涉及了天文学、物理学、计算机学等众多专业知识。在阅读这本书的过程中，总会时不时地感叹作者想象力之丰富，知识之渊博。与作者刘欣慈一样同为程序员的我读起来多了一丝亲切感。过去的自己对科幻小说存在一些误解，认为科幻小说无非只是天马行空的想象罢了，这类超现实的小说只适合用来消遣，并没有太多实用性。现在我为自己愚蠢的想法道歉：一本好的小说一定都蕴含着一个深刻的内核，或是对生命的思考，或是对人性的剖析等等。而小说的功能则是通过虚构一个故事或世界让读者更好的理解作者要表达的想法，并引导读者产生共鸣。《三体》这本书在我看来，它提出的是对人类的究极拷问：生存还是死亡？</p><p>这本书采用的是倒叙和插叙的叙述方式，让读者在阅读的过程中不断地处于产生疑惑和解答悬念的循环中，也使整个阅读过程都充满紧张和刺激的感觉，直到最后一刻谜底揭开之时不自觉地陷入深思并自我审视：当自己面临同样的困境会如何抉择？是选择生存还是死亡？</p><p>在给出自己的答案之前，我觉得很有必要按照时间顺序将整个故事的来龙去脉理一遍，这样可以更好地理解作者想要表达的想法。</p><h5 id="起源：文化大革命"><a href="#起源：文化大革命" class="headerlink" title="起源：文化大革命"></a>起源：文化大革命</h5><p>这本书的主角无疑是叶文洁，整本书都是围绕着叶文洁坎坷悲催的成长历程展开，她的遭遇让她看清了人性的丑恶，对人类文明也逐渐失去了信心，而这一切的源头毫无疑问是文化大革命。文革大致可以分为三个阵营：坚守真理的知识分子，疯狂无知的红卫兵以及为求自保的利己主义者。而叶文洁的一家四口恰巧分属这三个阵营，也为这个不幸的家庭埋下了悲惨结局的注脚。</p><p>叶文洁的父亲叶文泰，属于坚守真理的知识分子代表。在文革时期，作为物理学界的泰斗的他成为了众矢之的。但是，面对持续的残酷打击，他自始至终地捍卫着自己内心由知识和理性构筑的思想大厦，直到生命的最后一刻也不曾有一丝妥协。他内心其实早已看透：“在中国，任何超脱飞扬的思想都会怦然坠地，因为现实的引力太沉重了”，更何况是在这个疯狂的年代，坚守真理需要付出的是生命的代价。而作为红卫兵的叶文洁，站在台下红卫兵的队伍中目睹了父亲整个的批斗过程，除了强忍悲痛与泪水之外显得无能为力。那时候的她还是学生，同其他的红卫兵一样没有科学信仰，缺乏分辨是非的能力，并且对至高无上的权利都有着天生的崇拜。但她又不同于妹妹那样完全失去理智，六亲不认。这是因为她内心真正崇拜的人是自己的父亲，也意味着她和父亲有着同样的科学信仰。只是她那时候太年轻，很轻易地就被文革浪潮吞没，同时被吞没的还有个人的信仰。那时候的她本能地选择活下去，而加入红卫兵就是最好的选择。和叶文洁做出同样选择的还有父亲的两个研究生，我相信他们内心是崇尚科学的，这也让他们在批斗自己老师的时候尚且表露出一丝人性。但是他们内心又惧怕成为革命对象，为了生存只能将自己隐藏在红卫兵的外衣之下。但是当她在大兴安岭接受劳动改造时，面对他人的栽赃陷害以及上层对父亲的二次批斗，她选择了和父亲一样的斗争方式：以死捍卫自己的尊严和信仰。而与叶文洁及其父亲形成鲜明对比的是同为物理学教授的母亲，她则是一位精致的利己主义者，她既不像叶文泰那样甘愿为科学献身，也不像红卫兵那样愚昧无知，她所做的一切都是为了让自己活着，并且活得更好。早在文革初期她就嗅出了知识界的政治风向，做出很多超前的举动，试图告诉学生：所有的科学成果都是广大劳动人民的智慧结晶，而那些资本阶级的学术权威不过是窃取了这些智慧，试图得了文革主流的认可，从而使自己能在这场自己为革命对象的斗争中生存下来。为了达到这个目的，她不惜一切代价：在文革时期上台协助红卫兵批斗自己的丈夫；在文革后期眼光独到地嫁给了一位尚未平反的教育部高干，在文革结束后不久便再次回到上层阶层；为了与过去的历史旧账撇清关系而不惜与女儿决裂。为自己活着无可厚非，但是将自己的幸福建立在他人的痛苦之上就是可耻的。</p><p>文革结束后，叶文洁找到了当年将自己父亲批斗致死的三个红卫兵，试图让她们为当年的罪行忏悔，哪怕是人性的一点点复归。然而得到的答复是：“她们也是受害者，文革剥夺了她们的青春和未来，历史已经将她们遗忘，她们内心只有怨狠没有忏悔”。那一刻起，叶文洁对于人类文明彻底失去了信心，期待宇宙间更高的文明来引导人类文明已然成为了她坚定不移的信念。</p><h5 id="经过：寻找更高级的文明"><a href="#经过：寻找更高级的文明" class="headerlink" title="经过：寻找更高级的文明"></a>经过：寻找更高级的文明</h5><p>叶文洁因为自己大一的一篇名为《太阳辐射层内可能存在能量界面和其反射特性》的论文将她从文革二次迫害中拯救出来，进入了神秘的红岸基地。毫无疑问，红岸基地的出现不仅拯救了叶文洁的性命，也让早已心如死灰的叶文洁重新燃起了对生的欲望，因为在这里有了探索外星文明的可能性。</p><p>在红岸基地，因为特殊身份和遭遇叶文洁被隐形地的隔离与疏远，而工作成为了她生活的全部。只有全身心地投入工作才能暂时忘记过去的痛苦，加上叶文洁夯实的学术研究功底，为后续叶文洁成为第一个发现“太阳是一个电波放大器”这一理论的人增加了可能性。苏联天体物理学家卡达谢夫曾建议，可以根据宇宙中不同文明用于通讯的能量，来对它们分级。他将想象中的文明分为Ⅰ、Ⅱ、Ⅲ三种类型；Ⅰ型文明能够调集与地球整个输出功率相当的能量用于通讯。当时他的估计，地球的功率输出约为1015～16瓦。Ⅱ型文明能够把相当于一颗典型恒星的输出功率，1026瓦用于通讯。Ⅲ型文明用于通讯的功率达1036瓦，约等于整个星系的功率输出。红岸基地所能发射的最大功率虽然连Ⅰ文明都达不到，但是它可以满足穿越太阳对流层到达反射层的阈值，经过太阳放大后的功率可达到Ⅱ型文明能量级，意味着地球文明找到了探索更高文明的钥匙。在接触《三体》这本书之前，我就一直存在一个疑问：长期以来人类以自己的认知方式去探索其他文明真的可以建立联系吗？这就好比有一条寄生虫无法感知人类存在一样。因此，如果有一个文明以人类无法感知的方式进行交流，即便真的存在我们周围我们也是无从得知的。在与三体文明取得联系之后，叶文洁向三体星球发出了“求救”信，期望着更高的文明降临拯救人类。这几乎成为了她那时唯一的信仰，为了捍卫这一信仰不惜以雷志成和丈夫杨卫宁的性命为代价。</p><p>随着文革风波的平息，与文革同样疯狂的“红岸计划”也逐步停滞瓦解。因为与失去了与宇宙文明通讯的平台，重新回归正常生活的叶文洁本以将人类的命运寄托于自己的美好期望中，直到遇到了同样对人类文明失去信心的还有伊文斯。伊文斯是一位物种共产主义者，他的信仰是：地球上的所有物种生来平等。然而人类文明的首要规则是：“保证人类的生存和舒适的生活，其他都是第二位的”。与叶文洁不同的是伊文斯有更多的选择，以及继承了父亲巨额遗产，这让他可以根据自己的意愿去探索人性，证明自己的理论是否可行。可惜他的信仰与人类文明是背道而驰的，这注定了他在人类社会是一个失意者。叶文洁的出现为伊文斯指明了新的探索之路：借助更高的文明来引领地球文明。因此也有了第二红岸基地的诞生。</p><p>如果说叶文洁是搭建与三体文明交流桥梁的先驱者，那么伊文斯则是在地球传播三体文明的领军人。尽管在他们的共同的努力下，三体文明的已经将地球锁定为他们希望的生存之地并开始向地球文明靠近，但是他们对于三体文明的降临地球后的期许却截然不同，因而三体叛军中产生了不同的派别，主要分为三派：</p><p>降临派：这是三体叛军最本原最纯粹的一脉，主要由伊文斯物种共产主义的信奉者组成。他们对人类本性都已彻底绝望，这种绝望最初来源于现代文明导致的地球物种大灭绝。伊文斯的一句话已成为降临派的座右铭：我们不知道外星文明是什么样子，但知道人类。他们期望三体文明的彻底摧毁人类文明。</p><p>拯救派：拯救派的成员大多都是通过《三体》游戏认识三体文明，以高级知识分子居多，并对于三体文明有着宗教般的崇拜。但是对于人类文明的态度远没有降临派那样极端。他们的终极理想是拯救主，也就是三体文明。为了达到这一目的可以一定程度上牺牲人类世界。</p><p>幸存派：幸存派的成员都来自较低的社会阶层，他们期望自己和子孙成为三体文明和地球文明那场终极战争中的幸存者，他们认为现在就为三体服务更有利于实现这一目的。这一派的主张很符合中庸思想，因此也以中国人居多。</p><p>这三个派别相互制约和对立，在三体文明降临之前他们有着共同的大目标，共同为三体服务。但是一旦三体文明降临，他们便会了各自的利益各自为战。就像当年文革时期，在“革命军”这一大群体中也有着很多的派系，他们借以文革的名义谋求着各自的利益，而最后沦为牺牲品的只有年幼无知的红卫兵和坚守真理的人。历史总是惊人的相似，因为人性如此，人类文明如此。</p><h5 id="结果：三体文明降临"><a href="#结果：三体文明降临" class="headerlink" title="结果：三体文明降临"></a>结果：三体文明降临</h5><p>不同于地球得天独厚的的自然环境，可以让人类在登上食物链顶端之后不必再考虑如何生存下去，而是考虑如何生活地更好。人类的文明发展史从另一个角度来讲就是一部环境和资源的破坏史，为了短期的利益而忽视地球环境和人类未来至始至终贯穿人类史。每当出现能源危机时都有新的技术突破带领人类走出困境，这也让大部分人类可以更加肆意地追求物质上的享受，因为他们相信当人类出现危机时总会有新的技术出现将危机化解。曾几何时，三体世界也像地球一样，有民主自由的社会，有着丰富的文化遗产。然而在生存危机面前，文明则变成了最脆弱的环节，如同温室的花朵一般。如今三体人挣扎于自己的星球的三体困境中，为了生存而不断地寻求技术突破，包括寻找或者践踏其他星球的文明，甚至抹灭了三体人生而为人的尊严与自由，剥夺作为人的基本情感需求，没有财富没有地位没有爱情，也没有希望。三体世界里的人类大多数都像1379号监听员那样孤独的过完一生，要么工作至死，要么脱水封存。当他接受到来自地球的信息，得知宇宙的另一个角落存在一个星球，那里有着自己向往的生活。这对他而言这是人生中最有价值的时刻，然而第一时间想到的是对上级隐瞒消息，内心不忍地球文明被三体占有和摧毁。我想这不仅是因为对地球这颗美丽的星球心生怜悯，更多的是因为对三体世界的绝望。然而他却不知道此时地球上也有一群人像他一样对自己身处的世界和文明感到绝望，正期待着三体文明的降临。</p><p>为了阻止人类文明与科技的发展，三体高层研发出了智子，试图对人类进行降维攻击。说起智子工程不得不再次感叹作者天马行空的想象，将整个人类世界想象成一个CPU，智子以接近光速的速度在地球穿梭，这让处于低速层面的地球人类感觉到智子无处不在。</p><h5 id="抉择：生存还是死亡"><a href="#抉择：生存还是死亡" class="headerlink" title="抉择：生存还是死亡"></a>抉择：生存还是死亡</h5><p>面对更为高级文明的降临，地球人面临着前所未有的抉择：生存还是死亡？</p><p>相较于普通百姓，高级知识分子显得更为悲观，而这些高级知识分子中又以科学家最为悲观。因为他们更接近真相，更清楚事情的严重性。与此同时，他们作为三体文明首要的攻击对象，当理性和科学的大厦被击溃时，活着似乎显得毫无意义，这也是杨冬自杀的原因所在。</p><p>作为大多数存在的普通人，对于科学没有那么虔诚的信仰，出于生存的本能而选择自救。尽管在三体人看来地球人就像虫子一样卑贱。但是就像人类和蝗虫之间的战争一样，人类用尽各种方法试图消灭蝗虫，最终却不得不承认一个事实：虫子从未被真正意义上战胜过，</p>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需求第三定律</title>
      <link href="/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/"/>
      <url>/2018/11/14/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>需求第三定律的含义：每当消费者必须支付一笔附近费时，高品质的产品相对低品质的产品就变得便宜了。这笔附加费越高，高品质产品相对就越便宜。因此，这个定律又叫“好东西运到远方去定律”。</p><p><strong>附加成本大，精选品才值得</strong></p><p>当人们不得不支付一笔巨大的附加费时，就只有精选品才值得人们去运送、去提供，才值得人们享受。</p><p><strong>附加成本上升并非好事</strong></p><p>当附加成本上升，精选品就显得便宜，那么是否附加成本越高越好？</p><p>以中国出口香烟为例，如果进口国家对香烟实施配额制，每包香烟多付5元的附加费。那么这时只有较贵的香烟才值得出口。这样出口的香烟种类就减少了，国外消费者的选择也相应的少了。因此，虽然出口商品的平均质量提高了，但是出口商品的品种少了。国外的消费者和出口国生产商都蒙受了损失。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>需求第二定律</title>
      <link href="/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/"/>
      <url>/2018/11/13/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>理解了需求第二定律，就可以更懂人与人之间互相作用、互相博弈的规律</p></blockquote><p>需求第二定律的定义：需求对价格的弹性，和价格变化之后流逝的时间长度成正比。换言之，随着时间的推移，需求对价格的弹性会增加。</p><p><strong>需求对价格的弹性</strong></p><p>需求对价格的弹性，就是需求量随着价格变动而变动的程度。它等于需求量的变化比例除以价格的变化比例。<br>注：由于需求曲线是减函数，所以弹性永远都是负数。一般讲弹性都是指绝对值。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/1.png" width="300" hegiht="200"></div><p>奢侈品：弹性&gt;1.0，需求量的变化幅度大于价格的变化幅度的物品属于奢侈品<br>必需品：弹性&lt;1.0，需求量的变化幅度小于价格的变化幅度的物品属于必需品</p><p>弹性不等同于斜率，其他条件不变的前提下，需求函数的斜率为1。而弹性是渐变的。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/2.png" width="300" hegiht="200"></div><p>由于需求曲线中，价格是自变量，因此一件商品是奢侈品还是必需品完全取决于价格。</p><p><strong>寻找替代方案</strong></p><p>现实生活中是否存在一种商品，无论价格多高，它的需求量都是不变的。那么这种商品的需求曲线是一条垂直于需求量的直线。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/3.png" width="300" hegiht="200"></div><p>但是实际情况下是不存在的，人们一定会找到替代方案，整个人类历史就是一个不断寻找替代方案的历史。以食用盐为例，当盐的价格高到一定程度，人们就会想办法寻找替代方案，包括最终生病或死亡都属于替代方案。</p><p>正如需求第二定律所说，随着时间推移，需求对价格的弹性就越大，也就是寻找到的替代方案就越多，应变的空间也越来越大。</p><p><strong>商品的税负问题</strong></p><p>一件商品的税负由用买卖双方共同承担的，正确的答案由两句话组成：税负是双方共同承担的；双方各付多少，取决于需求者和供应者双方的相对弹性，谁的弹性低，谁对这份交易的需求更迫切，谁就付得多一点。</p><p><em>注：买家对应于需求曲线，而卖家对应于供应曲线。</em></p><p>情况一：在买卖双方对商品的弹性是一致的时候，各自均摊税负。如下图所示：</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/4.png" width="300" hegiht="200"></div><p>图中的平衡点N是需求曲线D与供应曲线S的相交点，表示在没有对商品征税的情况下，需求量和价格分别为q0、p0。对商品征税后，买家付出的价格从p0上涨到pd，卖家收到的价格从p0下降到ps，商品的需求量从q0下降到q1。面积A+B恰好等于税收。</p><p>情况二：买家的对交易更为迫切，对商品的弹性较低，即需求曲线的较为陡峭，而供应曲线相对平缓。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/5.png" width="300" hegiht="200"></div><p>由图可知，这种情况下，买家承担的税负更高。</p><p>情况三：卖的对交易更为迫切，对商品的弹性较低，即供应曲线的较为陡峭，而需求曲线相对平缓。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-02/6.png" width="300" hegiht="200"></div><p>由图可知，这种情况下，卖家承担的税负更高。</p><p>推广：</p><p>1、有人说房价太高，建议政府通过收取很高的房产交易税来压低房价，这种想法完全是错误的。重税只会增加买卖双方的负担，而且如果是买房者是刚需，则会承担大部分的税负。</p><p>2、不管是法律是否规定了雇主付养老保险还是雇员付养老保险，最后双方的分担都取决于雇主和雇员谁的弹性更大，谁的谈判能力就越高，承担的负担比例就相对小。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>需求第一定律</title>
      <link href="/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/"/>
      <url>/2018/11/11/%E9%9C%80%E6%B1%82%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><em>注：本文属于《薛兆丰经济学讲义》第28讲的读书笔记</em></p><blockquote><p>人总是善于根据代价的高低而灵活应变–对人性深刻而基本的刻画</p></blockquote><p>需求第一定律的定义是：当其他情况不变时，只要价格提高，商品的需求量就会减少；价格降到一定程度，需求量就会增加。</p><p><strong>需求曲线</strong></p><p>基于其他条件不变的前提，需求曲线是一条斜率不变的减函数，随着价格（自变量）的增大，需求量（因变量）递减。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/1.png" width="300" hegiht="200"></div><p>当存在价格之外的其他任何因素发生变化时，整条需求曲线发生变动和转动，但是仍然是一个减函数。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/2.png" width="300" hegiht="200"></div><p>很多时候我们容易被一些社会想象误导，误以为需求曲线在某些情况下是增函数的。比如股市出现追涨杀跌，其实是因为股票的盈利能力变了。存在这种误解是忽视了需求定律中“其他条件不变”的前提。在人性不变得前提下，价格越高，需求将越低。此外，需求不等同与需求量，一个人对某个商品的需求是不会随着价格变动而出现变化的。</p><p><strong>供应曲线</strong></p><p>在需求曲线中，当价格上升到一定程度会出现负需求，也就是供给。换言之，需求和供给完全取决于市场价格。当价格足够高时，原本属于需求者的一部分会变成供给者。</p><div align="center"><img src="https://raw.githubusercontent.com/industriousonesoft/iSoft_ImageBed/master/blog/xueqiudinglv-01/3.png" width="300" hegiht="200"></div><p><strong>交易剩余</strong></p><p>需求曲线上的任何一点都代表一个人对某个商品的在这个单位上的个人估值，即为了获得这个单位的服务愿意付出的最大代价。</p><p>但是，一个人对某个商品的估值与他最终得到这个商品所付出的代价之间往往存在着差距，这个差距就是“剩余”。同理，商品生产者也享受“剩余”，厂商对一个商品的估值与商品的市场价格之间的差距。因此这种剩余更合理的名称应该是“交易剩余”。</p><p><strong>思考题</strong></p><p>我们讲，凡是交易就有剩余，有剩余，买卖双方都皆大欢喜。但如果是这样的话，为什么世界上许多国家都有所谓的价格法，专门打击商人定价过高的行为呢？</p><p>我的理解：虽然存在交易，买卖双方就都能享受剩余。但是卖家和买家享受的剩余来源不同，或者说是相斥的。卖家享受的剩余=商品交易价格-卖家对商品的估值，因此商品的成交价格越高，卖家享受的剩余就越大。反观，买家享受的剩余=买家对商品的估值-商品的交易价格，即商品的成交价越高，买家享受的剩余就越小。根据需求曲线，价格越高，需求量越低。如果卖家对商品的定价过高，需求者可能会转变成供给者，整个市场会出现供大于求的现象。因此，为了保护消费者的权益以及维护市场供需平衡，需要通过法律手段来制衡商家定价过高的行为。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>失传的艺术-计算机科学</title>
      <link href="/2018/11/03/%E5%A4%B1%E4%BC%A0%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
      <url>/2018/11/03/%E5%A4%B1%E4%BC%A0%E7%9A%84%E8%89%BA%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Don’t learn to build doghouses and call yourself an architect. 不要明明是在搭建狗屋，却自称为建筑师。</p></blockquote><p>今天在阮一峰博客看到一篇名为<a href="http://rubyhacker.com/blog2/20150917.html">Computer science as a lost art</a>的英文博客，文章不长，内容也朴实随意，正如作者所言属于即兴发挥。文章阐述的观点让我自感惭愧，也让我意识到自己与真正的计算机从业者之间的差距，遂翻译以自勉。译文如下：</p><p>昨晚我的一位老友问我：“计算机科学是否已经成为了一门失传的艺术？”今早，我给出了即兴想到的答案：</p><p>嗯，这就是我的观点。我拥有计算机本硕学位即六年计算机科学求学历程，与此同时有着30年工作经验。换言之，我有些过时了，且与当下有点格格不入。</p><p>即使我不大愿意相信，但是确实有些事情实实在在的发生了。首先，如今电脑已经相当普及，你还能找到一个80岁以下却没有电脑或手机的人吗？其次，万维网（作为互联网最初的模样诞生于1989年）在1995左右便已经开始遍布于公众。随着电脑的使用领域变得越来越广，它也变得越来越重要。第三，那些我们用于创建软件应用的工具在功能上变得更复杂从而更便于使用，就像驾驶汽车这件事来说现在相对于1905年来说要简单的多。</p><p>我想要表达的是现在的电脑使用者比过去任何时候都要多。现在也有很多所谓的程序员没有上过一堂编程课。不过任何事情都要利弊。</p><p>这意味着一个人只需要很少的计算机知识便可以完成一个小项目，但也意味着这样的人很可能不会为了完成大项目而去学习更多的知识。</p><p>老实说，私底下我对于现在存在这样一大群不思进取的伪程序员这个事实感到很沮丧，我也很少对他人提及我的感受。在我看来，他们决定学习他们领域5%的知识是为了完成某个任务，或找点乐子，或谋生而已。</p><p>这些人使用编程工具创建一些日常所用的应用程序，殊不知编程工具本身也是软件。但是编程软件远非一般水平的人所能创建的。即便这些人每天都在使用编程语言，编辑器，编译器和操作系统，但是他们对于如何编写用于编程的软件，以及这些软件的运行原理没有丝毫的头绪。</p><p>20年后，一个赛车手可以把小孩放他的腿上，然后小孩会说：“哈，我也能驾驶这辆车，任何人都可以驾驶它。你只需要按下绿色按钮然后说‘送我去沃尔玛’即可。”这与我对如今学习编程这件事的看法有些类似。</p><p>回到计算机科学的话题。我的朋友有一个七岁的儿子自学了一款很棒的编程工具，然后编写了一款iPhone游戏。尽管，那是一款很简单的游戏。但是他完成了这件事情放在三十年多前差不多需要拥有计算机博士学位的人才能完成，而且还不是移动设备上的软件。</p><p>有时候我与一些人交流计算机知识时，他们的抱怨和疑惑说明他们已经到了自己的知识边界。有时候这让我很震惊，我认为：这些知识点应该是在你第一个学期的第一堂计算机科学课程里面就能学到的。随后我意识到，这些并没有真正意义上学习过计算机科学的课程。</p><p>当然，在我之前的上一代计算机前辈们也是以同样的眼光看待我们这一代人的。在1940年代，你几乎必须有一个电子工程学位才有可能接触到计算机。在上个世纪70年代末到80年代初，你只需主修一门计算机科学或工程就能接触到计算机，在90年代以后，你仅仅需要一张信用卡，或者你父母有一张信用卡。</p><p>我对于硬件很痴迷，顺便说一下，我离不开键盘。每当我拆开一台电脑试图捣腾点某个零件时，我总会把其他零件搞砸。严格意义上说我是一个软件男。因此，我曾经被他人嘲笑过，甚至一些年长的人也会因为我不会使用电焊笔而嘲笑我。</p><p>任何事情都基于你真正想做什么。如何你只是想开一家网店、制作购物车、网页表格、漂亮的图片以及社交媒体软件，那么你根本不需要计算机科学学位，甚至是与之相关联的学位。</p><p>如果你想创造一些尚未存在且很有趣的东西，或是你想在这个产业里面做出一点成绩，或是你仅仅想稍许改变一点这个世界，那么你必须有一个计算机学位。如果你想编写那些给低层次的程序员使用的软件和库，你也必须有一个计算机学位。</p><p>或者你从另外一个角度看待：如果你想搭建一个狗屋，只需要知道使用锤子和钉子，然后动手做即可。如果你想成为一名设计和建造摩天大厦的建筑师时，你首先需要一个建筑业的学位。再次恳请大家要有自知之明，不要明明是在搭建狗屋，却自称为建筑师。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《中国哲学史》读后感</title>
      <link href="/2018/10/20/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E5%8F%B2-%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2018/10/20/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E5%8F%B2-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>《中国哲学史》讲述了中国哲学的发展历史，打通了古今中外的相关知识，在有限的篇幅里融入了冯友兰先生对中国哲学的理解，是史与思的结晶，充满了人生的睿智与哲人的洞见。作者认为，哲学的功能在于提高人的心灵，超越现实世界，体验高于道德的价值。在学习哲学的过程中，人们没有智慧与不智慧之分，而哲学家们研究哲学的目的也从来不是为了提高智慧，仅仅是为了哲学本身。哲学既不是生存的工具或手段，也非我们生活的目的与理想，但它能使我们更清楚地认识到人生的意义。</p><p>在书中冯友兰先生着重于用浅显易懂的言语对哲学家本人思想的重新整理，梳理了中国哲学史上的几个重要的流派：儒家、墨家、道家、名家、阴阳家、法家，及各派在各个时期的发展、演变、更新。冯友兰自己认为，就《中国哲学史》的内容来讲有两点可以引以自豪的: 一是把先秦名家的辩者区分成两派;另一点是分辨出宋代程颢程颐兄弟思想的差异和各自特点。此二点均发前人所未发，为中国哲学史界普遍接受。</p><p>说到哲学，我们一般想到的都是西方的哲学，而并不知道中国也有哲学。其实中国哲学有三类，玄学，道学，义理之学，只是中国哲学并没有冠“哲学”之名。</p><p>中国哲学之所以缺少严谨的系统的体系，可能和中国人思想方式有关。每个民族都会在其文明发展的同时对人和世界的各种本体性问题发问，于是则产生了哲人。不同民族的哲人思考的终极问题往往相同，但思考的方法，思想的表述则大相径庭，是以各民族的哲学之面貌多有不同。区别于西方注重逻辑和思维缜密，中国的哲学更注重于现象而轻规律，逻辑的成分自然较少。如各个名家思想，常常是以其日常的“零碎语录”编辑而成的哲学，因而中国的哲学也就具有直观性、随意性及非专业性。</p><p>但事实上，在中国，哲学如宗教之于西方世界一样深深渗入社会，为常人所持。原因在于中国很多哲人并不以哲人自居，而是在日常行事中表达自己的思想，不求构筑体系，这是以有别于西方的。正如书中所言：“故哲学家之有所蔽，正因其有所见。惟其如此，所以大哲学家之思想，不但皆为整个的，而且各有其特别精神，特别面目”。而此书的作用，便是系统地讲解了中国哲学史从古至今的发展演变，让人充分了解中国的哲学发展。</p><p>一时代有一时代之时代精神，一时代之哲学即其时代精神之结晶也。全书分为两部子学时代和下篇经学时代。冯友兰先生从诸子百家中孔子说起。孔子之前只有鬼神，术数，没有一个鲜明的系统。孔子之后，儒家墨家，道家法家，阴阳家名家，无论是对事物的观察，处世之方，或者政治及社会主张，以及对理想之人格和社会的期望，都各自发展出系统的理论，并且身体力行，自成一派，发扬光大，这就是子学时代。而经学时代，则分为古文及今文。“经”即诸子之文，经学即是以旧瓶装新酒，用前人的经文来阐释自己的理论，生搬硬套自然无可避免。自董仲舒开创独尊儒术之时代始，历数两汉之古今文经学之争，魏晋南北朝之玄学佛学，唐朝之佛学以至宋明理学，最终以康有为等人为中古时代之结束。</p><p>冯友兰认为，中国哲学的精神之一，便是哲学背负着平衡入世与出世，现实与理想的矛盾。入世出世之对立，正如现实与理想主义的对立，而哲学的使命正是要在这两极对立中寻求它们的综合或许我们该在世俗中陶冶我们的性情。中国的哲学，以其所称的“直觉的概念” 出发，所以很多都是既入世又出世的道德。如今的我们似乎忘了原本的性情，在大流中随波逐流，每天除了工作挣钱，就是抱怨生活的不公平，很难静下心来读一本好书。在这样浮躁的状态下我们是不可能做到出世，我们应该明白现实与理想之间的差距是永远不可能消除的。人类一直在追求那能看到却不能到达的彼岸，那是人耐以生活的根本。由此而言，人们把生存看成是一种负担，一种难言的痛苦就可想而知了。</p><p>在中国哲学体系中，各时代的哲学家亦将此思想融入自己的生存之道之中。 儒家推崇“仁义”之道，也表现出神似欧陆浪漫主义诗哲追求的“暮春而游”之境，便是在其现实与抱负无法统一时，用哲学思想在两者之间寻求平衡，在世俗之中修养身心。对于我们而言，又何尝不是这样的情形。冯友兰说，哲学的功能不是为了增进对客观事物的认知，而是为了让人的心灵得到升华，超越现实世界，体验高于道德的价值。其实哲学并不是高高在上，高不可攀的学问，实际上它就深深的蕴涵在我们的日常生活当中，并且与我们的生活密切相关，密不可分。只不过我们缺少是让它们浮出水面，上升到哲学高度的理论思维而已。因此，我们更应该学习哲学，体验超乎现实的道德修养，吸取其精髓。在入世与出世之间修行品性，在喧闹的生活中创造自己的生活，在残酷的现实中建立自己强大的内心世界。</p>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《1984》读后感之楚门的世界</title>
      <link href="/2018/10/05/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/2018/10/05/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>我是国庆假期的最后一天，睡了一会懒觉，九点起床。没有像昨天的那样惯性地选择去公司加班，而是约了二三好友去健身房完成了今日的训练，这应该是我多年来第一次选择上午去健身。这种感觉让我想起温斯顿在某一天下班后没有径直回家，而是在一种自己也弄不明白的驱动力下走向了无产者居住的街道。现在看来，温斯顿这个看似不经意的选择加速了他生命结束的进程，但与此同时也是遇见爱情的开始，也许他当时认为只是生命中普通的一天。</p><p>下午没有午睡而是在某巴克点了一杯无糖拿铁，选了一个安静的角落，拿出kindle并尝试着在把《1984》看完。这是一个美妙的下午，感觉自己很久没有像今天这样心无旁骛地阅读一本书，或许这是第一次。不负“众”望，我如愿以偿地的看完了这本书。期间甚至没有去一趟洗手间，也许是我太过认真，也许是因为洗手间的温度比大厅低5°的原因。看完后，我伸了一个懒腰，环视着周围的这个世界，脑海中闪过一丝疑虑：我当下所处的世界是否是客观真实的，亦或是它只是一个“楚门的世界”。</p><p>王小波杂文中常提到罗素先生的一句话：“须知参差多态，乃是幸福的本源”，这也是我对生活和这个世界的期许与认知。但也会有人觉得单一机械乃是幸福的本源。于我，定是前者。在接触《1984》之前，我坚信周围的世界是客观存在的，而非存在于我的主观意识中，更不愿意相信它是被有意创造出来的假象，并通过教育等多种的方式让我信以为真。但是，现在我会怀疑至少存在部分以前看似合理的真相其实是一种假象，我们也许就像电影《楚门的世界》中的男主角那样，从一出生便生活在已经设计好的剧本里面，而不自知。也许“过去”并不客观的存在，它只存在于记录和人的记忆中。但凡是记录和记忆一致的东西，即是“过去”。我们从小接受的教育大多数都源于课本，视课本中的知识为金科玉律，认同课本中的价值观，认为课本中描述的历史就是历史本身的模样。那是否存在一种可能性，课本中的知识是出于某种政治或其他的目的而被有意编排的，为的是让我们变成被期望的样子，以达到统一思想的目的。书中说谁掌控了过去就掌控了未来，谁掌控了现在就掌控了过去，而教育应该是达成这个目的成本最低也是效果的手段之一，也许没有之一。目前来看，这种教育的非常成功的，我们周围已经培养出相对数量的无产者。这些人崇拜着老大哥，如今老大哥已然是党的化身。大多数时候他们会沉浸于各种综艺娱乐节目或是精心制作的爱国纪录片中安然度日，这就是所谓的奶头乐策略。但倘若出现对民族或国家的批评或诋毁，他们便会发出如同仇恨日那般的怒吼和反击，而非自省，但他们这些过激行为又似乎被上层默许的。在他们眼里非黑即白，似乎没有可用于商榷的中间地带。温斯顿一直将希望寄托于无产者，殊不知无产者本身已经没有了主观思想，他们安逸于目前的生活现状，他们认同资本主义是万恶之源，他们看到的国外局势永远是动荡不安的。即便日子过得艰苦也不会有所察觉或不满，因为没有对比，在他们目光所及之处皆如此，便也心安理得。纵观人类历史，任何一次革命的成功都必须有一只思想先进的先锋队，只有在他们的带领和引导之下群众才有可能觉悟，才有可能拿起武器反抗统治阶级。单纯依赖于愚蠢的无产者是不可能自我觉悟的，可惜温斯顿并没有意识到这一点。而温斯顿作为外围党成员中的觉悟者，本应属于先锋队中一员，但是他已丧失了人身和思想的自由。这也是为什么核心党只对外围党成员进行密切的监视，而放任无产者自生自灭。一直以来我不明白当年毛为什么要发动群众进行一场由下而上的文化大革命，而不是至上而下的整顿。现在我知道了答案，因为当年的先锋队已经变质了，而他们现在就是被革命的对象。文革的初衷是利于无产者的，其最终失败源于毛对权力和人性的过度自信，权利的泛滥和人性的扭曲导致局势失控，酿成了一出人间惨剧。当他意识到这一点的时候，已经油尽灯枯，无能为力。历朝历代得罪过既得利益集团的统治者都会背负骂名，不论是雍正还是毛，都是如此。因为他们得罪的就是书写和掌控历史的人，这也是为什么《毛选》最后一卷成为了禁书。想起书中有一个有意思的细节，通过奥勃良的家是可以知道核心党是享有特权的，他甚至可以关闭电幕。同样，在文革那个“闭关锁国”的时代，特权阶层也从未与外部世界隔绝。</p><p>温斯顿是孤独的，具体来说是思想孤独患者。他不得不小心翼翼地隐藏着自己内心反动的思想，但又极度渴望找到志同道合的同志。当他第一次见到奥勃良便坚信对方是他苦苦找寻的那个人，那个可以带给他希望的人，我当时也深以为然。然而，最后他才知道这一切都是幻想，不过是一场游戏一场梦而已。从最开始他就走进了奥勃良为他精心设计的圈套里，包括却林顿的店铺，与奥勃良的密会，以及那本精神领袖果尔德施坦因的书都是有意的安排。可怜的温斯顿一直认为自己隐藏的很好，没有留下蛛丝马迹，却不知道思想警察其实早已翻阅过他的日记，只是又被原封不动地放回原处，即便是日记本上那颗白色的灰尘都被小心地还原。以奥勃良为代表的思想警察耐心地用来七年时间自导自演这出戏，看着温斯顿做困兽之斗，不断地引诱着他表露自己内心的真实想法。如果非要说有一丝欣慰，那就是温斯顿比《楚门的世界》中的男主角幸运一点，因为至少他与裘莉亚之间的感情是真实存在的，且裘莉亚也是他唯一的战友，他们有过一段快乐的时光。不过温斯顿在这场斗争中注定是要失败的，因为他面对的不是某一个个体，而是一个经验丰富的集团，里面都是身经百战的老戏骨。毋容置疑，类似的戏码他们已经经历过一次又一次，也将一代又一代永远一而再再而三地演下去。人作为个体终究是要死去的，而集团是可以以思想和意志的形式永远存在的。一个统治集团只要能够指定它的接班人就是同一个统治集团。党所操心的不是维系血统相传而是维系党本身的永存。由谁掌握权力并不重要，只要等级结构保持不变。想到这一点，不由得心生寒颤，似乎确实是如此的。</p><p>《V字仇杀队》中的有一句台词：“面具下面不只是血肉之躯，而是一种思想，思想是不怕子弹”。此前我一直认为肉体消灭是对一个人最极端的处决，其实不然，思想改造才是。一个人失去了独立思考的能力，已于行尸走肉无异。温斯顿最开始也不明白为什么自己因为思想罪被捕之后没有立即被处以极刑，而是遭受不断地拷问和折磨。原因正如奥勃良所说，党是不会满足于消极的服从，甚至是最卑躬屈膝的服从都不要。他们不会对异端分子进行简单地肉体毁灭，而是进行改造思想和争取内心，使异端分子在内心真心诚意的屈服。让异端分子带着脱离正轨的思想死去，只会激发更多的异端分子，这是不能被容忍的。在强大的国家机器面前，温斯顿最终被改造成功，他出卖了裘莉亚，背叛了爱，也背叛了原来的自己。他尝试做过抵抗，但最终让他屈服的不是无尽地拷打带来的肉体上的痛楚，而是人的一种无法不服从的本能：对每一个人来说，都各有不能忍受的事情，连想都不能想的事情，这并不牵涉到勇敢与怯懦的问题。对温斯顿来说，老鼠是无法忍受的，对他会产生一种无法抗拒的压力。这也足以说明思想警察对于人性已经有很深刻的研究，从而有了让人闻风丧胆的101号房。想必裘莉亚也是在同样的情况下出卖了他，至少我相信是这样的。所以说，他们没有并出卖彼此，他们只是屈服于人的本能罢了。</p><p>最后，也是我个人觉得是最让感到绝望的一点：人类历史似乎始终都处于不断轮回的过程，那个人人自由平等的天堂永远不会到来，但却一直被作为革命最初的愿景。革命的目的其实是为了建立专政，夺取权利的目的就是为了权利，而所谓“取消私有制”实际上意味着把财产集中到比以前更少得多的一批人手中，不同的是，新主人是一个集团，而不是一批个人。而历史的不断重演，从某种意义上来说是在不断地帮助统治者丰富和优化巩固政权的手段，而无产者则永远是无产者。</p>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《永远的三丁目的夕阳》观后感</title>
      <link href="/2018/09/03/%E3%80%8A%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%89%E4%B8%81%E7%9B%AE%E7%9A%84%E5%A4%95%E9%98%B3%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2018/09/03/%E3%80%8A%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%89%E4%B8%81%E7%9B%AE%E7%9A%84%E5%A4%95%E9%98%B3%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>我想如果不是朋友的推荐，我不大可能会主动接触这部影片。其中一个比较直接原因在于影片的名称挺不起眼的，再者这类题材的电影已经不再是我的首选了。在第一次听到影名的时候感到有点困惑：三丁目是什么意思？为什么是永远的三丁目的夕阳？这里先回答第一个问题：丁目是日语词汇，类似汉语中胡同的意思，日本的地址通常是：区-丁目-番-号组成。因此，片名翻译过来就是：永远的第三胡同的夕阳。接下来是我对于第二个问题的答案。</p><h5 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h5><p>影片故事背景是昭和30年，即公元1956年（昭和元年为公元1926年），日本制定“电力五年计划”，进行以电力工业为中心的建设，并以石油取代煤炭发电。日本经济至此不仅完全从二次大战中复兴，而且进入积极建立独立经济的新阶段。1955至1957年，日本出现了第一次经济发展高潮。日本人把这个神话般的繁荣，称为神武景气(Jinmu boom)。</p><p>此时已是战后十多年，百废待兴，全日本上下一副蒸蒸日上的繁荣景象。与此同时，人们也开始慢慢地从战争的阴影中走出来，而东京旧城区夕日町三丁目就是这个时代背景下日本平民生活的缩影。那个时代的日本人不像现在那样拘谨阴郁，有着当今日本人少有的对未来的坚定信念，每个人的努力就如同电影里展现的东京塔的逐渐建成一样，是可以实实在在看到成果的。再加上那时如“夕日町三丁目”一般的平民街巷所充满的人情味，怎能不让如今被沉重且无望的工作以及冷漠的人际关系所压迫的日本人们为之向往呢？</p><h5 id="童年记忆"><a href="#童年记忆" class="headerlink" title="童年记忆"></a>童年记忆</h5><p>影片里面描述的很多细节和画面勾起了我童年的记忆，是那种温馨且快乐的记忆。我觉得铃木一家与我家有一定的重叠。我的父亲同样的是一个脾气暴躁的人，但是有时候也会有一些暖心的举动。就像铃木会特意为六子准备圣诞节回家的车票一样，我的父亲也曾用家里一个星期的伙食费为我买了一款最新上市的MP4播放器。虽然现在这个播放器已经被时代淘汰，但是我一直都留在身边，铭记这份温情。我的母亲也同一平的母亲一样，是一个温柔贤惠的家庭妇女。记得电影中有一个画面：一平不愿意午睡，张开嘴巴对着电风扇发出哇啊哇啊的声音，脑袋也随着风扇来回摇摆，被母亲发现后立刻假装睡着的场景。记得小时候我也常在午睡的时候对着家里的电风扇说话，因为这样会听到被旋转的扇叶反射回来的回声，有种千里传音的感觉。然后每次发现母亲过来时，立即摆出一副假装睡着打呼噜的样子。现在想想母亲那会应该早就看穿了我的演技，我却每次都为此洋洋得意。另外一个让我印象很深的画面是：铃木一家终于盼来三目丁区第一台电视机时，整个街道的居民都前来道贺围观看新鲜。大家都围坐在电视机旁七嘴八舌地议论着，当电视画面出现时全都目不转睛地盯着屏幕。整个屋子里时而安静、时而欢呼，一片其乐融融的景象。巧的是类似的情景也曾发生在我的家里。在我大概小学三年级的时候，我的父亲挣了一点小钱，于是给家里买了一台牡丹牌的彩色电视，那时候也算是村里的一件大事，以至于那会我在街坊邻居面前走路说话都比较嘚瑟。一般邻居们都会在吃过晚饭后陆陆续续来到我家，然后围坐在电视机旁有说有笑地看着电视，各抒己见地讨论着剧情。后来，随着生活水平地提高，越来越多的家里都配备了电视机，慢慢地晚饭后家里也开始变得清静。</p><h5 id="隐形婚戒"><a href="#隐形婚戒" class="headerlink" title="隐形婚戒"></a>隐形婚戒</h5><p>茶川这位以文学家自居的二流作家，在影片的前半部更多地是充当搞笑的配角，给人一种懦弱无能的感觉。然而，广美和淳之介出现彻底地改变了他的生活，也第一次让他有了家的感觉。看到茶川和广美的爱情，让我又理由相信那个是一个即便物质上贫穷匮乏，只要内心善良与真诚，同样有机会能够打动女孩子芳心的年代。当茶川战战兢兢地从口袋里面拿出用所有积蓄买来的盒子时，我以为盒子里至少会是一颗小的钻戒。然而，接下来的对话成为了整部影片最打动我的莫过于茶川向广美表白的镜头。茶川：“对不起，跟我结婚吧。我的钱虽然只够买个盒子，不过很快…盒子里的东西，我的稿费再多一点的话…”。广美：“给我戴上，那个…总有一天能买来的戒指”。虽然这段感情最终因为广美身不由己地离开而告一段落，但是当广美站在歌舞厅的天台，对着夕阳，伸出自己右手无名指，望着那枚隐形的戒指时，我觉得此生能拥有过这样一段爱情本身就是很幸福知足的事情。我们向往那个年代是因为我们内心都渴望得到一份真挚的爱情，是因为对方爱你这个人才选择和你在一起，合于性格，久于善良，忠于人品，亦或是是始于颜值，陷于才华。那个年代时间过得慢，人们对物质的需求也不高，一生也许真的只够爱一个人而已。现如今结婚的高门槛已经成为很多自由恋爱的年轻人以逾越的障碍，在现实面前而被迫选择结束的感情也已屡见不鲜。我想除了外界的因素之外，现在的爱情也许本身就缺乏一些真诚。我并不反对现在的婚姻价值观，作为女性通过自己的自然属性选择社会属性更优的男性，从物种进化的角度来说是完全符合自然法则的，可以让更好的基因得到更佳的资源配置。正因如此，那个更在意个人情感的年代才更让人怀念。</p><h5 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h5><p>最后说说我对这部影片的总体感受。东京铁塔作为日本标志性建筑，象征着日本经济腾飞和民族再次崛起。影片的首尾镜头与东京铁塔修建到竣工的时间节点动态呼应。而与之对应的是一种静态的永恒，即第三胡同的居民的淳朴善良，以及街坊邻居之间的真挚情感。这种美好的记忆就如同夕阳一般，很美，但已是近黄昏。不难想象随着城市化建设的推进，三丁目暖黄色基调的原貌必会成为过去，取而代之的定是冷灰色基调的现代建筑，留下的只有三丁目这个地名。电影的最后一个镜头是远方温暖绚丽的夕阳，夕阳下矗立着已经竣工的东京铁塔。铃木一家面向着夕阳，一平说：“明天，后天，就算50年后，夕阳也会一直这么美”。如今已是50多年后的今天，我想关于夕阳是否依旧那么美，大家心里都有自己的答案。虽然我并不认为这是导演的故意隐喻，这也许只是个巧合。当新的时代以一种高姿态来临，那个“大家诚诚恳恳，说一句，是一句”的社会已如夕阳的余晖般慢慢地消逝，如斯人的背影般渐行渐远。不过，这也正是这部影片触动我的地方，它带给我一种翻阅旧相册时的温暖和感动。</p>]]></content>
      
      
      <categories>
          
          <category> 影评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>还房贷最省钱的理财方法</title>
      <link href="/2018/08/21/%E8%BF%98%E6%88%BF%E8%B4%B7%E6%9C%80%E7%9C%81%E9%92%B1%E7%9A%84%E7%90%86%E8%B4%A2%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/21/%E8%BF%98%E6%88%BF%E8%B4%B7%E6%9C%80%E7%9C%81%E9%92%B1%E7%9A%84%E7%90%86%E8%B4%A2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最近看了紫竹张先生的一篇名为<a href="https://mp.weixin.qq.com/s?__biz=MzAxNDczNTk5MQ==&amp;mid=2651730253&amp;idx=1&amp;sn=f0d5cacc1d180fdb3407311affbb89f2&amp;chksm=80745e55b703d7430507e78469a2a3f4639ef30f8b43d3d6574d8328ae4869d6be49ea23088b&amp;mpshare=1&amp;scene=1&amp;srcid=0820Xnj0x8xfXItvqdGxpfLR&amp;key=fee773bf85a574f5c9b8985f5c4ee09210d769c87a720f5652cfec05e148fbf688c0964752d7765499411b591f4c39829f44009bd07580279982335beb674ad9481f3fa5b1cee2fc8a241c44bde6b8f9&amp;ascene=0&amp;uin=MjM2ODI5NjEyMA==">还贷款最省钱的理财方法</a>的文章，里面讲述的经济学知识与我们日常生活息息相关，却又是最容易被忽视和误解的部分。在一口气看了两遍感觉收获不小之后，觉得很有必要总结一下，作为备忘。</p><h5 id="最省钱的还贷方式"><a href="#最省钱的还贷方式" class="headerlink" title="最省钱的还贷方式"></a>最省钱的还贷方式</h5><p>在国内最常见的还贷方式有两种，分别是等额本金和等额本息：</p><ol><li><p>等额本金的月供是由每个月固定的还款本金数额加上当前未还款总额的利息组成。这种还款方式的特点是前期月供数额较大，后面随着未还总额的减少，利息也越来越少。</p></li><li><p>等额本息采用浮动本金还款，结合贷款年限计算出每个月还款的平均数。特点是每个月的还款金额几乎一样，前期月供中利息占的比重较大，后期的月供则主要是本金。</p></li></ol><p>结合上述两种还贷方式的特点容易产生一种误解，即大家会认为等额本息前期还的都是利息，有一种被银行剥削的感觉，因此倾向于提前还款，能还多少还多少。假如前面三五年没能提前还款，后面再提前还款就没有意义了，因为该交的利息都已经交了。这种观点表面上很有说服力，但仔细想想是完全错误的。</p><p>记住两个前提，一是等额本金和等额本息使用的利率都是一样的，二是银行房贷的利率较于其他大多数的贷款利率都低且贷款额度更大和年限更长。然后，我们分别从银行和个人的角度来分析。首先，从银行的角度来说，银行借出去多少钱就应该收多少利息，而收取利息的基数就是你尚未还清的贷款总额，也就是说你当前欠银行的钱越多就应该支付越多的利息。因此，从这个角度来说等额本金和等额本息对银行来说没有熟好熟劣的差别。等额本金因为前期还给银行的本金较多导致后期利息减少，但是银行可以用你还的这些本金继续贷款给其他人获取利息甚至是更高的利息。再者，从个人的角度来说，你欠银行多少钱就应该付多少利息。假设在经济能力允许且你口袋里的钱没办法获得一个高于贷款利率的收入，那么选择等额本金还贷从某个角度来说也算是一种理财方式。但是如果你手中的钱能够创造更高的收益，那么使用等额本金的方式就不一定是个好选择了。但是更多的人属于后者，在支付首付之后是储蓄大幅下降，所以会选择等额本息的方法以减缓经济压力。此外如果使用其他的贷款方式所需要支付的利息会更高。既然我们没有足够的钱来偿还贷款也就没有理由抱怨银行收取利息了。因此，在个人经济能力有限的前提下，选择等额本息对个人来说是最划算的。</p><p>此外，我们从银行贷款的利率只是名义上的利率，而非实际利率。原因在于中国未来都将处于不断通货膨胀的趋势，意味着人民币也不断在贬值。因此，你的实际利率等于名义上的履历扣除通货膨胀率，结果是实际利率值变成一个很低的值。接下来解释为什么说未来中国的通货膨胀会一直继续下去。</p><p>众所周知，过去的三十多年，中国通过改革开放实现从计划经济向市场化经济的转变，并且加入了WTO（世界贸易组织）。随着世界各国的经济全球化，中国的经济的决定权已经不在中国政府手上。当前全球经济根基的经济学理论源自于美国，该西方经济理论体系认为：</p><ol><li><p>适当的通货膨胀有助于经济发展，能够刺激生产和增加投资。人民倾向于花出手中的现金购买其他保值资产从而刺激了消费和生产，以及提供了更多的就业岗位。而通货紧缩则恰恰相反，人民倾向于存储现金以便提高未来的购买力。</p></li><li><p>当政府出现财政危机且需要增加财政收入时，一般会采取三种方式：一是增加税收；二是向公众借债；三是增加货币供应。前两种方式在政治上不得人心，所以一般都采取第三种方式。</p></li><li><p>政府不应该任由经济危机发生，政府有义务通过量化宽松（间接增印钞票）的方式来“熨平”经济波动，避免社会出现动荡，即便代价是通货膨胀。</p></li></ol><p>这种理论体系在西方大行其道，直接导致布雷顿森林货币体系的崩溃，美元和黄金脱钩，从此美元不断通货膨胀，全球货币也随之一路贬值，人民币自然不能独善其身。</p><p>有一个典型的通货膨胀的例子是：在1989年北京房价在1600-1900，当时的大学生工资是89元左右，每个月节衣缩食可以攒下50元。假设当时你倾其所有凑够首付，按月供60进行还贷款，等额本息三十年，到了2019年刚好还完。然而，当年你每个月要还的“巨款”60元，现在只能买一个披萨。</p><p>结合上述内容，最划算的贷款方式是使用等额本息的方式贷款最大金额，分三十年（最长还款年限）还款。此外，即便后面有了一定的储蓄也不要提前还款。原因在于流动资金具有一定的溢价效应。虽然某些现金类的理财产品收益率可能不如房地产投资，但是我们在投资房地产之余一定要配置一定比例的现金资产。因为固定资产的流动性很差，变现速度慢，而现金类产品能在你急性用钱的时候快速变现，以解燃眉之急。</p><p>最后一个建议是不要让你的公积金账户有闲置的资金。公积金有一个特性，除了还房贷之外很难提现，而且存款利率极低。如果你的公积金除了还房贷之外还有剩余，那么这些存款就是没有流动性的死款，存款越多亏的越多。结果就是名义上里面的钱是你的钱，实际上你却没有支配权。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科斯定律-从社会成本看问题</title>
      <link href="/2018/08/16/%E7%A7%91%E6%96%AF%E5%AE%9A%E5%BE%8B-%E4%BB%8E%E7%A4%BE%E4%BC%9A%E6%88%90%E6%9C%AC%E7%9C%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/16/%E7%A7%91%E6%96%AF%E5%AE%9A%E5%BE%8B-%E4%BB%8E%E7%A4%BE%E4%BC%9A%E6%88%90%E6%9C%AC%E7%9C%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近了解到一个很棒的经济学概念：社会成本问题。这是之前从未接触到的概念，给了我一个全新的思考问题的角度，心中多少有点欣喜。奈何这个概念有点深奥难懂，所以试着写出自己的理解以加深理解。</p><p>社会成本问题在经济学中有着非常重要的政策含义。只有理解了社会成本问题，才能顺应社会和市场的基本运行规律，制定出因势利导的经济政策。</p><p>最早把社会问题成本讲清楚的是罗纳德·斯科。人们一直信奉的用来解决纷争的金科玉律是：“权利的刑事应以不伤害别人的权利为界”。而斯科认为所有的伤害都是相互的，对于纷争的双方，谁避免意外的成本最低，谁的责任就最大。在面对具体的案例时，人们容易不自觉地掺入个人的情感和主观判断，而只有斯科看到了纠纷背后与资源争夺相关的、客观的经济本质。</p><p>斯科把产权或侵权的案件都看作是人们对稀缺资源的平等争用。为了解决这些纷争，进而形成了科斯定律：在交易费用为零或足够低的情况下，不管资源最初的主人是谁，资源都同样会流到价值最高的用途上。</p><p>然而现实生活中交易费用很高，很多资源是没有办法落到使用价值更高的人手里。因此，我么有时要鼓励第三方-例如政府-在知道资源怎样使用最合理、在非常有把握的情况下，使用手中的权利对资源进行重新分配。而这就是所有的制度、风俗、习惯以及政府、法院存在的根源理由-对资源、责任、权利进行初始界定。我们可以把社会上通行的制度、习俗和道德规范，都看成为了减少重复商议的成本而逐渐固定下来的解决纠纷的办法。</p><p>经济学本质就是研究这个世界客观地运行规律，这恰恰是经济学最具有魅力的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经济学概念-租</title>
      <link href="/2018/08/11/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5-%E7%A7%9F/"/>
      <url>/2018/08/11/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5-%E7%A7%9F/</url>
      
        <content type="html"><![CDATA[<p>最近在《姚兆丰经济学讲义》看到一个“租”的概念。从经济学的角度进行了重新定义，看完之后云里雾里、似懂非懂，于是做点笔记以加深理解。</p><p>有一种资产，不以收费的变化而变化，这种资产带来的收入就是租。租就是相对资产的付费，这里说的资产是广义上的，包括土地、矿产、才能以及特权，只要能够带来收入的就是资产，而对资产付费就是租。</p><p>每个人都享受一定程度的租。比如我们在平时上班时抽出半个小时刷朋友圈，老板并不会因此开除你或少付工资，这样你就赚了半小时的租。而且这一部分的租是属于旱涝保收的。然而现实生活中，随着时间和竞争条件的变化，真正让你旱涝保收的租是绝对不存在而是相对的存在的。</p><p>基于成本是放弃的最大代价这一前提，如果你对目前的工作感到满意，觉得下一份工作的收入会比现在低很多，那你就是在享受当前工作带来的租；相反，如果你觉得你另外一份工作收入会高很多，那你选择留在当前岗位的成本就非常高。此外，即使你不换工作留在当前的岗位上，如果你每天不管努力工作还是得过且过，结果收入都一样，那你选择懒散度日的态度，就是在享受租；但如果努力或懈怠带来的收入会有明显差异，那么你选择懈怠就要付出很大的成本。</p><p>不妨记住一句话：人人都是资本家，因为当你认识到自己是资本家之后，会把注意力放到提升自己的租值上，而不是所谓的被剥削。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSX开发之Safari App Extension初探</title>
      <link href="/2018/08/06/OSX%E5%BC%80%E5%8F%91%E4%B9%8BSafari%20App%20Extension%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/08/06/OSX%E5%BC%80%E5%8F%91%E4%B9%8BSafari%20App%20Extension%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="Safari-App-Extension简介"><a href="#Safari-App-Extension简介" class="headerlink" title="Safari App Extension简介"></a>Safari App Extension简介</h4><h5 id="什么是Safari-App-Extension"><a href="#什么是Safari-App-Extension" class="headerlink" title="什么是Safari App Extension"></a>什么是Safari App Extension</h5><p>Safari App Extension，即Safari浏览器应用拓展。它是苹果新推出的一种Safari扩展开发技术，最低支持Safari10.0，主要由三个部分组成分别是：</p><ul><li><p>Safari App Axtension: 扩展app本身，使用JS、CSS等前端脚本语言。主要功能是包括两方面：</p><ol><li>在插件运行之前注入js和css代码到当前的Safari浏览器页面，进而实现对页面的增删改查等功能</li><li>调用Safari提供的JS API接口与Containing app进行交互通信。</li></ol></li><li><p>Containing App: 扩展app的容器，属于Native App。主要功能包括四方面：</p><ol><li>配置和加载扩展app</li><li>与扩展app进行通信</li><li>提供可在Safari工具栏显示的原生界面</li><li>与Host App进行交互通信和共享数据</li></ol></li><li><p>Host App: 主程序，也属于Native App。主要功能包括三方面：</p><ol><li>加载Containing App</li><li>与Containing app通信交互</li><li>发布Safari App Extension到Apple App Store</li></ol></li></ul><p>结合上述的分析，Safari App Extension可使用两种组合的形式发布产品。一种是三个部分的App同时存在；另外一种是Host App只是作为发布工具，仅在第一次打开并完成扩展app安装之后就不再需要，因为安装好的扩展可在Safari-&gt;偏好设置-&gt;扩展中找到。</p><h5 id="与-Safari-Extension-的异同"><a href="#与-Safari-Extension-的异同" class="headerlink" title="与 Safari Extension 的异同"></a>与 Safari Extension 的异同</h5><p>Safari App Extension和Safari Extension的名称很相似，以至于在最开始研究的时候，我错以为二者是同一个东西，结果瞎忙活的一天才发现自己南辕北辙。不过，二者确实存在一些相似的地方。<a href="https://developer.apple.com/documentation/safariservices/safari_app_extensions/converting_a_legacy_safari_extension_to_a_safari_app_extension?language=objc">苹果的这篇官方文档</a>具体介绍了如何将Safari Extension转换为Safari App Extension。简单来说，二者共同点在于js和css代码是完全可以复用的，不同的地方是Safari Extension的配置、开发以及发布平台都是基于Safari浏览器，而Safari App Extension则是基于Xcode，且产品发布平台是Apple App Store。</p><h4 id="创建一个Safari-App-Extension"><a href="#创建一个Safari-App-Extension" class="headerlink" title="创建一个Safari App Extension"></a>创建一个Safari App Extension</h4><ol><li><p>创建</p><p> 因为Safari App Extension是以插件（plugin）的形式存在于Host App中的，因此需要首先创建一个Host App，也就是普通的Mac OSX的应用程序。然后再添加一个Safari App Extension的Target即可。</p></li><li><p>配置info.plist</p><p> Safari App Extension在被加载之前，Safari浏览器会通过读取info.plist文件以获得扩展的一些基本信息。</p><p> <strong>NSExtension</strong>，包括：</p><ul><li><p>NSExtensionPointIdentifier：定值，必须是com.apple.Safari.extension，表示Safari扩展</p></li><li><p>NSExtensionPrincipalClass：扩展的核心类名，默认是SafariExtensionHandler类，里面一些部分实现了NSExtensionRequestHandling和SFSafariExtensionHandling协议，作为与Safari扩展通信和交互的接口。</p></li><li><p>SFSafariContentScript：用于指定注入的js脚本，以数组的形式表示，在扩展加载之前注入Safari浏览器当前的tab页。缺省值是只有一个文件script.js，也可以注入多个js文件，注入顺序依据数组中的顺序。</p></li><li><p>SFSafariToolbarItem：用于配置Safari扩展在工具栏中按钮的类型、图片以及tooltip等。按钮类型包括comman、popover等。</p></li><li><p>SFSafariWebsiteAccess：包括Allowed Domains和Level两个属性，分别表示允许访问的网站域名列表和网页访问权限。其中Level可以是Some和All，分别表示部分访问和无限制访问。</p></li></ul><p> <strong>NSHumanReadableDescription</strong></p><p> 顾名思义，用于向用户阐述扩展基本功能的文字描述。在Safari浏览器的扩展管理器中选择某个插件就会显示对于的描述。 </p></li><li><p>运行 </p><p> 这里有一个坑，如果是Xcode中运行Host App并不会加载包含于其中的Safari App Extension，解决办法是编辑Safari App Extension的scheme，指定可执行文件为Host App，再编译运行即可。此外，如果是双击的方式打开某个已经编译好的Host App也会自动加载其中的扩展插件。然后在Safari-&gt;Preference-&gt;Extensions中可看到对应的扩展。值得注意的是，如果扩展插件不是从Apple App Store中下载的，那么是不能正常加载的，即便App在本地已经打包签名也一样。解决方法是勾选Safari Menu-&gt;Develop-&gt;Allow Unsigend Extensions即可。</p></li><li><p>调试 </p><p> Safari App Extension调试有两个值得注意的地方，第一，因为扩展插件是依附于Host App运行的，因为Xcode默认激活的是Host App进程，因此想要设置断点调试扩展插件，需要手动激活扩展进程。步骤是：在通过Xcode编译运行扩展进程之后，进入Safari Menu-&gt;Debug-&gt;Attach to process，选择对应的扩展进程。第二，在扩展插件中添加的NSLog调试信息不能在Xcode的终端输出，只能在电脑的控制台中查看。但是，lldb可以正常使用和输出。<a href="https://medium.com/@euginedubinin/ios-debugging-application-extension-without-a-host-app-89abf35a36af">更多细节参考这篇博客</a></p></li></ol><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>一个关于Safari App Extensions的Demo:<a href="https://github.com/icebergcwp1990/SafariAppExtensionDemo">GitHub Demo</a></p><p>苹果2016年WWDC关于Safari App Extensions的介绍：<a href="https://developer.apple.com/videos/play/wwdc2016/214/">Extending your App with Safari App Extensions WWDC 2016</a></p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
          <category> OSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济学中的成本</title>
      <link href="/2018/08/02/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%88%90%E6%9C%AC/"/>
      <url>/2018/08/02/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%88%90%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>最近在《薛兆丰经济学讲义》一书中看了“成本”这一概念在经济学中的定义，这与我过去的理解截然不同。</p><p>书中专门有一章是讲成本的概念，可见成长在经济学中占有非常重要的地位。书中说如果我们对成本的概念有了深刻的理解，就可以说对经济学了解了一半。</p><p>我以前对于成本的理解是做某件事情需要付出的代价，包括物质、金钱和劳动力等。然而，书中对成本的定义是：成本是放弃了的最大代价。换言之，如果做一件事情没什么可放弃的，也就不存在成本。比如，如果你选择做事情A的，那么就不能做事情B、C、D、E…。那么你做事情A的成本就是你所放弃的其他选项中价值最高的那个。</p><p>与成本容易混淆的一个概念是沉没成本。沉没成本是指那些已经发生但是不可收回的支出。比如你买票去看一场电影，但是看了10分钟之后你觉得这个电影不好看，最合适和做法就是马上离开电影院。此时，买电影票的钱已经沉没了，不可再放弃，也就不再是成本了。但是很少有人会在这种情况下果断地离开电影院。</p><p>既然成本的定义是“所有放弃了的选项中价值最高的那个”，但问题是所有放弃的选项并没有实现，我们又如何知道自己放弃东西的价值呢？答案是，这个价值只能靠想象。这正是成本深奥的原因所在。这个想象空间吸引了众多经济学家在成本的概念上下大功夫。他们充分挖掘了想象空间，分析公共品使用的成本、制度变迁的成本、社会成本、竞争本身带来的成本，将我们对世界的理解拓宽到前所未有的领域。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经济学的基础：稀缺</title>
      <link href="/2018/07/25/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%A8%80%E7%BC%BA/"/>
      <url>/2018/07/25/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%A8%80%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>稀缺与歧视</strong></p><p>稀缺是人类一直面对的问题，也是客观存在的事实。稀缺的含义非常之广，不仅指矿产、森林和能源等有形资产的匮乏，还有空气、美貌、天资、意志力和时空等无形资产稀少。</p><p>此外还有很多不易觉察到的稀缺资源，比如说地理位置的稀缺，如北上广这些一线城市的地理位置是稀缺的。另外信任也是稀缺的，不是可以随便建立起来的。同学之所以重要，是因为同学决定了你将来社交的圈子、工作层次。许多人读书的首要目的就是为了与同学建立信任这一项长期投资。</p><p>稀缺之所以一直客观存在，主要由两个原因：一是我们想要的东西别人也想要；二是人的需求在不断变化和升级，人的欲望是无止境的。</p><p>因为资源的稀缺，人们就不得不对资源的用途进行选择，而一旦做出选择就意味着存在区别对待，而区别对待就是歧视。（我觉得歧视在此处应该是中性词）</p><p>稀缺、选择、区别对待和歧视这四个概念，其实是一体的，只要有一个就意味着同时有其他三个。因为稀缺是客观存在的，因此歧视也是客观存在的。</p><p>既然不能逃避歧视，那么久只能直面歧视。有时候我们抱着平等主义的思想，试着消除歧视，结果却是产生了新的歧视，这也被称之为逆向歧视。</p><p>所以说，歧视不是问题，如何歧视才是问题。</p><p><strong>中年人的魅力</strong></p><p>今天听了梁实秋先生的文章《中年人的魅力就在如此》，里面的观点我个人比较赞同。虽然尚未进入中年，但是中年的困境的没办法逃避的，遂记录自勉：</p><ol><li><p>某个时期，某个社会，即使所有的青年人和老年人都中魔了，只要中年人不荒唐，事情就怀不到哪里去。</p></li><li><p>到了该自立的年岁还不知道精神上的自立，这是中国很多中年人的共同悲剧。</p></li><li><p>中年人最容易犯的毛病，是把一切希望寄托于自己的老年。</p></li><li><p>如今天天节衣缩食、不苟言笑、忍气吞声，都是在争取一个有尊严、有资材、有自由的老年。</p></li><li><p>我们无数次看到，一个窝囊的中年抵达不到一个欢乐的老年。这正像江河，一个浑浊的上游不可能带来一个清澈的下游。</p></li><li><p>习惯了郁闷的，只能延续郁闷；习惯了卑琐的，只能保持卑琐。而且，由于暮色苍茫间的体力不支，有朋散失，郁闷只能更加郁闷，卑琐只能更加卑琐。</p></li><li><p>中年人失去方寸的主要特征是忘记了自己的年龄，一会儿要别人像对待青年那样关爱自己，一会儿又要别人对待老人那样尊重自己。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英语发音规则总结</title>
      <link href="/2018/07/24/%E8%8B%B1%E8%AF%AD%E5%8F%91%E9%9F%B3%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/24/%E8%8B%B1%E8%AF%AD%E5%8F%91%E9%9F%B3%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><em>语句最常用的功能就是口语表达，一切的规则都是为了轻松且简单的表达！</em></p><p>最近在学习ESLPod的“Introducation to the United States”系列，在跟读的时候感觉挺吃力，一方面是因为对音标熟练程度不够，另一方面就是对英语发音规则缺乏认知。秉着主动学习的态度，通过在网路上查阅资料，对英语发音规则有如下总结。</p><p><em>英语发音规则的建立在对音标熟练且准确掌握的基础之上！</em></p><p>英语发音规则除了连读还包括浊化、爆破、同化、异化、缩读和略读等。大致包括七大技巧，它们分别是：</p><p><em>注：音标用-连接的地方表示要连读</em></p><p><strong>第一大技巧 连读的两大规律</strong></p><ol><li><p>词尾辅音+词首元音<br> eg: Time is up =&gt; [taim-iz-ʌp]</p></li><li><p>词尾元音+词首元音</p><p> (1). 在遇到前一个词是以[ei][ai][ɔi][i:][i][e]这几个元音结尾的情况，加[j]连读</p><p> eg: Hurry up =&gt; [hʌri-j-ʌp]</p><p> (2). 在遇到前一个词是以[aʊ][u:][ʊ]这个几个元音结尾时，加[w]连读</p><p> eg: How often do you swim =&gt; [haʊ-w-ɔfən]</p></li></ol><p><strong>第二大技巧 浊化的两大规律</strong></p><p>所谓浊化就是把清辅音读成浊辅音</p><p>清辅音：[p][t][k][f][s][θ]</p><p>浊辅音：[b][d][g][v][z][ð]</p><ol><li><p>元音+清辅音+元音</p><p> eg: letter =&gt; [‘lɛdɚ]  water =&gt; [ˈwɔdɚ] , stay out of this matter =&gt; [stei-y-aʊ-dv-ðis mædɚ]</p></li><li><p>元音+T+L</p><p> eg: battle =&gt; [bædl] cattle =&gt; [kædl]</p></li><li><p>Flat T的浊化</p><p> 3.1 在元音[ɚ]的前后</p><p> eg: artist =&gt; [ardst]  thirty =&gt; [θɚdi]</p><p> 3.2 两个tt并存时</p><p> eg: batter =&gt; [bædɚ]</p><p> 3.3 t在[əl]之前</p><p> eg: hospital =&gt; [hɑspɪdl]</p><p> 3.4 一般情况下，t在n和e之间，则t通常不发音。</p><p> eg: printer =&gt; [prɪn’ɚ]  center =&gt; [cen’er]<br>  winter =&gt; [win’er]   presented =&gt; [presen’ed]</p></li></ol><p><strong>第三大技巧 爆破的四大规律</strong></p><ol><li><p>爆破音略读：当前一个单词的词尾是爆破音（[p][t][k][b][d][g]）且后一个单词的词首也是爆破音，则省略前一个单词的词尾。</p><p> eg: take care =&gt; [tei-kɛr]</p></li><li><p>不完全爆破：所谓不完全爆破就是对于需要爆破的音，我们仅仅摆出对于的口型而不发出声音。</p><p> (1). 词尾爆破音+摩擦音（[f][s][θ][v][z][ð][r][j][w][ʃ][ɛ]）</p><p> eg: I’m almost there =&gt; [im ɔlmos(t) ðɛr]</p><p> (2). 词尾爆破音+破擦音[tʃ][dʒ][ts][dz][tr][dr]</p><p> eg: That joke =&gt; [ðæ(t) dʒok]</p></li><li><p>鼻音爆破省略：同一意群内，爆破音在鼻音[m][n][ŋ]前，爆破音省略以停顿代替</p><p>eg: Good night =&gt; [gʊ(d) nait]</p></li><li><p>舌边音爆破省略：爆破音+舌边音[l]</p><p> eg: It’s deadly =&gt; [it z dɛ(d)li] , Old lady =&gt; [ol(d) ledi]</p></li></ol><p><strong>第四大技巧 同化的二大规律</strong></p><ol><li><p>相互同化</p><p> (1). /t/+/j/-&gt;/tʃ/</p><p> eg: I got you =&gt; [i gɑ tʃ u]</p><p> (2): /d/+/j/-&gt;/dʒ/</p><p> eg: Did you =&gt; [Di dʒ u]</p><p> (3) /s/+/j/-&gt;/ʃ/</p><p> eg: God bless you =&gt; [Gɑ blɛ ʃ u]</p><p> (4) /z/+/j/-&gt;/ʒ/ </p><p> eg: How is your boyfriend =&gt; [Haʊ iz ʒ ʊr]</p></li><li><p>顺向同化：主要同于词尾加s和ed的情况，这两个音都存在清辅音和浊辅音两种发音，具体发音与该音的前一个音标的清|浊一致。</p><p> (1). 名词的复数</p><p> eg: friends =&gt; [frɛndz] , books =&gt; [bʊks]</p><p> (2). 第三人称单数</p><p> eg: works =&gt; [wɜːks]</p><p> (3). 过去式或过去分词</p><p> eg: looked -&gt; [lʊkt]</p></li></ol><p><strong>第五大技巧 异化：所谓异化就是当清辅音夹在/s/和元音之间时，清辅音发生浊化</strong></p><ol><li><p>sp+元音</p><p> eg: speak =&gt; [sbi:k]</p></li><li><p>sk+元音</p><p> eg: school =&gt; [sgʊl]</p></li><li><p>st+元音</p><p> eg: start =&gt; [sdɑrt]</p></li><li><p>str+元音</p><p> eg: strange =&gt; [sdrendʒ]</p></li></ol><p><strong>第六大技巧 缩读：缩读规律性不强，不能一一列举</strong></p><ol><li><p>常见缩读</p><p> (1). want to =&gt; [wanna]</p><p> (2). be going to =&gt; [be gonna]</p><p> (3). got to =&gt; [gotta]</p><p> (4). because =&gt; [‘cause]</p><p> (5). out of =&gt; [outta]</p><p> (6). you =&gt; [ya]</p><p> (7). what is the =&gt; [what’sa]</p><p> (8). sure =&gt; [sher]</p><p> (9). what are you =&gt; [wachya/wacha]</p><p> (10). ing =&gt; [in’]</p></li><li><p>情态动词完成时和过去将来时的不规则缩读</p><p> (1). could have =&gt; could’a</p><p> (2). must have =&gt; must’a</p><p> (3). should have =&gt; should’a</p><p> (4). would have =&gt; would’a</p></li><li><p>of的不规则缩读 (本质上是由于语速+f的弱读+上下文导致)</p><p> (1). kind of =&gt; kinda</p><p> (2). a lot of =&gt; a lotta</p><p> (3). lots of =&gt; lotsa</p><p> (4). sort of =&gt; sorta</p><p> (5). bunch of =&gt; buncha</p><p> (6). because of =&gt; becausa</p></li></ol><p><strong>第七大技巧 略读</strong></p><ol><li><p>词尾爆破音略读</p><p> eg: very goo(d) , nerver give u(p)</p></li><li><p>意群结尾的爆破音</p><p> eg: I thin(k) you shouldn(t) punish him too har(d)</p><p> 注：I + think是一个意群，经过think后面紧接you，但是you属于宾语从句，不是一个意群。 </p></li><li><p>同类音：[s]/[θ] , [s]/[ʃ], [z]/[ð]，谁在前面谁先死</p><p> eg: Thi(s) shop i(s) so romantic </p></li><li><p>t音的消失： 当[t]在[n]和元音之间（原因可能是[t]的音弱读像边音l因此可以直接略读）</p><p> eg: Internet =&gt; [In(t)ɚnɛt]</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于英语学习的困惑</title>
      <link href="/2018/07/19/%E5%85%B3%E4%BA%8E%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%B0%E6%83%91/"/>
      <url>/2018/07/19/%E5%85%B3%E4%BA%8E%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%B0%E6%83%91/</url>
      
        <content type="html"><![CDATA[<p>最近的英语学习计划执行的很糟糕，脑海里似乎对目前自己使用的学习方法没有足够的信心或者理论支撑。于是今天又看了一遍《把你的英语用起来》书中Dr.Krashen教授提出的最适合中国人学英文的理论，以下是相关笔记：</p><ol><li><p>input输入假说。Dr.Krashen认为英文学习的根本在于input输入，缺乏输入就不可能学好任何一门外语。</p></li><li><p>i+1理论，也叫可理解性输入假说。在一条是在上一条的基础上作进一步补充说明。进行输入练习时，一定要遵循i+1的原则。i代表目前的水平，1代表稍微高一点点的难度。随着自己水平的提高，需要主动的调整输入材料的难度，使之符合i+1。</p></li><li><p>narrow input假说。输入的材料类型和难度级别在一定时间内相对要狭窄。这样做有极大的好处，只输入自己感兴趣的材料，可以把熟悉的语言知识以不同的模式快速熟悉起来。</p></li><li><p>情绪机制。学习材料和环境应该是有趣的、轻松自如的，才能实现效果的最大化。</p></li><li><p>系统化量化。英文学习必须建立一个系统化、量化的流程，规定好整个学习周期的时间，彻底突破。</p></li></ol><p><strong>自勉</strong></p><p>笛卡尔曾经有一个比喻：在森林里迷路，如果不停地换方法，最后的结果很可能是走不下去。然而如果你认准一个方向坚定地走下去，最后一定能走出森林，哪怕你绕了一段远路，但胜利最终是属于你的。所以，如果只有方法没有坚持下去的勇气，一切都是空谈。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《swift编程语言中文版》学习笔记</title>
      <link href="/2018/06/01/Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/01/Swift%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="2-9-类和结构体"><a href="#2-9-类和结构体" class="headerlink" title="2.9 类和结构体"></a>2.9 类和结构体</h4><p>swift中类和结构体的关系比其他语言更加密切，二者主要的区别在于：</p><ul><li>类支持继承</li><li>类支持运行时检测类实例类型</li><li>类有deinit函数</li><li>类是引用类型而结构体是值类型</li></ul><p>swift中类或结构体允许直接修改其属性（存在子属性的一般也就是类或结构体）的子属性，而在Objective-C不行  </p><p>结构体有一个默认的成员逐一初始化器</p><p>在Swift中，整数、浮点数、布尔值、字符串、数组、字典都是值类型，并且是以结构体的形式存在的，结构体和枚举也都是值类型，意味着赋值或参数传递过程都是属于值拷贝，而类是引用类型</p><p>用于判定多个类引用是否指向同一个类实例的两个恒等运算符：等价于（===）和 不等价于（===）</p><p>swift中同样存在指针，比如引用类型，但是其声明方式同值类型一样</p><p>由于集合类型（数组和字典）都是以结构体实现的值类型，因此在赋值或传参过程中会发生拷贝，但是swift只会在有必要拷贝的情况下（比如拷贝后的数组长度发生变化等）才会执行拷贝，因此不必顾虑集合类型拷贝带来的性能问题。</p><p>字典类型的拷贝过程，如果键或值是值类型，则拷贝对应的值类型，如果是引用类型则拷贝的引用（其实就是指针）</p><p>数组类型只有在操作困难修改数组长度时才会发生，即使是修改数组内的元素值也不会发生拷贝，而是引用。</p><p>使用unshare函数可以确保数组的唯一性，但是并不意外这一定会发生拷贝，而是在有必要时才会拷贝。而copy函数属于强制拷贝数组。</p><p><del>可以使用恒等运算符来判定两个数组是否共用了相同的元素</del></p><p>数组只有在长度发生变化的操作中才会进行值拷贝，否则属于引用赋值</p><h4 id="2-10-属性"><a href="#2-10-属性" class="headerlink" title="2.10 属性"></a>2.10 属性</h4><p>属性分为存储属性和计算属性，前者用于存储常或变量作为实例的一部分，只能用于类或结构体中，而后者用于计算一个值，可以理解成一种运算，可用于类、结构体和枚举中。</p><p><strong>存储属性</strong></p><p>当值类型的实例赋值给一个常量时，值类型的所有属性都会变成常量，即使是变量属性也不能再修改，而当引用类型的实例赋值给一个常量时，仍可以修改实例的变量属性。</p><p>@lazy关键字用于声明延长存储属性：在第一次被调用时才会计算初始值的属性，类似懒加载。用前提包括必须是存储属性且是变量属性。因为常量属性在构造之前必须要有初始值，因此不能声明为延迟存储属性。</p><p><strong>计算属性</strong></p><p>计算属性必须声明为（var）变量属性，因为它的值是不固定的。计算属性不直接存储值，而是提供一对getter和setter用来获取和访问其他属性或者变量的值。</p><p>如果计算属性的setter没有定义表示新值的参数名，则可以使用默认名称newValue。</p><p>一个计算属性如果只有getter没有setter那就是只读类型，</p><p><strong>属性监视器</strong></p><p>作用类似于OC的KVO，可以为延迟存储属性之外的属性添加属性监视器，也可以通过重载的方式为父类的属性添加属性监视器。</p><p>两种监视器：willSet和didSet，前者的参数是新属性值，缺省参数名为newValue。后者的参数是旧属性值，缺省值参数名为oldValue。监视器在属性初始化时不会被触发。</p><p><strong>全局变量和局部变量</strong></p><p>计算属性和属性监视器同样适用于全局和局部变量。全局的常量或变量默认就是延迟计算的且不需要标记@lazy关键字。</p><p><strong>类型属性</strong></p><p>存储属性和计算属性通常用于特定类型的实例，但是属性也可以直接用于类型本身，称之为类型属性</p><p>类型属性类似于OC中声明在超类中的属性（swift没有超类的概念）。类型属性可以被所有实例访问。</p><p>用关键字static定义值类型的类型属性，用class定义类的类型属性。</p><p>值类型可以定义存储型和计算型的类型属性，而类只能定义计算型的类型属性。存储类型的类型属性必须在声明时指定默认值，因为类型本身没有构造器（只有为实例提供的初始化构造器）。</p><p><em>为什么类不能定义存储型的类型属性？很可能与类是引用类型有关系？</em></p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> {</span><br><span class="line"><span class="comment">//static关键字</span></span><br><span class="line"><span class="comment">//存储型</span><span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">"Some value."</span></span><br><span class="line"><span class="comment">//计算型</span><span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> {<span class="comment">//return a int value </span></span><br><span class="line">}}</span><br><span class="line"><span class="comment">//枚举类型</span><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> {</span><br><span class="line"><span class="comment">//存储型</span><span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">"Some value."</span></span><br><span class="line"><span class="comment">//计算型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> {<span class="comment">//return a int value </span>}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//类类型</span><span class="keyword">class</span> <span class="title class_">SomeClass</span> {</span><br><span class="line"><span class="comment">//class关键字</span></span><br><span class="line"><span class="comment">//只能定义计算型属性</span><span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">computedTypeProperty</span>: <span class="title class_">Int</span> {<span class="comment">//return a int value </span>}}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-11-方法"><a href="#2-11-方法" class="headerlink" title="2.11 方法"></a>2.11 方法</h4><p>方法是与某些特定类型相关联的函数，方法分：实例方法和类型方法</p><p><strong>实例方法</strong></p><p>方法和函数的局部名称和外部名称的默认行为的区别：</p><p>方法的第一个参数的外部参数可以省略，等价于在参数前加下划线（_），第二个及后面的参数名称可以同时作为局部和外部参数名称，等价于在参数前加#号。</p><p><strong>self属性</strong></p><p>self属性不需要显式调用，主要使用场景在于区分方法参数与实例属性，方法参数享有优先权，因此需要self指定实例属性消除歧义。</p><p><strong>mutating关键字</strong></p><p>类中的成员为引用类型，所以修改实例及其属性的值不会改变类型；而结构体和枚举中成员均为值类型，修改变量的值就是相当于修改变量的类型。Swift中默认不允许修改类型，因此需要前置mutaing关键字来表示该函数中能够修改类型。</p><p>值类型中的一般的实例方法不能修改其实例属性，而使用mutating关键字声明实例方法可以修改属性，并且修改的状态保留在原始结构中。在此方法中还可以给self重新赋值一个全新的实例，并替换原有实例。</p><p>枚举的mutating方法可以把self设置为枚举类型中不同的成员。</p><p><strong>类型方法</strong></p><p>类型方法的声明与类型属性声明类似，类的类型方法加关键字class，结构体和枚举的类型方法加static。</p><p>在本类或结构体的范围内，类型方法可以相互调用，也可以直接调用类型属性，不需要显式类型名称做为前缀。</p><h4 id="2-12-附属脚本"><a href="#2-12-附属脚本" class="headerlink" title="2.12 附属脚本"></a>2.12 附属脚本</h4><p>附属脚本本质上提供了一种访问对象、集合或序列的快捷方式，可以定义在类、结构体和枚举中。使用时配合”[]”语法糖直接对多个属性同时访问或赋值</p><p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同进行重载，而且索引值得个数可以是多个。</p><p>定义附属脚本使用subscript关键字，没有函数名，或者说subcript就是默认函数名称。附属脚本对于索引入参的数量和类型没有限制，返回值可以是任何类型，但是<em>不能使用in-out参数和对参数设置默认值。</em></p><p>附属脚本在定义上与实例方法类似，区别在于使用时附属脚本不需要指定函数名，而是根据参数自动匹配对应的脚本函数。</p><p>附属脚本与计算型属性类似，可以设定读写或者只读属性。区别在于附属脚本不是具体的属性，并且可以自定义参数和返回值类型和个数。而计算性属性的参数和返回值在定义时已经指定，可以理解为是对某一个具体属性的附属脚本，但是调用方式却没有附属脚本那么便捷，而是类似实例方法调用。</p><h4 id="2-13-继承"><a href="#2-13-继承" class="headerlink" title="2.13 继承"></a>2.13 继承</h4><p>在swift中，继承是区分“类”和其他类型的一个基本特征。子类可以调用和访问超类的方法、属性和附属脚本，并且可以重载这些方法。</p><p>不继承与其它类的类，称之为基类。不同于OC有一个共同的基类NSObject</p><p>在swift中，初始化器默认是不继承的。</p><p><strong>重写</strong></p><p>子类可以重写类方法、实例方法和附属脚本，使用关键字override标明</p><p>子类可以通过重写的方式将超类的存储型属性以计算型属性存在，但是该属性在超类还是存储型属性。</p><p>使用关键字final来防止重写</p><h4 id="2-14-构造过程"><a href="#2-14-构造过程" class="headerlink" title="2.14 构造过程"></a>2.14 构造过程</h4><p>与OC的构造器不同，Swift的构造器无返回值，主要任务是确保新实例在第一次使用之前完成正确的初始化。</p><p>在构造器中给存储型属性赋值时不会触发任何属性观测器</p><p>不同的构造器通过参数的不同进行区分，如果没有定义外部参数名，Swift会自动生成一个与内部参数名相同的外部名，等价于在内部名前添加#号。也可以使用下划线(_)来覆盖默认行为。</p><p><strong>默认构造器</strong></p><p>只有在所有成员变量都有默认值得时候，才能省略构造器，或者说Swift提供了一个默认的构造器。结构体的默认构造器是逐一成员构造器。</p><p><strong>值类型的构造代理</strong></p><p>构造器可以通过调用其他构造器完成部分构造过程，此过程称之为构造代理，且构造器代理的实现规则和形式在值类型和类类型有所不同。</p><p>值类型不支持继承，构造器代理任务只能给本身提供的其他构造器。而类类型可以调用超类的构造器完成构造代理。</p><p>值类型中一旦自定义了构造器后将无法访问到默认构造器，结构体则无法访问逐一成员构造器。如果定制的构造器是定义在扩张中，则不会覆盖默认构造器。</p><p><strong>类的继承和构造过程</strong></p><p>指定构造器是类中最主要的构造器：初始化类中所有的属性，并且根据父类链往上调用父类的构造器来实现父类初始化。每一个类至少拥有一个指定构造器，可继承自父类。</p><p>便利构造器则通过调用指定构造器实现，并给部分参数提供默认值。</p><p><strong>构造器的继承与重载</strong></p><p>与OC不同，一般情况下，Swift不会默认继承父类构造器，即此时创建子类时不能调用父类的构造器。可通过重载的方式继承与父类相同的构造器，且不需要使用override关键字。</p><p>两种特殊情况下，自动继承父类构造器：</p><ul><li>子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器和便利构造器。</li><li>子类提供了所有父类指定的构造器实现，将自动继承所有父类的便利构造器。</li></ul><p><strong>使用闭包或全局函数设置属性的默认值</strong></p><p>如果某个存储型属性的默认值需要特别的定制，使用闭包或全局函数为其提供定制的默认值。赋值时执行闭包或调用函数，将返回值赋给该属性。</p><p>使用闭包初始化属性时，不能在闭包中访问其它的属性，即便属性有默认值也不允许。同时，不能使用隐式的self属性或调用其它的实例方法。</p><h4 id="2-15-反初始化"><a href="#2-15-反初始化" class="headerlink" title="2.15 反初始化"></a>2.15 反初始化</h4><p>反初始化函数使用关键字deint来标识，只适用于类类型，在实例释放前一步自动调用。</p><p>反初始化函数调用链与初始化函数调用链相反，先完成子类的资源释放再执行父类的反初始化函数。与OC类似。</p><h4 id="2-16-自动引用计数-ARC"><a href="#2-16-自动引用计数-ARC" class="headerlink" title="2.16 自动引用计数(ARC)"></a>2.16 自动引用计数(ARC)</h4><p>引用计数只用于类类型的实例，值类型不是以引用的方式存储和传递的。</p><p><strong>循环引用</strong></p><p>使用weak引用或者无主引用来解除循环引用，弱引用可以为nil，所以必须是可选类型的，指向的实例释放后ARC自动将weak指针置空。无主(unowned)引用默认始终有值，因此必须是非可选型。如果无主引用指向的实例已释放，再次通过无主引用访问该实例即为野指针错误，需要手动置空。</p><p>weak指针适用情况：当两个对象AB之间均非一对一关系，即A对B或者B对A都是一个可选值，允许是nil</p><p>unowned指针适用情况：当对象A必须引用对象B，而A之于B是一个可选项，允许为空</p><p>unowned + 隐式展开可选项：对象AB属于一对一关系，且A对象是B的初始化参数之一，设置B为隐式展开的可选属性，此时B对象为赋值之前默认值为nil，不影响A的初始化操作，从而A初始化后可以作为参数完成B的初始化。</p><p><em>下面代码思路正确，但是代码执行出错，隐式展开可选项似乎没起作用，待进一步研究！</em></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Country与City属于一对一关系，且City的初始化依赖于Country</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">class</span> Country {<span class="number">2.</span> let name: String<span class="number">3.</span> let capitalCity: City! <span class="comment">//隐式展开可选项</span><span class="number">4.</span> init(name: String, capitalName: String) {<span class="number">5.</span> <span class="keyword">self</span>.name = name<span class="number">6.</span> <span class="keyword">self</span>.capitalCity = City(name: capitalName, country: <span class="keyword">self</span>) <span class="number">7.</span> }<span class="number">8.</span> }<span class="number">9.</span><span class="number">10.</span><span class="keyword">class</span> City {<span class="number">11.</span> let name: String<span class="number">12.</span> unowned let country: Country <span class="comment">//unowned指针</span><span class="number">13.</span> init(name: String, country: Country) {<span class="number">14.</span> <span class="keyword">self</span>.name = name<span class="number">15.</span> <span class="keyword">self</span>.country = country </span><br><span class="line"><span class="number">16.</span> }<span class="number">17.</span> }</span><br></pre></td></tr></tbody></table></figure><p><strong>闭包产生的循环引用</strong></p><p>类似于OC中Block产生的循环引用。</p><p><em>Swift中的约束：只要闭包内使用self的成员，就必须通过self指针调用，而不能直接调用，可提醒存在强引用的风险</em></p><p>通过定义占有列表解除强循环引用，占有列表有关键字weak或unowned和实例的引用组成，包含在一个中括号中，有逗号隔开。eg: [(weak|unowned), self]</p><p>占有列表放置在闭包参数和返回类型之前。如果没有指定参数或返回类型则放在关键字in前面。</p><p>当闭包和占有实例总是互相引用并总是同时销毁时，使用unowned定义占有列表。当占有引用有可能为nil时，使用weak。</p><h4 id="2-17-自判断链接"><a href="#2-17-自判断链接" class="headerlink" title="2.17 自判断链接"></a>2.17 自判断链接</h4><p>Swift的自判断链和OC中的消息为空类似，但是Swift可用于任意类型（值类型和类类型），并且一定会有返回值，返回值一定是可选项类型。</p><p><strong>可使用自判断链代替强制拆包</strong><br>二者调用方式类似：自判断值后面使用？号，而强拆使用的是！号。当自判断值为空时，强拆会引发运行时错误，自判断链则会返回一个空值，表示自判断链调用失败。</p><p>自判断链适用于调用属性、实例方法和附属脚本（子脚本）中，三者的任意组合成自判断链。</p><h4 id="2-18-类型转换"><a href="#2-18-类型转换" class="headerlink" title="2.18 类型转换"></a>2.18 类型转换</h4><p>Swift中的is和as两个操作符分别用来做类型检测和类型转换。</p><p>假如向下转换可能出现失败的情况，使用as?返回一个可选值，转换失败返回nil。假如确定一定能转换成功则使用as，有点类似强制解包。</p><p>Swift为不确定类型提供了两种特殊类型别名：</p><ul><li>AnyObject可以代表任何class类型实例</li><li>Any可以表示除了方法类型之外的任何类型</li></ul><h4 id="2-2-扩展"><a href="#2-2-扩展" class="headerlink" title="2.2 扩展"></a>2.2 扩展</h4><p>扩展是向一个已有的类、结构体或枚举类型添加新功能。与OC中的分类类似，但是Swift的扩展不需要知道名称，<em>可以理解成OC中的匿名分类？</em>。</p><p>Swift中的扩展可以：</p><ul><li>添加计算型属性和计算静态属性</li><li>定义实例方法和类型方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使一个已有类似符合某个接口</li></ul><p>Swift中扩展和OC中分类一样，扩展中的功能在该类型的所有实例都是可用的。</p><p><em>注意：扩展可以添加新的计算型属性，但是不能添加存储属性，也不可以向已有属性添加属性观测器</em></p><h4 id="2-21-协议"><a href="#2-21-协议" class="headerlink" title="2.21 协议"></a>2.21 协议</h4><p>类、结构体和枚举均可实现多个协议，中间用逗号分隔。</p><p><strong>属性要求</strong></p><p>协议能够要求遵循者包含一些特定名称和类型的实例属性或类属性，同时可以指定类型的读写权限，但是具体属性最终实现可以是存储型或者计算型属性。</p><p><strong>方法要求</strong></p><p>协议方法的声明和普通方法声明相似，但是不需要方法内容。</p><p>class中实现协议中的mutating方法时，不用写mutating关键字，因为类为引用类型，可直接修改类的属性；用结构体和枚举实现协议中的mutating方法时，则必须写mutating。</p><p><strong>协议类型</strong></p><p>协议可当做一种满足一定要求的类型对待，可用于声明满足协议的变量。比如委托模式，声明一个满足委托协议的代理变量，然后通过代理变量调用委托协议中的方法。</p><p><strong>在扩展中添加协议成员</strong></p><p>通过扩展为已存在的类型遵循协议是，该类型的所有实例也会随之添加协议中的方法。</p><p>当一个类型实现了某个协议中的所有要求却没有声明相应的协议时，可以通过扩展来补充协议声明。</p><p><strong>集合中的协议类型</strong></p><p>协议类型可以用来声明集合，表示集合中的元素均为协议类型。</p><p><strong>协议的继承</strong></p><p>协议能够继承一到多个其他协议。语法和类的继承相似。</p><p><strong>协议合成</strong> </p><p>一个协议可又多个协议采用protocol&lt;SomeProtocol, AnotherProtocol, ThirdProtocol&gt;这样的格式进行组合。</p><p>协议合成不会生成一个新的协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。</p><p><strong>检验协议的一致性</strong></p><p>使用is检验协议的一致性，使用as将协议类型向下转换为其他的协议类型。</p><ul><li>is操作符用来检查实例是否遵循了某个协议</li><li>as?返回一个可选值，当实例遵循协议时，返回该协议类型，否则返回为nil。</li><li>as用以强制向下转换。</li></ul><p><strong>@objc</strong></p><p>@objc表示协议的可选的，用可以用来表示暴露给Objective-C的代码。此外，@objc型协议只对类有效，因此只能在类中检查协议的一致性。</p><p>在@objc声明的协议中，可以使用@optional关键字作为前缀定义可选的属性或者方法。</p><p>调用可选方法是，在函数名和参数直接加上?来检查该方法是否被实现，当其不可访问时，？之后的语句不会执行，并且返回nil。</p><h4 id="2-22-泛型"><a href="#2-22-泛型" class="headerlink" title="2.22 泛型"></a>2.22 泛型</h4><p>泛型是一种清晰和抽象的代码表达方式，可以根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型，从而避免了代码重复。</p><p>泛型是Swift强大特征之一，许多Swift标准库是通过泛型代码构建的。</p><p><strong>关联类型</strong></p><p>定义协议时，通过associatedtype声明一个关联类型，不用具体指定实际类型。直到实现协议时，才给出关联类型的实际类型。</p><p><strong>通过extension为已知类型添加协议的兼容性</strong></p><p>如果某个类型已经覆盖了某个协议所包含的要求，那么可以通过拓展将已知类型和协议建立关联。有点像JS中的鸭子类型。</p><h4 id="2-23-高级运算符"><a href="#2-23-高级运算符" class="headerlink" title="2.23 高级运算符"></a>2.23 高级运算符</h4>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《李光耀观天下》读书笔记</title>
      <link href="/2018/05/16/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/16/%E6%9D%8E%E5%85%89%E8%80%80%E8%A7%82%E5%A4%A9%E4%B8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>《李光耀观天下》这本书是以李光耀先生的自述性自传，全书向读者阐述自己对当今这个世界的观点与看法。面对复杂多变的世界形势，他总能保持中立客观，并且抓住事情的本质。其字里行间透露着一种谦虚与客观的态度，言语中蕴藏着深刻的学问与广阔的见识。</p><span id="more"></span><p>相对于这边书的中文译名《李光耀观天下》， 我更喜欢它的英文名称《One Man’s View of the World》。英文书名似乎给人一种更为谦虚与中立的感觉，也许只是我个人感觉罢了。</p><p>读完此书之后，由于自己世界观的不健全，只对于书中关于的一些比较熟悉的国家的分析与见解印象比较认同，主要的亚洲国家，比如中日韩朝等。而对于其他国家的，特别是中东地区的阿拉伯国家，因为缺乏对这些国家的了解，只能处于一种认知与被动接受的角度去看待相关的分析。换言之，这本书带给我是一个新的看待世界的视角，从而进一步完善我的世界观。</p><p>书中除了最后四章，前面起章都是以国家为基本单位，阐述了李光耀先生对每个国家现状的分析以及未来发展的预测。最后四章分别分析了全球经济、能源与气候、个人生活以及与联邦德国总理赫尔穆特·施密特先生的对话。由于自己目前能力有限，没能站在一个更高中的角度提炼并串联每一个章节的中心思想，所以只能是按照书中原有的组织结构依次总结自己关于每个章节的心得体会。</p><h4 id="中国：一个强大的中央"><a href="#中国：一个强大的中央" class="headerlink" title="中国：一个强大的中央"></a>中国：一个强大的中央</h4><p>中国有着悠久的历史，历朝历代都是通过一个强大的中央政权来治理国家，这一点在中国人心中已经根深蒂固。因此，西方国家提倡的一人一票的民主选举制度是不能再中国出现。中国的特殊性也决定了中国需要开辟一条属于自己的道路。此外，在中国这片土地上不再可能出现大规模的动乱或者反政府活动了。从“乌坎事件”可以得出两点结论：一是共产党能保持它的掌控地位，在党的领导下社会可以恢复秩序。二是共产党拥有强大的国家安全机器，可以运用软硬兼施的方式控制局势。与此同时，共产党是支持民众反对腐败的地方官的，而民众也是支持共产党，反对的只是腐败的地方官。</p><p>中国经历改革开放，在过去的四十年经济突飞猛进，重新以重要大国的形象出现在国际舞台。中国人也变得崇尚多元爱好的充满理想。随着全国各地的变化，中国的政治也必须变革。然而中国地域广阔，人口基数大，维持社会稳定是根本前提，因此制度改革的进度一定是缓慢的。此外，中国目前的法制不健全，更多的是依赖于人制，这与中国的特殊国情和历史渊源有关。不论将来中国如何发展体制和制度，完全都是中国式的，并且有一个不变的核心：强大的中央政权。</p><p>中国能发展到今天这个地步离不开历届领导人的贡献。毛泽东作为开国主席，主张革命之后再革命，尽管其主导的“文化大革命”给新中国带来毁灭性的打击，但是仍不能掩盖他的光芒。第二代领导人邓小平作为改革开放的领路人，扭转了中国的发展方向，给中国带来了翻天覆地的改变。第三代领导人是邓小平选拔的江泽民，进一步的加快了中国四个现代化的建设步伐。第四代领导人胡锦涛是一位整合者，为人沉着冷静，思考缜密，面临着城镇化与贫富差距等多项挑战，并作出了一些根本性的改变。第五代领导人习近平能将中国带向何处尚不可知。但是历届领导人都有一个共同的特点就是不露锋芒，保持谦逊。</p><p>为了营造和维持一个有利于经济发展的国际环境，中国只寻求和平崛起，绝不称霸。但是在关乎主权和领土完整等原则性问题，中国是丝毫不会退让与妥协的。其中，中日的纠纷在于钓鱼岛归属问题，中美则会出现的最大危机是在台湾问题上。李光耀先生认为随着中国大陆与台湾在经济等多方面的联系日趋紧密，台湾与大陆重新统一只是时间问题，这是任何国家无非阻挡的。</p><p>当今的中国，由于经济发展速度过快，以至于社会其他方面没能跟上步伐实现同步发展，意味着高速发展的背后隐藏着各种各样的问题。首先是新一代中国年轻人的观念转变，他们不像经历过战争、革命和改革的老一辈中国人明白和平稳定的珍贵。新一代的年轻人看到的更多是当下中国的强盛，并以这样的姿态自居，这样导致在面对一些国际敏感话题是容易自傲。其次是中国社会贫富差距的进一步加大，以及为了眼前发展经济从而忽略了环境与长远发展，这无疑是国内稳定与经济发展潜在隐患。最后是经济发展将面临瓶颈，最容易实现经济发展的时期已经过去，为了确保今后几十年的经济能持续增长，整个经济战略需要调整。</p><h4 id="美国：陷入困境但优势仍在"><a href="#美国：陷入困境但优势仍在" class="headerlink" title="美国：陷入困境但优势仍在"></a>美国：陷入困境但优势仍在</h4><p>由于中国的崛起以及中国亚洲有着距离上的优势，导致美国在亚太地区的影响力正在削弱。为了应对这一势力格局的变化，打算重新将战略重心移回本区域。除中国之外的其他亚洲国家希望美国持续参与本区域的事务，以平衡中国的影响力，有助于保持亚太区域的稳定和安全。但是美国能否长期履行承诺与美国的未来的经济发展有关系，发挥影响力需要有强大的经济做后盾。</p><p>美国的成功在于它活力十足的经济，这活力的来源是一种不可思议的能力，不仅能以更少资源去实现同等的产出，还能不断创新。这使得美国能够始终走在科技前沿，掌握话语权。此外，美国是一个开放自由，且由移民组成的社会，能够吸引并且留住人才。中国在吸引人才方面不如美国的原因之一在于语言问题，比起英语，华语是一门更难掌握的语言。美国竞争力的另一来源，是有许多遍布全国各地并相互竞争的卓越中心，每个中心都认为本身能媲美其他中心，从而构成了美国这样一个多元的社会。而中国则完全不同，中国人相信只有中央强大，中国才能繁荣。最后，美国拥有一种颂扬勇闯天下的文化。对于成功的企业家会获得应有的社会地位和认可，对于创业失败的情况认为是通往终极成功的必要过程，不会因此而受到鄙视。</p><p>美国面临着很多严重问题。首先是债务问题。比起一些欧元国家，美国面临的债务问题相对轻微。部分原因在于美元是世界储备货币，这意味着美国享有比其他国家低许多的借贷成本。国会与总统对如何解决债务问题难以达成共识，他们更关注下一届选举。其次，美国公立学校的教育得不到重视，中下层人才的教育问题面临危机，不同于私立学校，公立学校的地方政府拨款受金融危机影响被进一步削减，而联邦政府又不能直接干涉。长久下去，美国的竞争力会逐渐下滑。除此之外，美国面临的问题还包括：基础设施差、阶级鸿沟加剧、种族歧视根深蒂固、拜金主义严重以及繁琐冗长的选举过程。</p><p>美国人属于乐观主义，从根本上相信未来会更好，更倾向于提前消费。完全不同于中国和日本人的未雨绸缪。美国作为世界第一强国，乐于担任世界警察的职务，但是有时候确得不偿失，进攻伊拉克和阿富汗就佐证。</p><h4 id="欧洲：衰退与分歧"><a href="#欧洲：衰退与分歧" class="headerlink" title="欧洲：衰退与分歧"></a>欧洲：衰退与分歧</h4><p><strong>欧元困境</strong></p><p>欧洲现在有17国家加入欧元，整个欧洲现在处于一种财政没有整合而货币是通一的困境中。不同的欧元国家的财政预算和公民消费习惯差异很大，国家之间的发展速度和经济实力也存在差距，这些不协调因素逐步破坏者欧元一体化制度。欧元面临的困境是一个必然的历史结果。</p><p>解决欧元危机，有三个可行的方案。</p><ul><li>完全整合。模仿美国建立有一个联邦储备局和一个财政部长，当某个洲出现经济困境，联邦政府会伸出援手，而其他州的民众也视他们为同胞，不会要求偿还。而在欧洲是行不通的，不同国家之间民族差异性大。而且欧洲各国的选民不大愿意将国家的财政大权交给一个中央机关。</li><li>欧元解体。每个国家有各自的财政部长并各自自行管理本国货币。当一个国家经济放缓，因为不受限于一种共同货币，可以采用“量化宽松”政策扩大货币供应量，使货币贬值，加大出口吸引力。欧元区国家则没办法采用这样的货币政策来刺激经济复苏。此外欧洲国家出于选举的压力，也不能通过消减福利，改革税收制度，放宽劳动力市场规则或延后退休等措施来加强国家竞争力。</li><li>局部解体。这种结局的可能性很多，竞争力相近的国家可组合成一个新共同体，从而分成不同层次的欧洲。每个层次以不同的速度发展。</li></ul><p><strong>福利社会和僵化的劳动力市场法律</strong></p><p>欧洲走向衰退的另一个原因在于：难以维继的福利制度和僵化的劳动力市场法律。随着二战红利的殆尽和全球化市场经济的发展，欧洲工人的竞争力逐步削弱，工资也自然下降，对社会福利的依赖也越大。福利制度一定制定就很难往下调整，政府处于选举的压力，往往尽力满足民众的要求。</p><p>如果说福利开支的维持在一定水平的话，问题或许还可以受到控制。可事实是这类开支的随时间递增的，占国家总收入的比重逐步上升。原因之一民粹主义者要求更多福利。</p><p>福利社会最坏的影响，在于它削弱了人们努力奋斗的动力。如果社会保障体系设计成不管一个人努力工作或是悠闲生活都能得到同样的好处，那么努力的工作的意义变得渺小。</p><p><strong>欧洲一体化的理想幻灭</strong></p><p>欧洲如果能实现一体化，不论从和平的角度还是经济发展的角度都是一个最佳选择。然而现实是欧洲不可能完全融合。首先欧洲国家未能成功的实现货币一体化，更何况实现政治和军队一体化。原因在于欧洲国家都有自己悠久的历史与光荣的传统，并且各自引以为豪。此外，欧洲其他国家也不会接受英语作为唯一的工作语言，因为语言背后有着荣耀和文学，他们都想保留本身的语言。</p><p>尽管欧洲在国家的地位和话语权减弱，但是不会对其生活水平造成同等的影响。这片大陆有着高水平的教育和技能，足以让欧洲人过上好生活。个别国家将有些衰退，但会根据自身的竞争力达到一个稳定的状态。</p><h4 id="日本，走向平庸"><a href="#日本，走向平庸" class="headerlink" title="日本，走向平庸"></a>日本，走向平庸</h4><p>关于日本，人口的老龄化加上持续下降的生育率，相较于经济停滞不前和政治领导人虚弱等问题，人口问题成为了日本面临的最大问题。任何社会的经济主力军都是年轻人，年轻人群体的比重逐渐减小，也意味着经济的萎缩。即便是像中国这样的人口大国，在实时计划生育近30年后，随着人口红利的消失，开始出现老龄化和生育率低的问题，于是在2013年放宽生育政策，开发二胎，试图调整和改善社会人口组成结构。由此可见人口问题对经济是多么重要。</p><p>日本人口问题的产生原因是多方面的，其中包括：</p><ol><li>日本女性的社会角色开始由传统的家庭主妇向现代的职业女性转变</li><li>日本企业对女性的包容性差，让职业女性很难兼顾家庭和工作，导致生育成本过高</li><li>日本民族的种族纯洁性观念强，日本社会对外国移民极为抗拒，即便是对日侨移民也是如此</li></ol><p>即便如此，不可否认日本是一个了不起的民族，公民素质很高，团队精神举世无双。这些特质让日本在未来的一段时间内仍能在世界经济强国中有一席之地。但是日本正在走向平庸也是不争的事实。</p><h4 id="朝-韩，偷天换日"><a href="#朝-韩，偷天换日" class="headerlink" title="朝 韩，偷天换日"></a>朝 韩，偷天换日</h4><p>谈及朝鲜和韩国，绕不开的话题的朝鲜半岛局势。就目前而言，朝鲜半岛局势在可预计的未来不会有什么变化。即不可能和平统一又不可能爆发战争。</p><p>和平统一的阻力在于，一方面朝鲜与韩国的经济实力差距悬殊，韩国暂时不愿意为了和平统一而付出巨大的经济利益。而是希望朝鲜能够对外开放，发展经济，在双方差距缩小到一定程度时才考虑和平统一的可行性；另一方面，作为朝鲜邻国的中国不愿意看到朝韩统一，这意味美国可能将会在朝鲜设立军事基地，更近一步的威胁中国。</p><p>爆发战争的可能性也几乎为零。一方面尽管朝鲜有核武器，对韩国包括首尔在内的重要城市有直接的杀伤力。但是朝鲜的核武器更多在于巩固金氏政权；另一方面，朝鲜的工业水平与韩国差距太大，即便的真的发动战争也很可能战败。</p><p>目前来说，朝鲜的经济仍然停滞不前，国内人民的温饱问题都没能得到解决。韩国则仍然保持经济增长，得益于三星、LG和现代等国际品牌企业。虽然同日本一样面临生育率低和人口老龄化问题，但是韩国愿意接纳外国移民，所以这问题能够得到缓解。</p><h4 id="印度：受种性制度羁绊"><a href="#印度：受种性制度羁绊" class="headerlink" title="印度：受种性制度羁绊"></a>印度：受种性制度羁绊</h4><p>印度是一个由多种族组成的国家，印度境内使用的民族语言多达400种。印度有着中国的人口规模，却不同于中国一样有共同使用的语言：普通话。印度语言环境的多元化无疑是国家管理的一大障碍。</p><p>印度从来都不是一个单一性的实体，不同于中国超过90%的人口比例是汉族。因此，我们不能把中国和印度两大文明相提并论。印度不具备中国那样的决心和专一。</p><p>这种分离情况也体现在印度的政治体系上。地区的领导人不会按照联邦政府的意志办事，他们的委任来源于百姓的选票。</p><p>此外，种姓制度使得印度情况更为复杂，成为了阻碍其发展的另外一个重要的原因。印度分为婆罗门人（僧侣阶级）、吠舍人（平民阶级）和达利人（贱民阶级）。不同的阶级直接等级分明，不能通婚。从宏观的层面来看，种姓制度限制了各阶级的基因库的多样化。</p><p>由于印度国内的官僚化和阶级化，导致许多有才干的印度人到国外寻求机遇，并且一去不回，造成人才流失，进一步影响国家发展。</p><p>此外，印度的基础建设落后，虽然人口红利优势明显，但是却很难得到国外投资方的青睐。</p><p>综上，首先，印度虽然是民主制度，然而却没能体现民主带来的优势。其次，由于印度有着悠久的历史，社会内有一些根本的势力难以改变。印度受制于内部构造结构和种姓制度的束缚，几乎无法挣脱。</p><h4 id="马来西亚：分道扬镳"><a href="#马来西亚：分道扬镳" class="headerlink" title="马来西亚：分道扬镳"></a>马来西亚：分道扬镳</h4><p>在李光耀先生看来，马来西亚和新加坡是同根同生的，当年英国离开时留给两个国家大致相同的遗产，两国在后殖民时期的发展水平也旗鼓相当。可以说两个国家离开殖民统治之后处于同一起跑线。</p><p>然而，两个国家的领导人选择两条完全不一样的发展道路。马来西亚放弃了英语选择建立一个以马来语为主的国家，并且是属于马来人的马来西亚。新加坡则选择建立一个以英语为主的多元种族化的国家。正所谓道不同不相为谋，两个国家最终没能结成联盟，分道扬镳。</p><p>马来西亚随着马来人的比重越来越重，其他种族的权益得不到保障，从而造成了人才流失严重。马来人的特权已经在马来西亚社会根深蒂固，因为即便是新的领导人有意促进种族和谐加强团结，有意提出一些保障其他种族的权益的举措，但是实际上往往是力不从心，因为他们需要大多数马来人的选票来赢的竞选。</p><p>由于马来西亚和新加坡的发展道路截然不同，且均不能改变对方的想法，二者学会了和平相处，接受彼此的不同。</p><h4 id="印度尼西亚：偏离中央"><a href="#印度尼西亚：偏离中央" class="headerlink" title="印度尼西亚：偏离中央"></a>印度尼西亚：偏离中央</h4><p>印度尼西亚是由分散在5000公里范围内的1.75万个岛屿组成，有超过200个民族，是一个多元化的国家。</p><p>在哈比比出任印尼总统之前，印尼是全世界政治上最集权的国家之一。苏加诺和苏哈托都依赖于中央集权来管理这个地理上分散的国家。除了利用国家机器镇压叛乱和维持团结之外，苏加诺选择了马来语而非爪哇语作为印尼的官方语言，尽管爪哇族是印尼的主要民族，苏加诺本身是爪哇人，且印尼的经济和文化中心的首都雅加达也位于爪哇岛。这一举措不仅解决了印尼各地区的交流沟通问题，还有利于维护国家团结稳定。</p><p>在哈比比担任总统之后，政府开始走地方化道路。中央权力的下方不仅加速了地区经济的发展，也维持了国家统一。然而，地方化是一个不可逆转的过程，一旦权力下放到地方就不可能再收回。</p><p>地方化对于印尼是发展是一件好事，但是并不能解决印尼面临的所有问题。除了面对传统的挑战，印尼还需要面对新的挑战。其中包括中央的政治僵局、基础建设的落后和贪污成风的现状。</p><p>印尼目前发展虽然良好，但是其本质上是以天然资源为基础的经济体，印尼国民也过于依赖土地的馈赠，而非靠双手谋生。印尼因为其丰富的资源能够吸引国外的巨额投资，从而获得持续的经济增长。然而，自然资源总有耗尽的一天，届时再纠正印尼国民已经养成的闲散的生活态度不是一件容易的事情。</p><h4 id="泰国：苏醒的社会底层"><a href="#泰国：苏醒的社会底层" class="headerlink" title="泰国：苏醒的社会底层"></a>泰国：苏醒的社会底层</h4><p>在他信·西那瓦就任之前，泰国的精英阶层垄断了整个政治局面，执政方针主要以首都的利益为考量。</p><p>在他信担任泰国首相之后，将原本被曼谷既得利益集团和中产阶级独占的资源转移到泰国较为贫穷的地区，颠覆了泰国的政治现状。他信为农民提供贷款，给贫困家庭的学生颁发海外奖学金，为城市贫民提供政府津贴的住房，让穷人享受医疗保障。</p><p>他信的这些政策严重的威胁和影响到曼谷精英阶层的利益，他信的政府在2006年的军事政变中被推翻。泰国的首都陷入巨大的动荡，主要有两股军事力量相互抗衡，分别是保皇派的黄衫军和支持他信的红杉军。</p><p>在泰国，军人向来是扮演者主要的角色。但是随着年轻一代对王室的尊敬日渐减弱，黄衫军的实力也日渐衰退。整个社会还是沿着他信开创的道路继续前进，许多农民加入中产阶级，协助推高国内消费。泰国的发展态势会是良好的。</p><h4 id="越南：解不开的社会主义思维枷锁"><a href="#越南：解不开的社会主义思维枷锁" class="headerlink" title="越南：解不开的社会主义思维枷锁"></a>越南：解不开的社会主义思维枷锁</h4><p>越南同中国一样是一个忠于社会主义道理的国家，在中国改革开放几年之后，越南也决定推行自由市场改革。然而，越南老一辈共产党领袖的思维基本上无法跳出社会主义的枷锁。他们始终都拿不出像中国领导人一样的真正决心，去彻底改变整个制度。</p><p>和中国不同，越南没有像邓小平那样既在干部中有不可动摇的崇高地位，又坚信改革是唯一出路的领导人。究其原因在于，在改革开放之前十几年间中国在不断的摸索和积累经验，为改革打下了基础。而此时的越南正与美国进行残酷的越南战争，与此同时很多了解资本主义运行规律的成功商人也纷纷逃离了越南。</p><p>越南人是东南亚最能干和精力最充沛的人民之一，但愿在老一代共产党领导人谢世之后，新一代年轻人接班之后，能够肯定自由市场的重要性，让越南进入一个新篇章。</p><h4 id="缅甸：将领改变路向"><a href="#缅甸：将领改变路向" class="headerlink" title="缅甸：将领改变路向"></a>缅甸：将领改变路向</h4><p>缅甸军政府在2011年开始改革，将缅甸从死胡同中挽救过来，然而这种彻底的改变，既不是源于深刻的自我反省或真实的顿悟，也不是一个濒临倒台的独裁政权急于自救的举动，而是别无选择。</p><p>对比于有着同样自然资源和气候条件的泰国，通过开发市场变得富裕，缅甸却停滞不前，整个国家固步自封近40年。直到2011年无路可走才选择掉头。</p><h4 id="新加坡：处在十字路口"><a href="#新加坡：处在十字路口" class="headerlink" title="新加坡：处在十字路口"></a>新加坡：处在十字路口</h4>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人物传记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacOS系统中使用OpenCV库（sandbox supported）</title>
      <link href="/2017/12/24/%E5%9C%A8MacOS%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8OpenCV%E5%BA%93%EF%BC%88sandbox%20supported%EF%BC%89/"/>
      <url>/2017/12/24/%E5%9C%A8MacOS%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8OpenCV%E5%BA%93%EF%BC%88sandbox%20supported%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近因工作需要研究图片格式转换相关的知识点，其中使用到OpenCV库（一个基于BSD许可（开源）发行的跨平台计算机视觉库，很强大）中的ssim（结构相似性）算法实现来计算两张图片的相似度，用以做图片转换前后的对比。因此需要在Xcode中配置OpenCV库并且能在沙盒下使用，这一过程花费了将近一天的工作时间才配置成功，由于网上大多数资料基本上都是在非沙盒条件下的配置教程，对我没有太多实质性的帮助，这也是笔者写这篇博客的意义所在。</p><h3 id="安装OpenCV库"><a href="#安装OpenCV库" class="headerlink" title="安装OpenCV库"></a>安装OpenCV库</h3><p>在Mac下，安装OpenCV库的方式一般有两种：使用brew命令或者使用make编译源代码。笔者用的是第一种：在终端执行命令：brew insall opencv，即可安装opencv库及其所依赖的动态库。安装成功之后，会在命令行终端的最后一行显示当前OpenCV库的安装路径和版本号，笔者电脑上的安装路径为：/usr/local/Cellar/opencv/3.4.0_1，版本号为3.4.0_1。</p><p>在/usr/local/Cellar/opencv/3.4.0_1/include目录下有两个文件夹：opencv和opencv2，里面是OpenCV相关的头文件。/usr/local/Cellar/opencv/3.4.0_1/lib/下有许多前缀为libopencv_的dylib文件，这些都是OpenCV的链接库文件。</p><h3 id="在MacOS下配置并使用OpenCV库"><a href="#在MacOS下配置并使用OpenCV库" class="headerlink" title="在MacOS下配置并使用OpenCV库"></a>在MacOS下配置并使用OpenCV库</h3><p>笔者项目中用到OpenCV库中的libopencv_imgproc.3.4.0.dylib库。因此下文以这个库为例进行展开，其他的库类似操作即可。</p><h4 id="使用otool查看库依赖关系"><a href="#使用otool查看库依赖关系" class="headerlink" title="使用otool查看库依赖关系"></a>使用otool查看库依赖关系</h4><p>首先使用otool命令查看libopencv_imgproc.3.4.0.dylib的依赖关系，必须确保其这些依赖的库在系统中能够找到。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib </span><br><span class="line">/usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib:</span><br><span class="line">/usr/local/opt/opencv/lib/libopencv_imgproc<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">@rpath/libopencv_core<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以看到libopencv_imgproc.3.4.0.dylib一共依赖了4个库，忽略系统自带的libc++.1.dylib和libSystem.B.dylib，因为这两个库任何Mac电脑上都可以找到。另外两个库分别是@rpath/libopencv_core.3.4.dylib和/usr/local/opt/tbb/lib/libtbb.dylib，分别查看这两个库所依赖的库。</p><p>查看libopencv_core.3.4.dylib库的依赖关系。这个库是以libopencv_开头的，与libopencv_imgproc.3.4.0.dylib在同一个目录下。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L  /usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib </span><br><span class="line">/usr/local/Cellar/opencv/<span class="number">3.4</span><span class="number">.0</span>_1/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span><span class="number">.0</span>.dylib:</span><br><span class="line">/usr/local/opt/opencv/lib/libopencv_core<span class="number">.3</span><span class="number">.4</span>.dylib (compatibility version <span class="number">3.4</span><span class="number">.0</span>, current version <span class="number">3.4</span><span class="number">.0</span>)</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libz<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1.2</span><span class="number">.5</span>)</span><br><span class="line">/System/Library/Frameworks/OpenCL.framework/Versions/A/OpenCL (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1.0</span><span class="number">.0</span>)</span><br><span class="line">/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">4.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，忽略系统自带的库之后其所依赖的库只有一个：/usr/local/opt/tbb/lib/libtbb.dylib。说明libtbb.dylib这个库同时被libopencv_core.3.4.dylib和libopencv_imgproc.3.4.0.dylib引用到。</p><p>查看libtbb.dylib库的依赖关系，在目录/usr/local/opt/tbb/lib/目录下可找到这个库。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/local/opt/tbb/lib/libtbb.dylib</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib:</span><br><span class="line">/usr/local/opt/tbb/lib/libtbb.dylib (compatibility version <span class="number">0.0</span><span class="number">.0</span>, current version <span class="number">0.0</span><span class="number">.0</span>)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">1226.10</span><span class="number">.1</span>)</span><br><span class="line">/usr/lib/libc++<span class="number">.1</span>.dylib (compatibility version <span class="number">1.0</span><span class="number">.0</span>, current version <span class="number">120.1</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以看到libtbb.dylib库所依赖的都是系统自带的库，所以库依赖关系遍历到此结束。如果当前库还依赖于其他非系统自带库，则需要继续查找下去。</p><p>弄清楚库之间的依赖关系之后，接下来将库配置到Xcode中。</p><h4 id="无沙盒"><a href="#无沙盒" class="headerlink" title="无沙盒"></a>无沙盒</h4><p>如果是无沙盒条件下使用OpenCV还是很简单的，因为使用brew命令安装OpenCV过程中所有依赖的库都已帮你配置好了，只需要配置好头文件和库文件即可，不需要关心库之间的依赖关系。</p><p>首先配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/include。</p><p>配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：/usr/local/Cellar/opencv/3.4.0_1/lib。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/1.png" alt="无沙盒配置头文件"></p><p>接着切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png" alt="无沙盒配置库文件"></p><p>对于 Lion 操作系统，需要在Xcode-&gt;Target-&gt;Build Settings中，将“C++ Language Dialect”设置成 C++11，将“C++ Standard Library”设置成libstdc++ ，如下图所示。个人感觉是由于Xcode默认设置的GNU++11、libc++与OpenCV库有一些兼容性问题，我在更改该设置前老是出现编译错误。后续版本在Montain Lion系统中解决了这个问题，因此不需要此操作。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/3.png" alt="无沙盒配置编译器"></p><p>注意，如果使用OpenCV库函数的源文件扩展名是.m的，你还需要改成.mm，这样编译器才知道该文件混合使用C++语言和Objective-C语言。</p><p>以上，无沙盒条件下配置完成。这种配置存在一个严重的缺陷，即如果想要编译后的软件在其他电脑上正常运行则必须确保其他电脑在同样系统目录下安装了OpenCV库，即OpenCV库头文件与链接库文件目录与编译电脑一致，显然这是不能接受的。常规的解决方法是将软件所依赖的库一并打包到软件中，具体配置过程可见于下文的有沙盒配置过程。</p><h4 id="有沙盒"><a href="#有沙盒" class="headerlink" title="有沙盒"></a>有沙盒</h4><p>有沙盒与无沙盒的区别出来签名之外，还有一个重要的区别就是访问权限。无沙盒条件下，软件和Xcode一样拥有当前用户下的最高权限，可以访问当前用户下的任何目录，这也是为什么在Xcode的配置项中可以直接使用当前用户的系统路径的原因。</p><p>一旦为添加沙盒条件后，软件所能访问的目录局限于自己的沙盒下，不再有访问当前用户系统目录的权限。此时，只有将软件所依赖的库一并打包到软件中，才能使软件正常运行。具体步骤如下所示。</p><p>首先，将软件所依赖的库文件和头文件拷贝到项目工程下的OpenCV目录中，分别存放于lib目录和include目录中：</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/4.png" alt="有沙盒配置拷贝库相关文件"></p><p>然后，配置OpenCV库头文件的查找路径，在Xcode-&gt;Target-&gt;Build Settings中找到“Header Search Paths”选项，新添加一项：$(PROJECT_DIR)/OpenCV/include。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/5.png" alt="有沙盒配置头文件"></p><p>接着，配置OpenCV库文件的查找路径：在Xcode-&gt;Target-&gt;Build Settings中找到“Lib Search Paths”，新添加一项：$(PROJECT_DIR)/OpenCV/lib。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/6.png" alt="有沙盒配置库文件"></p><p>其中PROJECT_DIR宏是Xcode自带的，表示xxx.xcodeproj文件所在的目录路径。</p><p>然后，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Link Binary With Libraries”中，将软件用到依赖的OpenCV链接库拖拽其中。笔者只用到了libopencv_imgproc.3.4.0.dylib库，因此只需要拖拽这一个库即可。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/2.png" alt="有沙盒配置关联库文件"></p><p>接着，切换到Xcode-&gt;Target-&gt;Build Phases的tab下，在“Copy Files”中，将libopencv_imgproc.3.4.0.dylib库及其所依赖的库拷贝到软件目录下的Frameworks中。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/7.png" alt="有沙盒配置关联库文件"></p><p>最后一步，使用install_name_tool命令修改依赖库之间、软件与依赖库的依赖关系。因为使用brew安装，库之间的依赖关系以及库本身的加载路径都是系统路径，在沙盒条件下是无效的。</p><p>切换到Xcode-&gt;Target-&gt;Build Phases的tab下，点击左上角的“+”，选择“New Run Script Phase”，新建一个“Run Script”项目，里面是一个shell脚本文件，在Xcode编译运行前执行。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/opencv/8.png" alt="有沙盒配置修改库依赖关系"></p><p>修改依赖关系的顺序很重要，如果依赖关系是：软件-&gt;dylibA-&gt;dylibB-&gt;dylibC，则修改依赖关系的顺序是：dylibC-&gt;dylibB-&gt;dylibA-&gt;软件。</p><p>笔者当前软件中的依赖关系是：软件-&gt;libopencv_imgproc.3.4.0.dylib-&gt;libopencv_core.3.4.0.dylib-&gt;libtbb.dylib。</p><p>由于libtbb.dylib库所依赖的都是系统自带库，因此不需要修改。</p><p>修改命令与参数简单介绍，详细使用方式可通过终端执行命令：man install_name_tool查看：<br>install_name_tool -change oldPath newPath lib(or executable file)</p><p><strong>1. 修改libopencv_core.3.4.0.dylib对libtbb.dylib的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/tbb/lib/libtbb.dylib"</span> <span class="string">"@loader_path/libtbb.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib"</span></span><br></pre></td></tr></tbody></table></figure><p>其中@loader_path是Xcode自带的宏，表示库加载路径，即libopencv_core.3.4.0.dylib的加载路径，因为libtbb.dylib与libopencv_core.3.4.0.dylib是在同一目录，因此@loader_path/libtbb.dylib表示告诉libopencv_core.3.4.0.dylib在自身所在目录中加载libtbb.dylib。</p><p>$TARGET_BUILD_DIR是Xcode自带的宏，表示Xcode编译目录，即编译后的软件存放的目录。PRODUCT_NAME宏也是Xcode自带的，表示软件名称。因为笔者项目中是先拷贝库文件到软件目录中，再修改依赖关系。因此libopencv_core.3.4.0.dylib库所在路径为：$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_core.3.4.0.dylib。</p><p>以下修改命令类似，不再赘述。</p><p><strong>2. 修改libopencv_imgproc.3.4.0.dylib对libtbb.dylib和libopencv_core.3.4.0.dylib的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/tbb/lib/libtbb.dylib"</span> <span class="string">"@loader_path/libtbb.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib"</span></span><br><span class="line"></span><br><span class="line">install_name_tool -change <span class="string">"@rpath/libopencv_core.3.4.dylib"</span> <span class="string">"@loader_path/libopencv_core.3.4.0.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/Frameworks/libopencv_imgproc.3.4.0.dylib"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.软件对libopencv_imgproc.3.4.0.dylib库的依赖关系</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change <span class="string">"/usr/local/opt/opencv/lib/libopencv_imgproc.3.4.dylib"</span> <span class="string">"@executable_path/../Frameworks/libopencv_imgproc.3.4.0.dylib"</span> <span class="string">"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME"</span></span><br></pre></td></tr></tbody></table></figure><p>值得注意的是，软件路径必须可执行文件的路径$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME，而不能是$TARGET_BUILD_DIR/$PRODUCT_NAME.app，因为xxx.app文件本质上的一个目录。</p><p><strong>注意：如果在软件编译后运行时crash，并提示类似ImageLoaderMachO的错误则很可能是因为从系统目录下拷贝过来的库文件没有写的权限。因为OpenCV使用的是brew命令安装，brew使用的是root权限，而Xcode只有当前目录下的最高权限，所以必须确保库文件在当前用户下有读写权限，可以使用chmod +rw /path/to/dylib添加读写权限</strong></p><p>以上，在有沙盒条件下的配置完成。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>笔者在刚开始配置过程中，由于自身知识储备不足的原因被折腾得够呛。现在看来整个配置过程其实不难，通过博客记录一遍思路和流程显得更为清晰，理解也更为深刻。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Objective-C 2.0读书笔记</title>
      <link href="/2017/10/07/Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/07/Effective%20Objective-C%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-熟悉Objective-C"><a href="#第1章-熟悉Objective-C" class="headerlink" title="第1章 熟悉Objective-C"></a>第1章 熟悉Objective-C</h3><h4 id="1-了解Objective-C语言的起源"><a href="#1-了解Objective-C语言的起源" class="headerlink" title="1: 了解Objective-C语言的起源"></a>1: 了解Objective-C语言的起源</h4><ul><li>Objective-C语言是由Smalltalk演化而来，后者是消息型语言的鼻祖。</li><li>消息机构的语言，不论是否多态，其运行时所执行的代码都由运行环境来决定；而使用函数调用的语言则由编译器决定，但调用函数是多态的，则是在运行时通过查询“虚方法表（virtual table）”决定具体执行函数。</li><li>如果只需要保存int、flot、double、char等非对象类型，通常使用CGRect这种结构体，因为结构体可以使用栈空间，而不用分配和释放堆空间，避免额外开销。</li></ul><h4 id="2-在类的头文件中尽量少引用其他头文件"><a href="#2-在类的头文件中尽量少引用其他头文件" class="headerlink" title="2: 在类的头文件中尽量少引用其他头文件"></a>2: 在类的头文件中尽量少引用其他头文件</h4><ul><li>除非确实有必要，否则不要引入头文件，尽量使用向前声明，这样不但可以缩短编译时间和降低类之间的耦合。</li><li>如果无法使用向前声明，比如要声明某个类遵循一项协议。尽量把所遵循的协议移至实现文件中的匿名分类。如果必须在头文件引入协议头文件，则把协议单独放在一个头文件中。</li></ul><h4 id="3-多用字面量语法，少用与之对等的方法"><a href="#3-多用字面量语法，少用与之对等的方法" class="headerlink" title="3: 多用字面量语法，少用与之对等的方法"></a>3: 多用字面量语法，少用与之对等的方法</h4><ul><li>使用字面量语法创建字符串、数值、数组、字典更为简单扼要。</li><li>使用取下标操作访问数组下标或者字典中的键对应的元素。</li><li>使用字面量语言更为安全，遇到nil对象会抛出异常。</li><li>字面量语法的限制：除了字符串以外，所创建出来的对象必须属于Foundation框架才行。</li></ul><h4 id="4-多用类型常量，少用-define预处理指令"><a href="#4-多用类型常量，少用-define预处理指令" class="headerlink" title="4: 多用类型常量，少用#define预处理指令"></a>4: 多用类型常量，少用#define预处理指令</h4><ul><li>若常量局限于某个实现文件之内，则前面加字面k，若常量在类之外，则通常以类名为前缀。</li><li>static修饰符意味着变量仅在定义此变量的编译单元中可见，在Objective-C的语境下，编译单元通常指每个类的实现文件，即以.m为后缀名。</li><li>常量必须使用const修饰符声明，常量定义从右至左解读，下面例子中定义了一个常量指针，const修饰的是指针，指向NSString对象。<figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ECOStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>如果一个变量同时声明为static和const,那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值。</li><li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中，因此通常与之相关的类名做前缀加以区分。</li></ul><h4 id="5：用枚举表示状态、选项、状态码"><a href="#5：用枚举表示状态、选项、状态码" class="headerlink" title="5：用枚举表示状态、选项、状态码"></a>5：用枚举表示状态、选项、状态码</h4><ul><li>C++11标准修订了枚举的某些特性，其中包括可以指定何种“底层数据类型”来保存枚举类型的变量。这样做的好处是可以向前声明枚举变量了，如果编译器不清楚底层数据类型就不知道分配空间大小。</li><li>如果枚举类型是多个选项且同时使用，那么久将各选项值定义为2的幂，以便按位或操作进行组合。</li><li>用NS_ENUM与NS_OPTION宏来定义枚举类型，并指明其底层数据类型，这样确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li><li>在处理枚举类型的switch语句中不要实现default分析，这样加入新的枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li></ul><h3 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h3><h4 id="第6条：-理解“属性”这一概念"><a href="#第6条：-理解“属性”这一概念" class="headerlink" title="第6条： 理解“属性”这一概念"></a>第6条： 理解“属性”这一概念</h4><ul><li>使用@property语法编译器会自动创建一套存取方法，因此访问属性实质上就是调用存取函数，走消息派发流程。</li><li>@synthesize语言可以指定属性实例变量的名字，默认的属性名前加下划线。</li><li>@dynamic关键字可以阻止属性创建实例变量和存取方式，编译器即使在编译过程中没有发现该属性的存取方法也不会保存，而是相信这些方法在运行期能够找到。</li><li>原子性只能确保每次都能获取属性的有效值，即确保属性修改完成再被其他线程访问，但是不能确保线程安全。</li><li>处于性能考虑，iOS程序所有属性都是nonatomic，Mac OS X程序使用atomic属性通常不会有性能瓶颈。</li><li>对应一个属性定义的变量来说，直接访问实例变量会绕开指定的属性特质和消息派发流程。</li></ul><h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul><li>使用“点语法”（本质上使用实例变量存取方法）与直接访问实例变量的区别：<ul><li>直接访问实例变量不经过Objective-C的消息派发流程，因此速度比点语法快。</li><li>直接访问实例变量不会调用属性配置的存取方法，从而绕过了属性指定的相关特质。</li><li>直接访问实例变量不会触发“键值观测KVO”通知，因为键值观测是建立在存取方法之上的。</li></ul></li><li>在初始化方法和dealloc中尽量直接访问实例变量，因为子类可能覆写父类属性的存取方法，从而无法输出预期。</li><li>在对象内部读取数据时，应该直接通过实例变量来读，除惰性初始化技术之外。而写入数据时则应通过属性来写。</li></ul><h4 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h4><ul><li>检测对象的等同性，必须提供“isEqual:”和hash方法。相等的对象hash值必须相同，但是has值相同的对象未必相等。</li><li>计算hash值时应考虑减少碰撞。因为collection检索哈希表时会用对象的哈希值作为索引。hash方法的高效与低碰撞率可以使collection减少开销。</li><li>等同性判定的执行深度根据具体的对象决定，不一定将整个对象进行判定，有时候只需要判定代表对象唯一性的值即可。</li><li>在容器中放入可变类对象时，确保对象加入后就不再改变哈希值，否则容易造成未知行为。</li></ul><h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul><li>类簇模式可以把实现细节隐藏在一套简单的公共接口后面。</li><li>系统框架中经常使用类簇，比如NSArray、NSNumber等。</li><li>从类簇的公共抽象基类中继承子类时，遵循几条规则：<ul><li>子类应该继承自类簇中的抽象基类。</li><li>子类应该定义自己的数据存储方式。</li><li>子类应当覆写超类文档中指明需要覆写的方法。</li></ul></li></ul><h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><ul><li>使用关联对象可以将两个对象以属性的方式关联起来，并指定类似于@property的内存管理语义和存储策略。</li><li>设置关联对象的键值是个“不透明指针”，若想令两个键值匹配到同一个值，二者必须是完全相同的指针才行。鉴于此，设置关联对象值时通常使用静态全局变量做键值。</li><li>由于关联对象容易引入难于排查的bug，所以不要轻易使用。</li></ul><h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><ul><li>objc_msgSend通过在运行期搜索接收者类的方法列表实现“动态绑定”，以选择子为key值搜索函数指针。</li><li>函数原型与objc_msgSend函数很像，在objc_msgSend函数内部搜索到选择子对应的函数并在函数最后return语句调用，利用“尾调用优化”进行优化。</li></ul><h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><ul><li>消息转发分两大阶段：动态方法解析和完整的消息转发机制（分两阶段）</li><li>动态方法解析：实例对象收到无法解析的消息会触发类方法：+（BOOL）resolveInstanceMethod:(SEL)selector，如果是类对象对应的类方法为：+（BOOL）resolveClassMethod:(SEL)selector。在这个方法中可以通过class_addMethod动态插入方法，所添加的方法是用纯C函数（IMP指针）。</li><li>完整的消息转发机制第一阶段：调用函数-(id)forwardingTargetForSelector:(SEL)selector，看是否能把消息转发其他对象处理。通过此方案可以用“组合”来模拟”多重继承“的某些特性。</li><li>完整的消息转发机制第二阶段：- (void)forwardInvocation:(NSInvocation *)invocation;此阶段可以在转发消息前修改消息内容。若本类不处理，则需调用父类同名方法。</li></ul><p>###第4章 协议与分类</p><h4 id="23：通过委托与数据源协议进行对象间通信"><a href="#23：通过委托与数据源协议进行对象间通信" class="headerlink" title="23：通过委托与数据源协议进行对象间通信"></a>23：通过委托与数据源协议进行对象间通信</h4><ul><li>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</li><li>当某对象需要从另外一个对象中获得数据时，可以使用委托模式【数据源协议】。</li><li>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</li></ul><h4 id="24：将类的实现代码分散到便于管理的数个分类之中"><a href="#24：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24：将类的实现代码分散到便于管理的数个分类之中"></a>24：将类的实现代码分散到便于管理的数个分类之中</h4><ul><li>使用分类机制将类的实现代码划分成易于管理的小块</li><li>将应该视为“私有”的方法归入名叫private的分类中，以隐藏实现细节。</li></ul><h4 id="25：总是为第三方类的分类名称加前缀"><a href="#25：总是为第三方类的分类名称加前缀" class="headerlink" title="25：总是为第三方类的分类名称加前缀"></a>25：总是为第三方类的分类名称加前缀</h4><ul><li>分类机制通常用于向无源代码的既有类中增加新功能，且分类中的方法会覆盖既有类的同名方法，后一个分类会覆盖前一个分类的同名方法。</li><li>为了减少同名函数覆盖的概率，以命名空间来区分各个分类的名称与其中所定义的方法，在Objective-C中实现命名空间的方法就是给分类名和函数名添加专用的前缀。</li></ul><h4 id="26：勿在分类中声明属性"><a href="#26：勿在分类中声明属性" class="headerlink" title="26：勿在分类中声明属性"></a>26：勿在分类中声明属性</h4><ul><li>属性是封装数据的方式，尽管可以通过关联对象的方式合成实例变量，但是建议最好全部在主接口中实现，分类的作用在于扩展类的功能，而非封装数据</li><li>除了“class-continuation分类【匿名分类】”之外可以定义属性，其他分类最好只定义方法</li></ul><h4 id="27：使用“class-continuation分类”隐藏实现细节"><a href="#27：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="27：使用“class-continuation分类”隐藏实现细节"></a>27：使用“class-continuation分类”隐藏实现细节</h4><ul><li>匿名分类可以定义方法和实例变量，原因在于“稳固的ABI”机制（详见第6条）</li><li>在实现块中添加匿名分类可隐藏实现细节，即私有变量和方法。</li><li>编译objective-C++时，在匿名分类中定义c++相关的变量，从而避免了因为在头文件中声明C++变量，进而导致凡是引用该类的其他类都必须改为Objective-C++类。</li><li>利用匿名分类扩展头文件中声明为“只读”的属性为“可读写”状态</li><li>利用匿名分类隐藏该类遵循的协议。</li></ul><h4 id="28：通过协议提供匿名对象"><a href="#28：通过协议提供匿名对象" class="headerlink" title="28：通过协议提供匿名对象"></a>28：通过协议提供匿名对象</h4><ul><li>使用协议可将具体的对象类型谈化成遵循某种协议的id类型，协议中规定了对象需实现的方法</li><li>如果对象类型不重要，重要的是对象是否实现了某些方法，此时可用“匿名对象”来实现这一概念，与Python的“鸭子类型”有点相似。</li></ul><p>###第5章 内存管理</p><h4 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h4><ul><li>悬挂指针：对象在release之后，内存被放回“可用内存池”，但是不一定保证马上被回收，此时指针属于悬挂指针，容易导致crash。</li><li>为了避免不经意间使用了悬挂指针，在调用完release之后清空指针</li><li>autorelease能延长对象生命周期，使其在跨越方法调用边界后依然跨越存活一段时间，释放操作会在清空最外层自动释放池时执行，即在当前线程进入下一次事件循环时释放。</li><li>通常采用“弱引用”来避免循环引用发生，从而避免内存泄漏</li></ul><h4 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h4><ul><li>Clang的静态分析器（static analyzer）不但可以指明程序中引用计数出现问题的地方，还能根据需要预先加入适当的retain和release操作以避免这些问题。自动引用计（ARC）数的思路也是源于此。</li><li>ARC在执行retain、release和autorelease等操作时，不是通过普通的Objective-C消息派送机制，而是直接调用其对应的C语言版本，这样效率更高。</li><li>ARC通过命名约定将内存管理标准化，方法名以下列词语开头，其返回的对象归调用者所有：<ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy<br>否则，返回对象会自动释放，即相当于执行autorelease操作.</li></ul></li><li>在编译期和运行期，ARC都把能够相互抵消的retain、release、autorelease操作约简。</li><li>运行期，为了优化代码，在方法返回自动释放的对象时，调用objc_autoreleaseReturnValue,此函数会检视当前函数调用的代码是否需要对返回对象执行retain操作，如果是则设置一个全局标志位。而不执行autorelease操作；与只对应的是在调用代码如果要保留对象，则不执行retain操作，而是调用objc_retainAutoreleasedRetuenValue.此函数检测之前设置的全局标志位，如果已经置位，则不执行retain操作。</li><li>ARC环境优化方式具体实现由编译器决定，比如将全局标志位存储在STL(Thread Local Storage:线程局部存储，以key-value的形式读写)中，STL只适用于调用和被调用方都是ARC模式的情况，使用__builtin_return_address可以在被调用函数中获得调用函数的栈空间，进而可以推算出调用方后续操作是否调用了objc_retainAutoreleasedReturnValue，如果调用则是ARC环境，反之使用没优化的老逻辑。</li><li>变量的内存管理的边界问题，在设置变量值时，需要先保留新值，释放旧值，最后设置实例变量，确保即便是新值与旧值是同一对象也不能引发错误。在ARC情况下，无需考虑这种“边界情况”</li><li>ARC下清理实例变量是借用Objective-C++的析构函数实现的，不需要重载dealloc，如果存在CoreFoundation等非Objective-C对象时，只需在dealloc函数中执行CFRetain/CFRelease等释放操作，而不需要调用超类的dealloc方法。</li></ul><h4 id="第31条：合理使用dealloc方法"><a href="#第31条：合理使用dealloc方法" class="headerlink" title="第31条：合理使用dealloc方法"></a>第31条：合理使用dealloc方法</h4><ul><li>在dealloc中只释放对其他对象的引用，解除监听和取消订阅的KVO等，不要做其他事情</li><li>不要在dealloc中释放开销大或系统内稀缺资源，如文件描述符、套接字以及大块内存等，因为这些资源可能被其他对象持有，不宜保留过长时间，而是实现一个专门用于清理的函数，如close等</li><li>出于优化效率的目的，系统不能保证每一个对象的dealloc都会执行</li><li>不应在dealloc中调用执行异步任务的方法或只能在正常状态下执行的方法，因为dealloc所在的线程会执行final release。</li></ul><h4 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h4><ul><li>MRC环境下，在@try中创建的对象应在@finaly中释放而非@try中，以避免因抛出异常导致内存泄漏</li><li>ARC环境下，出于对运行期的性能考虑默认情况下是不会处理异常捕获过程中出现的内存泄漏情况。</li><li>ARC环境下，可以通过-fobjc-arc-exceptions这个编译标志开启安全处理异常功能，默认情况是关闭的，但是出于Objectve-C++模式下会自动打开。</li></ul><h4 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h4><ul><li>虽然垃圾回收机制可以检测并回收保留环，但是Mac OS X 10.8之后以及iOS平台不支持这个功能</li><li>MRC环境下，使用unsafe_unretained（表明属性不安全且不归实例所拥有）或者weak属性来避免保留环，且效果等同</li><li>ARC环境下，weak属性在修饰对象被回收后自动清空，更为安全，避免访问悬挂指针。</li></ul><h4 id="第34条：以“自动释放池块”降低内存峰值"><a href="#第34条：以“自动释放池块”降低内存峰值" class="headerlink" title="第34条：以“自动释放池块”降低内存峰值"></a>第34条：以“自动释放池块”降低内存峰值</h4><ul><li>GCD或主线程都默认自带自动释放池。</li><li>自动释放池是以栈的形式存在的，对象收到autorelease消息后，会被放入最近的自动释放池的栈顶。</li><li>合理运用自动释放池，用以降低应用程序的内存峰值，如for循环中。</li><li>ARC环境下的@autoreleasepool比MRC环境下NSAutoreleasepool更为轻便与安全。</li></ul><h4 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h4><ul><li>向已回收的对象发送消息是不安全与不稳当的，如果内存已经被复用且复用的对象不能响应此消息则会crash，如果复用对象能够响应消息也许输出不能达到预期，如果内存部分存活则可能消息可能依然有效。</li><li>“僵尸对象”是调试内存管理问题最佳方式。</li><li>僵尸类是从名为_NSZombie_的模板类复制而来，通过创建一个名为_NSZombie_原类名的新类，再将已回收对象的指针指向新类，原对象的类变了，但是内存结构不变，便于调试。示例代码：</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line"><span class="keyword">if</span> (!zombieCls) {</span><br><span class="line"><span class="keyword">class</span> baseZomeCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</span><br><span class="line">zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Perform normal destruction of the object being deallocated</span></span><br><span class="line">objc_destructInstance(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//Set the class of the object being deallocated to the zombie class</span></span><br><span class="line">objc_setClass(<span class="keyword">self</span>, zombieCls);</span><br></pre></td></tr></tbody></table></figure><p>代码的关键在于：对象的内存没有释放，因此这块内存不可被其他对象复用，虽然会造成内存泄漏，但是出于调试的目的可以忽略。</p><ul><li>僵尸类的作用是通过消息转发机制体现，因为僵尸类没有实现任何方法，和Object一样是根类，只有一个实例变量isa。在消息转发机制通过类名检测到当前对象是一个僵尸对象时会进行特殊处理：打印原类的相关信息，然后终止程序。示例代码：</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"><span class="comment">//If so, this is a zombie</span></span><br><span class="line"><span class="keyword">if</span> (string_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) {</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd));</span><br><span class="line"></span><br><span class="line">Log(<span class="string">"*** - [%s %s]: message sent to deallocated instance %p"</span> , originalClsName, selectorName, <span class="keyword">self</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h4><ul><li>retainCount返回的保留计数只是某个给定时间点上的值，并未考虑到对象加入自动释放池的情况，因此不能反映真实的保留计数。</li><li>有时系统出于优化的目的，retainCount可能永远都不返还0，在保留计数为1的时候就被回收了。</li></ul><p>###第6章 块与大中枢派发</p><p>####第37条 理解“块”这一概念</p><ul><li>块在定义与使用方面与函数类似，但是块本身是一个对象，有引用计数。</li><li>在块中直接访问实例变量，虽没有显性使用self，但是self变量还是会被块捕获。</li><li>块的内存结构中，最重要的是invoke函数指针，指向块的实现代码，第一个void *参数指代块，用于访问块对象所捕获的变量。此外descriptor变量指向结构体指针，每个块里都包含此结构体，其中声明了块对象的总大小和copy与dispose两个辅助函数的指针。</li><li>根据内存位置分为全局块、栈块和堆块。</li><li>栈块只在定义氛围有效，下述代码存在一个比较隐蔽的错误，存在危险：块的内存都分配在if及else范围内，在离开相应范围后如果编译器覆写了分配给块的内存则会导致crash，否则正常运行。</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); };</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">block = ^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); };</span><br><span class="line">}</span><br><span class="line"><span class="comment">//解决方式：将块拷贝到堆中，成为堆块</span></span><br><span class="line"><span class="keyword">void</span> (^block)();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* some condition */</span>) {</span><br><span class="line">block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block A"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}<span class="keyword">else</span> { </span><br><span class="line">block = [^{ <span class="built_in">NSLog</span>(<span class="string">@"I am block B"</span>); } <span class="keyword">copy</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>在全局范围声明的块及为全局块，其所使用的内存区域也在编译器全部确定。</li></ol><h4 id="第38条-为常用的块类型创建typedef"><a href="#第38条-为常用的块类型创建typedef" class="headerlink" title="第38条 为常用的块类型创建typedef"></a>第38条 为常用的块类型创建typedef</h4><ul><li>以typedef重新定义块类型，可令块变量用起来更简单</li><li>定义新类型时应遵循现有的命名习惯，勿使其名称与别的类型相冲突。</li><li>可以为同一个块签名定义多个类型的别名，便于理解类型的用途。</li></ul><h4 id="第39条-用handler块降低代码分散程度"><a href="#第39条-用handler块降低代码分散程度" class="headerlink" title="第39条 用handler块降低代码分散程度"></a>第39条 用handler块降低代码分散程度</h4><ul><li>异步任务执行完成之后，可使用委托协议或者内联块。相比于委托代理，块更为简洁和聚合。</li><li>建议使用同一个块来处理成功与失败的情况。</li><li>设计API时如果用的了handler块，可以增加一个参数，使调用者可通过此参数来决定块执行的队列。</li></ul><h4 id="第40条-用块引用其所属对象时不要出现保留环"><a href="#第40条-用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条 用块引用其所属对象时不要出现保留环"></a>第40条 用块引用其所属对象时不要出现保留环</h4><ul><li>如果块所捕获的对象直接或者间接地保留了块本身，那么得注意是否存在保留环的问题。</li><li>一定要找个适当的时机解除保留环，而不能把责任推给API调用者。</li><li>网络下载器可在任务启动时将自己加入全局的容器对象中，在任务结束后移除，从而保证自己在任务执行期间存活的同时不需要API调用方引用，大部分网络通信库都是采用这办法，如Twitter框架的TWRequest对象。</li></ul><h4 id="第41条-多用派发队列，少用同步锁"><a href="#第41条-多用派发队列，少用同步锁" class="headerlink" title="第41条 多用派发队列，少用同步锁"></a>第41条 多用派发队列，少用同步锁</h4><ul><li>同步块@synchronized(obj)会根据给定对象自动创建一个锁，锁在代码块执行完成释放。由于给定对象相同，那么意味着它们使用的同一个锁，代码块需按顺序执行。如果在两个或多个没有逻辑关联的代码块给同一个对象加锁，会影响执行效率。</li><li>滥用@synchronized(self)很危险，因为所有同步块都会彼此抢夺同一个锁。示例：使用@synchronized实现属性的原子性（atomic）：</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line"><span class="keyword">return</span> _someString;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line">_someString = someString;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果有很多属性都是类似写法，那么每个属性的同步块都要等其他同步块执行完成才能执行。理想情况应该是属性各自独立地同步。</p><ul><li>使用GCD实现属性原子性：</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">localSomeString = _someString;</span><br><span class="line">});</span><br><span class="line"><span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//同步队列+同步派发</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line"><span class="built_in">dispatch_sync</span>(_syncQueue, ^{  </span><br><span class="line">_someString = someString;</span><br><span class="line">});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><ul><li>GCD版本优化：设置方法不需要返回值，所以并不一定非得同步；获取方法可以并发执行，且设置方法与获取方法之间不能并执行。</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//异步队列+同步派发</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString {</span><br><span class="line">__block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(_syncQueue, ^{</span><br><span class="line">localSomeString = _someString;</span><br><span class="line">});</span><br><span class="line"><span class="keyword">return</span> localSomeString;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//异步队列+异步派发（同步派发可能效率更高，原因在于异步派发需要拷贝块，如果拷贝时间超过代码执行时间，则得不偿失。异步派发适合较为复杂的任务）+栅栏块</span></span><br><span class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString {</span><br><span class="line"><span class="comment">//栅栏块会单独执行，执行前会等待当前所有并发块执行完成，避免出现读写竞赛</span></span><br><span class="line">dispatch_barrier_async(_syncQueue, ^{  </span><br><span class="line">_someString = someString;</span><br><span class="line">});</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="第42条-多用GCD，少用performSelector系列方法"><a href="#第42条-多用GCD，少用performSelector系列方法" class="headerlink" title="第42条 多用GCD，少用performSelector系列方法"></a>第42条 多用GCD，少用performSelector系列方法</h4><ul><li>performSelector系列方法在内存管理方面容易有疏忽，由于无法确认将要执行的选择子是什么，因而ARC编译器无法插入适当的内存管理方法。</li><li>performSelector系列方法所能处理的选择子有局限性，选择子的参数个数与类型以及返回类型都受到限制。</li></ul><h4 id="第43条-掌握GCD及操作队列的使用时机"><a href="#第43条-掌握GCD及操作队列的使用时机" class="headerlink" title="第43条 掌握GCD及操作队列的使用时机"></a>第43条 掌握GCD及操作队列的使用时机</h4><ul><li>对于只需要执行一次的代码来说，GCD的dispatch_once是首选，但是执行后台任务则可以考虑NSOperationQueue。</li><li>在iOS4与Mac OSX 10.6开始，操作队列在底层是用GCD来实现的。</li><li>GCD是纯C的API，任务使用轻量级数据结构块来表示；操作队列则是Objective-C的对象，采用更为重量级的NSOperation对象执行任务。</li><li>使用操作队列的优势：<ul><li>可取消还未启动的任务</li><li>可指定操作间的依赖关系</li><li>可通过键值观测机制监控NSOperation对象的属性</li><li>可指定操作的优先级，而GCD只能指定队列的优先级</li><li>可重用NSOperation对象</li></ul></li><li>是否使用底层实现方案还是高层API，可通过实际性能测试来确定。</li></ul><h4 id="第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第44条-通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条 通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第44条 通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul><li>一系列的任务可归入一个dispatch group中，开发者可以在所有任务完成后获得通知</li><li>利用dispatch group并发地执行多项任务。</li><li>dispatch_apply是持续阻塞的，直到所有任务都执行完成。</li></ul><h4 id="第45条-使用dispatch-once来执行只需要运行一次的线程安全代码"><a href="#第45条-使用dispatch-once来执行只需要运行一次的线程安全代码" class="headerlink" title="第45条 使用dispatch_once来执行只需要运行一次的线程安全代码"></a>第45条 使用dispatch_once来执行只需要运行一次的线程安全代码</h4><ul><li>dispatch_once采用“原子访问”来判断块中的代码是否已经执行过，而非使用重量级的同步机制，相比于@sychronized更为高效，如果想了解@synchronized的实现机制可以看看<a href="http://icebergcwp.com/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.html">这篇博客</a>。</li><li>标记dispatch_once_t应该声明为static，确保每次调用都复用同一个变量。</li></ul><h4 id="第46条-不要使用dispatch-get-current-queue"><a href="#第46条-不要使用dispatch-get-current-queue" class="headerlink" title="第46条 不要使用dispatch_get_current_queue"></a>第46条 不要使用dispatch_get_current_queue</h4><ul><li>dispatch_get_current_queue已被废弃，只应做调试使用</li><li>派发队列是按层级来组织的，子队列是包含于父队列的，所以无法单用某个队列对象来描述“当前队列”这一概念</li><li>dispatch_get_current_queue用于解决由不可重入代码所引发的死锁，可以使用“队列特定数据”来解决：dispatch_queue_set_specific(dispatch_queue_t queue,const void *key, void *context, dispatch_function_t destructor);</li></ul><h3 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h3><ul><li>标准根类NSObject属于Foundation框架，而非语言本身。如果不适应Foundation框架，则需要自己实现根类</li></ul><h4 id="第47条-熟悉系统框架"><a href="#第47条-熟悉系统框架" class="headerlink" title="第47条 熟悉系统框架"></a>第47条 熟悉系统框架</h4><ul><li>在众多框架中，Foundation和CoreFoundation这两个框架最为重要，提供了许多核心功能</li><li>Objective-C编程经常会使用纯C实现的框架，比如CoreFoundation，里面用到底层C语言级API，这样可以绕过运行时系统，提升速度，但是需要手动管理内存。</li></ul><h4 id="第48条-多用块枚举，少用for循环"><a href="#第48条-多用块枚举，少用for循环" class="headerlink" title="第48条 多用块枚举，少用for循环"></a>第48条 多用块枚举，少用for循环</h4><ul><li>遍历collection有四种方式。最基础的是for循环，其次是NSEnumerator遍历和NSFastEnumeration协议下的快速遍历，最快、最先进的方式是“块枚举发”</li><li>“块枚举法”本身能够通过GCD来并发执行遍历，无须另行代码，其他遍历方式则不能做到这一点</li><li>如果提前知道遍历collection中的对象，应修改块签名，指出对象的具体对象。</li></ul><h4 id="第49条-对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条 对自定义其内存管理语义的collection使用无缝桥接"></a>第49条 对自定义其内存管理语义的collection使用无缝桥接</h4><ul><li>Foundation框架中的collection类都有与之对应的CoreFoundation框架版的C语言API</li><li>桥接符号__bridge表示ARC保留对Objective对象的所有权，而__bridge__retain则刚好相反，需要使用CFRelease释放内存。</li><li>使用CoreFoundation框架可以创建出Foundation框架所不具备的功能，比如NSDictionary的键值内存管理语义是“copy”，即键值必须支持Copying协议，使用CoreFoundaition创建一个键值内存管理语义为“Retain”的CFDictionary。</li></ul><h4 id="第50条-构建缓存时选用NSCache而非NSDictionary"><a href="#第50条-构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第50条 构建缓存时选用NSCache而非NSDictionary"></a>第50条 构建缓存时选用NSCache而非NSDictionary</h4><ul><li>实现缓存时应选NSCache而非NSDictionary对象。NSCache提供了优雅的自动删减功能，而且线程安全。此外，它与字典不同，不会拷贝键值，而是retain一次。</li><li>可以给Cache对象设置上限：缓存对象总个数和缓存总大小，这些设置定义了缓存删减其中对象的时机。但是这些设置仅对Cache起指导作用，并非一定在系统资源紧张时删减Cache中的某个对象，因此不能通过设置上限来迫使Cache优先删减某个对象。</li><li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据功能，也就是说当NSPurgeableData对象所占内存被系统丢弃时，对象也会从缓存中移除。</li><li>缓存的设计初衷是为了提高响应速度，只有那些“重新计算起来费劲”的数据才值得放入缓存，比如网络获取或者磁盘读取的数据。</li></ul><h4 id="第51条-精简-initialize与-load的实现代码"><a href="#第51条-精简-initialize与-load的实现代码" class="headerlink" title="第51条 精简+initialize与+load的实现代码"></a>第51条 精简+initialize与+load的实现代码</h4><ul><li>在加载过程中，如果类实现了+load方法，那么系统会通过函数指针调用+load。调用顺序是父类-&gt;子类-&gt;分类。因为程序加载时是使用函数指针调用而非消息机制，所以分类中的+load不会覆盖子类中的+load方法。         </li><li>程序启动时，运行期处于“脆弱状态（fragile state）”，如果+load方法中使用了其他非系统库（系统库的类在这之前已经加载好了）的类，那么这些类的+load方法也在此时被调用。如果子类没有实现+load方法，那么各级超类是否实现此方法都不被系统调用。</li><li>+load方法务必实现的精简一些，因为整个程序在+load方法时都会阻塞。其真正的用途在于调试程序。</li><li>+initialize方法会在程序首次调用该类之前调用，只调用一次，如果某个类未被使用，那么其+initialize方法一直不会被调用。</li><li>+initialize方法被调用时，运行期系统已经处于正常状态，理论上可以在其中调用任何类的任意公开方法，且是线程安全的。</li><li>+initialize方法与其他消息一样，如果子类未实现它而其超类实现了，那么会子类也会调用一次超类的实现方法。 </li><li>无法再编译器设定的全局变量，可以放在+initilize方法中初始化。</li></ul><h4 id="第52条-别忘了NSTimer会保留其目标对象"><a href="#第52条-别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条 别忘了NSTimer会保留其目标对象"></a>第52条 别忘了NSTimer会保留其目标对象</h4><ul><li>NSTimer对象会保留其目标，知道计时器调用invalidate方法后失效为止。另外，一次性的计数器在触发任务后就会立即失效。</li><li>反复执行任务的计时器，很容易引入保留环，可通过扩充NSTimer功能，用块来打破保留环。代码如下：</li></ul><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats;</span><br><span class="line">+ </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">ECOBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimerInterval</span>)interval  block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats {</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimerInterval:interval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(eoc_blockInvoke:) userInfo:[block <span class="keyword">copy</span>] repeats:repeats];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eco_blockInvoke:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line"><span class="keyword">void</span>(^block)() = timer.userInfo;</span><br><span class="line"><span class="keyword">if</span> (block) {</span><br><span class="line">block();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```                    </span><br><span class="line">这个方法仍然存在保留环，计时器现在的target是<span class="built_in">NSTimer</span>类对象，但是因为类对象无需回收，所以不用担心。</span><br><span class="line"></span><br><span class="line">* 上述方法本身不能解决问题，但是提供了解决问题的工具。使用分类中的eoc_scheduledTimerWithTimeInterval来创建计时器：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">void</span>)startPolling {</span><br><span class="line">__<span class="keyword">weak</span> type(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">_pollTimer = [<span class="built_in">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class="number">1.0</span> block:^{ </span><br><span class="line">EOCClass *strongSelf = weakSelf;</span><br><span class="line">[strongSelf p_doPoll]; </span><br><span class="line">} repeats:<span class="literal">YES</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人类简史》第一部分认知革命读书笔记</title>
      <link href="/2017/08/03/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/03/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="人类：只是一种普通的动物"><a href="#人类：只是一种普通的动物" class="headerlink" title="人类：只是一种普通的动物"></a>人类：只是一种普通的动物</h4><p>一直以来，我和很多人一样以为地球同一时期只有一种人类且是独特于其他的物种之外的特殊物种，不然怎么会站在了食物链的顶端。现在我才知道这种想法是错误的，其实我们现代人即智人（human sepiens）只是人属的一种，就像豹属包括狮子，豹子等。人属也包括多个物种，只是现存的人种只有智人，就容易让人造成智人是唯一人种的假象。</p><p>早在250万年前人类开始由猿属中的南方古猿开始演化，人类的足迹在200万年前开始从东非欧亚大陆扩散，结合当地的环境各自演化出不同的人种，有匠人、鲁道夫人、尼安德特人、直立人、梭罗人等等。这些人分别先后出现，并在某一段时间同时存在地球的不同地方。其中，直立人出现时间是200万年前到5万年前，存活了将近200万年，是目前所知存续时间最长的人类物种，目前地球上唯一的人种智人已知的是大约15万年前在非洲出现，具体何时、有何种早期人类演化而来无从得知，就目前的发展来看是很难打破直立人存续的记录了。此外，这些人种的演化并不是呈线性发展的，这些人种在大约200万年前到大约一万年前之间同时存在世界各地，各种进化或灭亡，直到一万年前左右，仅剩下智人一种人类。</p><p>人类比其他物种有一个共同特征就是脑容量大。然而庞大的大脑也是庞大的负担，大脑不仅结构脆弱且消耗能量巨大，占身体体重约2%~3%却消耗能量占25%。时至今日，大脑发达带来的好处显而易见，但是远古人类为此付出一定的代价，主要包括两种：一是人类需要更多的食物满足热量需求，其次就是为了保证大脑能量供需导致肌肉退化萎缩。至于为什么人类大脑会在200万年间不断演化，无从得知。</p><p>人类另外一个共同特征就是直立行走，直立行走将手从移动的功能中分离出来，着重神经发展，进一步演化成可以处理精细任务。与此同时，直立行走也有不利之处。直立行走意味着脊椎需要支撑一个超大的头盖骨，为此需要面对背痛与颈椎脖子疾病。特别对妇女造成的负担更大，直立行走需要让臀部变窄，然而根据人类演化趋势，婴儿的头越来越大，从而导致分娩风险增高。于是，根据自然选择的原理，在婴儿还尚未完全发育之前分娩，这时候头部毕竟小且柔软，风险也会降低很多。所以，相对于其他物种，人类都是早产儿，许多重要的器官都未发育完善，出生之后需要母亲的悉心呵护与培养。这也是导致人类发展出突出的社交技巧的原因之一。正因为小孩出生后需要长时间的抚养，作为母亲必须依赖于家族部落的协助才能获得足够的食物，为此需要一种能够形成强大的社会关系的能力。此外，人类出生后的发育不完善也意味着更好的可塑性，需要外界的教育，这也依托于强大的社会化的背景。正因如此，人类的性格、信仰和价值观等观念才会各种各异，才有基督徒或佛教徒，自由主义者或民族主义者，好战派或和平派。</p><p>尽管人类拥有超强的大脑，但是在过去的200万年前，人类一直都是一种弱小、边缘化的物种。直到10万年前，智人这一人类物种崛起，一跃而居于食物链的顶端才结束弱者的命运。然而，这次仓促的跳跃对整个生物链造成了巨大的影响。在此之前其他处于食物链顶端的物种都是经过好几百万年的进化才站上了顶峰，因此生态系统有足够的时间协调各物种之间的平衡。相比之下，智人在很短的时间内一步青云，让生态系统猝不及防，人类本身也不知所措，为此付出的代价就是人类史上众多的灾难。</p><p>在人类踏上食物链顶端的路上，火的使用功不可没。早在80万年前部分人类偶然的机会学会使用火，到了30万年前直立人、尼安德特人以及智人的祖先已经能够熟练的使用火。火之于人类有两大主要好处：一是烹饪食物，烹饪食物不仅扩大了食物来源，使原本不可直接使用的食物，比如小麦、马铃薯等食物再烹饪供人类使用。此外烹饪让食物发生化学反应，同时对食物进行高温消毒，大大地减少了人类咀嚼与消化食物的时间。这样不仅让人类的牙齿缩小，肠道缩短，还能提供更多的热量供大脑发育。第二个好处是火可以成为御敌的工具，不同于其他动物经过数百万年进化而来的利爪或翅膀，这些功能都无法突破先天的身体限制，而火是一种可操作且力量无穷的工具，为人类更好的存续提供了保障。</p><p>在200万年前<del>1万年前，地球上的还存在多个人类物种，但是随着智人的出现以及扩散，其他物种先后走上了灭绝的道路。每当智人到达某个地方，当地原本的人种就在不久之后消失了。究其原因，有两种大相径庭的理论。一是“混种繁衍理论”，即智人与其他人种混种繁衍，最终形成了现代的人类。另外一种则是“替代理论”，即不同物种之间处于争夺资源与排外的情绪，互相厮杀，最终智人取得了胜利，替代了原有人类。最近数十年，替代理论一直是大致共识，不仅因为有考古证据支持，政治上也更为正确。如果非洲人、欧洲人和亚洲人是智人与不同人类物种的混种后代，那么基因上的差异也会很大，那么在政治、民族等多个方面的理解也会存在差异，从而导致种族间的大冲突，然而现实情况并非如此。然而，混种繁衍理论也并非没有可能。最近的一些研究发现中东和欧洲人有%1</del>%4尼安德特人的基因，澳大利亚原住民和现代美拉尼西亚人有6%的丹尼索瓦人的基因。如果这些发现属实，则说明混种繁衍理论至少是部分正确，有可能在某个时间点，不同人种还属于同一人种的不同族群，即使族群差异到了一定程度，但是仍然可以交配产下后代，再经过进一步演化才彻底切断彼此连接，形成两种不同的物种，也就不能再混种繁衍了。也许在物种分化的某个灰色地带，尼安德特人与智人在即将演化成两个不同的物种之前发生了混种繁衍，并产生了新的人类，导致智人的基因中残存着尼安德特人的DNA。</p><p>按照自然选择的规律来说，尼安德特人比智人进化的更完善，有更大的大脑和更发达的肌肉。但是结果却是智人存活了下来，而尼安德特人在地球消失了。智人最终成为最后的人类，战胜了其他人类物种的真实原因不得而知，但是有一个很有说服力的解答，那就是：智人有独特的语言。</p><h4 id="知善恶树"><a href="#知善恶树" class="headerlink" title="知善恶树"></a>知善恶树</h4><p>在距今7万~3万年前，智人发生了认知革命，具体原因不得而知，普遍认为是某次基因突变，改变智人大脑内部连接方式，从而改变了智人的思维方式与沟通语言能力。智人的语言并不是世界上第一种语言，每种动物都有其交流的语言，并且有其精密复杂的结构。然而，智人的语言较于其他动物的语言，它更为灵活，通过有限的词汇排列组合，可以产生无限多的句子和含义，从而大幅度提高了交流的效率。另外智人的语言有“八卦”和“虚构”的功能。</p><p>智人可以通过“八卦”功能让部落规模变得更大。在一般的动物族群里，成员数量一般在20~50左右。族群的团结依赖于首领的管理与威望。一旦族群扩大，族群内部就会发生动摇，最后造成分列。即便如此，八卦维系的规模也是有限制。社会研究学家指出，借由八卦维持的最大“自然”团体一般是150人。原因在于超过这个数之后，团体之间就不能深入了解和八卦彼此的生活情况。然而，事实是智人突破了这个界限，创造出了城市、国家等这些有成千上万成员的团体。其原因很可能在于智人的语言的“虚构”功能，能够虚构一些现实中不存在的事物，“虚构”这一功能不仅可以让智人拥有想象，更重要的意义在于可以让大家一起想象，共同相信某个虚构的事物，从而可以共同合作。现实生活中，很多的概念都是虚构的，包括国家，民族，宗教，金钱，法律，人权，正义等等。只是我们现代人从出生就接触这些概念，根本没怀疑它们的真实性，更不会发觉它们只是存在我们共同的想象之中。</p><p>在没有发生认知革命之前，智人和其他具有社会行为的动物一样，行为有相当的程度是有基因决定的。因此，一旦出现社会结构改变、发明新科技或者移居都是因为基因突变或者环境改变导致的。正因如此，远古人类没有什么革命性的改变。然而，智人出现认知革命之后，可以基于某个虚构的故事让大批互不相识的人有效的进行合作，而且只要改变虚构故事的内容，合作的方式也随之改变。这意味着智人找到了一条绕开基于组的快车道，可以迅速改变社会结构和发展速度。</p><p>认知革命通过虚构故事创造了很多想象现实，也发展处许多的行为模式，这成为我们所谓的“文化”的主要成分。文化出现之后，无法停止地继续改变和发展，就成了我们所谓的“历史”。认知革命正是历史从生物学中脱离而独立存在的起点。在此之前，所有人类的行为属于生物学的范畴，因为都是有基因主导的。换言之，智人生存在一个双重现实的社会中，一方面是客观存在的现实，即生物的范畴，另外一方面的虚构的现实，即历史和文化的范畴。生物学与历史的关系可以简化为三点：<br>1、基本上，生物学为智人的行为和能力设下了基本限制，设定了一个活动范围，所有的历史都在这个范围之内发生。</p><p>2、然而，这个范围非常大，能让智人有各种惊人的发挥空间，让虚构故事的能力和虚构的故事不断发展精进。</p><p>3、想了解智人的行为，就必须描述人类行为的历史演化，而不能只考虑人类在生物上的限制。</p><p>智人通过认知革命发展出独特的语言，无异于获得了《圣经》里面那个知善恶树的果实，从此改变了智人的命运，智人摇身一变成为了亚丹和夏娃。</p><h4 id="亚丹和夏娃一天"><a href="#亚丹和夏娃一天" class="headerlink" title="亚丹和夏娃一天"></a>亚丹和夏娃一天</h4><p>在智人的历史上，绝大多数时间都是靠采集为生。相比于几万年时长的采集生活，智人已知或者现存的生活方式不足以改变人类的思维方式。换言之，现代人类早在农业时代之前的采集时代就开始塑形，我们的大脑和内心的思维方式仍停留在以狩猎和采集的时代。农业革命之后，人类大脑的进化速度远不及周围生活环境的发展速度，造成了一种物质世界与内心世界脱轨的普遍现象。</p><p>这种现象影响这现代人生活的方方面面，狩猎采集时代的思维方式深植于我们的潜意识中。其中包括是已经得到广泛接受的“贪吃基因”理论和颇具争议的“一夫一妻制”。远古人类在那个甜食匮乏的时代为了获得更多的热量会偏爱高热量的甜食，导致物质丰富的现代人不知觉地喜爱甜食，造成肥胖等疾病。</p><p>因此，想要更好地了解我们自己、我们的社会和政治，就需要更了解我们祖先的生活条件。然而，我们对于采集者祖先的生活几乎没有可以确定的事实。目前普遍的研究方法有两种，一是考古学研究，通过远古社会遗存的文物进行推断。然而远古的狩猎采集生活用具保存下来的大都是骨骼化石和石器，其他容易腐烂的材料都无从考证，另外远古人类没有固定的生活居住地，而是不断的迁移，所以很少使用人造物品。因此，通过现存文物来还原远古人类的生活必定会有偏差；另外一种研究方式是人类学观察，通过研究现存的采集社会来推测远古采集社会的样貌。首先，现存采集社会多少已经受到周围的农业或者工业社会影响，不可同日而语。其次，现存的采集社会之所以能够存活到现在，是因为它们都位于气候恶劣或者地形险峻的地区，从而逃避了农业与工业社会的侵蚀，这与远古富饶地区的采集社会不论在人口规模和生活方式上都存在差异。再者，狩猎采集社会最显著的特点就是它们彼此之间的差异很大，各有特色。因此，通过人类学方式观察现存的采集社会只能帮助我们了解部分远古采集社会的可能性，而非全貌。</p><p>根据现有的证据，我们对远古采集社会虽然只有管中窥豹的认识，但是也能获得一些可靠的推断。首先，他们大部分人都是生活在小部落里面，且所以成员都是人类，而不同于农工社会中，存在家禽家畜的数量超过人类的社会群体。远古采集社会没有家禽家畜，但是有狗的存在，狗是第一种由智人驯化的动物，狗与人类的感情远超过人类与其他动物之间的感情。此外，同属一个部落的成员彼此熟悉，终其一生都生活在一起，没有孤单和隐私。不同的智人部落之间偶尔会有交流与交换物品，大多数时间都是互相独立，各行其是。大多数智人部落都是处于不断迁移的状态，只有很少的部落在食物富饶的地区会选择永久定居。远古智人部落与农业革命以后的人类的生活方式的差异主要有以下几点：<br>1、远古智人有着多样化的饮食结构，不依赖单一的某种食物，饮食结构更灵活，相比之下我们的饮食显得单一固定，容易受自然灾害影响；<br>2、整体而言，现代人类的知识范围远超远古人类，但是个人层面，远古智人是有史以来具备最多知识与生存技能的人类；<br>3、狩猎采集的生活方式更为轻松与舒适，不像现代人那样忙碌；<br>4、远古智人没有像现代人那样饱受传染病的困扰，原因在于多数传染病都是来自家禽家畜，采集社会只有狗是唯一会和人类近距离接触的动物。另外，采集社会人口密度小且分散，疾病不易传播流行。</p><p>正因为远古采集者有着比现代人更健康和多样的饮食结构，更短的工作时间，更少的传染病困扰。因此被定义为“最初的富裕社会”。但是这并不表示远古采集社会是理想与美好的，它们同样存在着残酷的一面，存在物资匮乏、族群相杀、时节难过以及儿童死亡率高等问题。有时候，他们会杀害儿童、病人和老人，但是他们的想法其实和现在许多人赞同堕胎和安乐死没有区别。远古的狩猎采集者和我们一样，都是人类。</p><p>除了生活方式与环境上的差别，远古采集者的心理和精神世界又是如何？多数学者都同意，远古采集者普遍信奉泛神论的信仰（animism，源自拉丁文anima，意为灵魂或精神）。泛神论相信，几乎任何一个地点、任何一只动物或植物、任何一种自然现象，都有其意识和情感，并且与人类之间没有障碍，可以直接通过语言、歌曲、舞蹈和仪式沟通。泛神论的一个特点在于所有的灵都只限于当场当地，某个具体的事物，而非万能的神。泛神论不是特定的宗教，而是数千种不同宗教、邪教或信仰的统称，这些宗教对于世界的看法、对于人类的定位都大同小异。然而，远古采集者是否一定都是泛神论我们无从得知。此外，采集社会是否存在政治，这一点也无法确定。尽管有考古发现一些具有“阶级”意味的表象，虽然具体原因不得而知，但是仍能说明3万年前的智人已经发明了一些社会政治规范，不仅超出了DNA的设定，也超越了其他人类和动物的行为模式。</p><p>最后，“战争”在远古采集社会扮演什么样的角色？有学者认为战争是出现在农业革命之后，伴随着私有财产而生。而另外一种主张则认为采集社会已经有各种残忍的暴力事件。然而不管是通过考古学研究还是人类观察学推测，都是无法还原远古采集社会的真实面貌，所以不能一概而论。采集社会可能有许多不同的宗教和社会结构，不同的地区和不同时段的生活情况也大相径庭，或存在暴力或平静祥和。</p><p>由于证据的缺乏，远古采集社会的很多事情都无法确定，我们也就无法重建出一副当时的宏观景象，更不用说重塑特定的事件。关于远古采集社会的很多问题，我们都只能沉默以对。这幅沉默的帷幕笼罩了几万年的人类历史，也许会一直尘封，也许未来出现新的研究工具可以揭开这幅厚重的帷幕。我也不能因为对远古采集社会知之甚少便否定远古智人对人类历史的贡献，不能对于7万年人类历史中的六年视而不见。他们做了很多重要的事情，特别是形塑了我们现有的世界，程度之大出乎意料，他们的足迹早已遍布全世界。整个动物界从古至今，最重要也是最具破坏性的力量，就是这群四处游荡、讲着故事的智人。</p><h4 id="毁天灭地的人类洪水"><a href="#毁天灭地的人类洪水" class="headerlink" title="毁天灭地的人类洪水"></a>毁天灭地的人类洪水</h4><p>在认知革命前，所有的人类物种都只住在亚非大陆。那时候地球不同的洲都有自己独特的生态系统和物种，但是随着智人在认知革命之后掌握了航海技术，智人的足迹开始遍布全球各地，对当地的生态与物种来说是致命的灾难，很多物种遭受灭绝，智人就如同毁天灭地的洪水一般“征服”全球。其中，澳洲大陆与美洲大陆都是血淋淋的例子。</p><p>大约在45000年前，智人首次抵达与亚非大陆相遇深远且隔海相望的澳洲大陆绝对是一件跨时代的大事，重要性不亚于哥伦布发现美洲大陆或是人类首次登月。这意味着海洋这个阻挡智人扩张最大的障碍也被征服了。随着智人来到澳洲大陆的那一刻起，曾经在这块土地生活了数万年甚至上百万年的物种都消失殆尽。其中澳大利亚当时24中50公斤以上的动物有23中都惨遭灭绝，许多比较小的物种也从此消失，整个澳大利亚的生态系统食物链重新洗牌，这也是澳大利亚生态系统数百万年来最重大的一次转型。</p><p>有些学者试着以气候变迁为借口为人类脱罪，然而有三大证据显示智人难辞其咎。</p><p>证据一：虽然澳大利亚气候确实在45000年前有一场改变，但是规模幅度不大。更何况在此之前，地球早就经历过许多次更为严重的冷却和暖化循环，在过去百万年间，平均每10万年就有一场冰河时期。换句话说，澳大利亚上的物种在45000年前早就经历过多次气候变迁，并且大多数都存活下来了。然后，45000年以后，全澳大利亚超过90%的巨型动物都从历史消失。如果说智人所有的巨型动物都恰巧死于严寒之后来到澳大利亚，实在很难令人信服。</p><p>证据二：如果是气候变迁导致物种灭绝，那么海洋生物受到的冲击通常不亚于陆地生物。然而，我们没有找到任何证据显示在45000年前海洋生物有显著的灭绝情形。如果假设智人的罪魁祸首，那么也很容易解释这波灭绝浪潮只席卷了陆地生物，而放过了附近的海洋生物。因为那时候智人虽然航海技术有大幅度提升，但是人类毕竟还是主要生活在陆地。</p><p>证据三：类似澳大利亚这种物质大面积灭绝的案例在接下来的几千年在不同的地点不断上演，而时间点都是在人类首次抵达的时候。</p><p>通过上面列出的三个证据，智人对与类似澳大利亚这样物种大灭绝的惨案的频繁上演难辞其咎。当时智人的生活与狩猎工具还是以石器为主，那么他们是如何主导这次生态浩劫的？以下有三种解释：</p><p>第一种解释：一般来说大型动物繁殖缓慢，孕期长，胎数少，怀孕周期长。因此就算智人猎杀不频繁，也可能会导致某个物种的死亡率高于出生率，最后导致这个物种的灭绝。</p><p>第二种解释：认为智人抵达澳大利亚的时候已经掌握了火耕技术。面对陌生而危险的环境，他们会刻意地烧毁难以跨越的森林，将地貌变成开阔的草原以适合人类的需求。他们在短短的几千年就彻底改变了澳大利亚大部分地区的生态系统。这种说法有植物化石记录为佐证。在45000年前，桉属植物在澳大利亚只是少数，智人的到来开创了桉属植物的黄金时代，因为桉属植物特别耐火。</p><p>第三种解释：这种解释不排除智人狩猎与火耕有显著影响，但是强调不能忽视气候因素。45000年前的气候变迁让澳大利亚的整个生态系统失衡，变得特别脆弱。正常情况下，系统会慢慢调整并适应恢复。智人在这个时候到来，将已经脆弱的生态系统推进了无底深渊。</p><p>与澳大利亚类似的还有美洲大陆，大约在14000年前，智人通过当时西伯利亚与阿拉斯加相连的陆地抵达美洲大陆。在此之前，美洲大陆的物种远比今天丰富，各种在亚非大陆未曾得见的物种都在此繁衍茁壮。然而在人类抵达后的两千年内，大多数独特物种都惨遭毒手。</p><p>回归智人历史，第一波物种灭绝浪潮是由于智人的扩张，第二波物种浪潮是因为农业革命，现在我们正面临第三波物种灭绝的浪潮：由工业革命所造成的物种灭绝。有些环保人士声称我们的祖先智人总是和自然和谐相处，殊不知智人就是造成最多动植物灭绝的元凶。也许，这场人类洪水的唯一幸存者可能只剩下人类自己，其他登上诺亚方舟的也只可能是作为人类盘中佳肴的家禽家畜罢了。</p><div align="center">[思维导图](https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png)<p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/ABriefHistoryOfHumankind-OnePart.png" alt="思维导图"></p></div>]]></content>
      
      
      <categories>
          
          <category> 书评 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人类简史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析@synchronizd底层实现原理</title>
      <link href="/2017/06/11/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/06/11/%E5%89%96%E6%9E%90@synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>@synchronizd是Objective-C中的一个语法糖，用于给某个对象加锁，因为使用起来简单方便，所以使用频率很高。然而，滥用@synchronizd很容易导致代码效率低下。本篇博客旨在结合@synchronizd底层实现源码并剖析其实现原理，这样可以更好的让我们在适合的情景使用@synchronizd。</p><p>@synchronizd本质上是一个编译器标识符，在Objective-C层面看不其任何信息。因此可以通过clang -rewrite-objc指令来获得@synchronizd的C++实现代码。示例代码如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    <span class="built_in">NSString</span> *obj = <span class="string">@"Iceberg"</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) {</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello,world! =&gt; %@"</span> , obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>{</span><br><span class="line">    </span><br><span class="line">    NSString *obj = (NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_0;</span><br><span class="line">    </span><br><span class="line">    {</span><br><span class="line">        id _rethrow = <span class="number">0</span>;</span><br><span class="line">        id _sync_obj = (id)obj;</span><br><span class="line">        <span class="built_in">objc_sync_enter</span>(_sync_obj);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_SYNC_EXIT</span> {</span><br><span class="line">                _SYNC_EXIT(id arg) : <span class="built_in">sync_exit</span>(arg) {}</span><br><span class="line">                ~_SYNC_EXIT() {</span><br><span class="line">                    <span class="built_in">objc_sync_exit</span>(sync_exit);</span><br><span class="line">                }</span><br><span class="line">                id sync_exit;</span><br><span class="line">            } _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_8l_rsj0hqpj42b9jsw81mc3xv_40000gn_T_block_main_54f70c_mi_1 , obj);</span><br><span class="line">                </span><br><span class="line">            } <span class="built_in">catch</span> (id e) {</span><br><span class="line">                _rethrow = e;</span><br><span class="line">            }</span><br><span class="line">        </span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_FIN</span> {</span><br><span class="line">                _FIN(id reth) : <span class="built_in">rethrow</span>(reth) {}</span><br><span class="line">                ~_FIN() {</span><br><span class="line">                    <span class="keyword">if</span> (rethrow)</span><br><span class="line">                        <span class="built_in">objc_exception_throw</span>(rethrow);</span><br><span class="line">                }</span><br><span class="line">                id rethrow;</span><br><span class="line">            } _fin_force_rethow(_rethrow);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过分析C++代码可以看到@sychronized的实现主要依赖于两个函数：objc_sync_enter和objc_sync_exit。此外还有try{}catch{}语句用于捕捉@sychronized{}语法块中代码执行过程中出现的异常。</p><p>我们发现objc_sync_enter函数是在try语句之前调用，参数为需要加锁的对象。因为C++中没有try{}catch{}finally{}语句，所以不能在finally{}调用objc_sync_exit函数。因此objc_sync_exit是在_SYNC_EXIT结构体中的析构函数中调用，参数同样是当前加锁的对象。这个设计很巧妙，原因在_SYNC_EXIT结构体类型的_sync_exit是一个局部变量，生命周期为try{}语句块，其中包含了@sychronized{}代码需要执行的代码，在代码完成后，_sync_exit局部变量出栈释放，随即调用其析构函数，进而调用objc_sync_exit函数。即使try{}语句块中的代码执行过程中出现异常，跳转到catch{}语句，局部变量_sync_exit同样会被释放，完美的模拟了finally的功能。</p><p>接下来，在<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm">苹果公开的源代码文件objc-sync.mm</a>中找到objc_sync_enter和objc_sync_exit这两个函数的实现，一窥其中的奥秘。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncData</span> {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SyncData</span>* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">//当前加锁的对象</span></span><br><span class="line">    <span class="type">int32_t</span> threadCount;  <span class="comment">//使用对object加锁的线程个数</span></span><br><span class="line">    <span class="type">recursive_mutex_t</span> mutex; <span class="comment">//递归互斥锁</span></span><br><span class="line">} SyncData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lockCount;  <span class="comment">//表示当前线程对object对象加锁次数</span></span><br><span class="line">} SyncCacheItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SyncCache</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> allocated;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> used;</span><br><span class="line">    SyncCacheItem list[<span class="number">0</span>];</span><br><span class="line">} SyncCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Fast cache: two fixed pthread keys store a single SyncCacheItem. </span></span><br><span class="line"><span class="comment">  This avoids malloc of the SyncCache for threads that only synchronize </span></span><br><span class="line"><span class="comment">  a single object at a time.</span></span><br><span class="line"><span class="comment">  SYNC_DATA_DIRECT_KEY  == SyncCacheItem.data</span></span><br><span class="line"><span class="comment">  SYNC_COUNT_DIRECT_KEY == SyncCacheItem.lockCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SyncList</span> {</span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SyncList</span>() : <span class="built_in">data</span>(nil) { }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use multiple parallel lists to decrease contention among unrelated objects.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></tbody></table></figure><p>上述代码是一些相关的数据结构，下面分别进行介绍：</p><p>SyncData结构体中有四个成员变量，其中object指针变量指向当前加锁对象，threadCount表示对object加锁的线程个数，mutex是一个递归互斥锁，意味着可以对object进行多次加锁，其具体作用后面会提到。</p><p>SyncCacheItem结构体中有两个成员变量，其中data是SyncData结构体类型的指针，lockCount表示当前线程对当前结构体对象加锁次数，其实就是对加锁对象object的加锁次数。我们可以看到SyncCacheItem与SyncData是一对一关系，SyncCacheItem只是对SyncData进行了再次封装以便于缓存，具体使用见后文。</p><p>SyncCache结构体中有三个成员变量，其中维护了一个SyncCacheItem类型的数组，allocated和used则分别表示当前分配的SyncCacheItem数组中的总个数和已经使用的个数。这个结构体与线程是一对一的关系，用于存储当前线程已加锁对象对应的SyncCacheItem结构体，因为一个线程可以对同一个对象多次加锁，所以通过引入缓存SyncCache可以提高效率，具体使用见后文。</p><p>SyncList结构体中有两个成员变量和一个构造函数，其中data是SyncData结构体类型的指针，lock是一个自旋锁。</p><p>sDataLists是一个全局StripedMap哈希列表，其中value为SyncList对象，key为加锁对象object指针进行hash后的值。StripedMap是一个C++模板类，其实现代码如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> { CacheLineSize = <span class="number">64</span> };</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_EMBEDDED</span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">8</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> { StripeCount = <span class="number">64</span> };</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> {</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>{</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) { </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) <span class="type">const</span> { </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">StripedMap</span>() {</span><br><span class="line">        <span class="comment">// Verify alignment expectations.</span></span><br><span class="line">        <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">0</span>].value;</span><br><span class="line">        <span class="type">uintptr_t</span> delta = (<span class="type">uintptr_t</span>)&amp;array[<span class="number">1</span>].value - base;</span><br><span class="line">        <span class="built_in">assert</span>(delta % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(base % CacheLineSize == <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，由于自己对C++模板类不熟悉，所以只能看个大概。其中有两个值得注意的地方，其中StripeCount表示哈希数组的长度，如果是嵌入式系统值为8，否则值为64，也就意味着哈希数组最大长度为64；函数indexForPointer为散列函数，算法不难，但是很巧妙，值得学习。</p><p>下面开始分析相关的函数实现，首先找到@sychronized直接调用的两个函数：objc_sync_enter和objc_sync_exit，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, ACQUIRE);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) {</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">objc_sync_nil</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) {</span><br><span class="line">        SyncData* data = <span class="built_in">id2data</span>(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) {</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">bool</span> okay = data-&gt;mutex.<span class="built_in">tryUnlock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!okay) {</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不难发现，上述代码都调用了id2data函数来获取一个与obj对应的SyncData对象，然后使用该对象中的递归互斥锁分别进行加锁与解锁。至此@sychronized的大致实现过程已经很清晰了，本质上是为一个对象分配一把递归互斥锁，可以也是为什么可以反复使用@sychronized对同一个对象进行加锁的原因。那么@sychronized是如果管理这把互斥锁，以及是如何处理多个线程对同一个对象进行多次加锁的情况？很明显，一切奥秘都藏在id2data函数中，其代码如下所示：</p><ul><li>注：为了描述方便，下面将id2data函数的形参object描述为同步对象obejct。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//从全局哈希表sDataLists中获取object对应的SyncList对象</span></span><br><span class="line"><span class="comment">//lockp指针指向SyncList对象中自旋锁</span></span><br><span class="line"><span class="comment">//listp指向一条SyncData链表，因为C++ STL中的哈希表处理地址冲突的方法是链地址法</span></span><br><span class="line">    <span class="type">spinlock_t</span> *lockp = &amp;<span class="built_in">LOCK_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData **listp = &amp;<span class="built_in">LIST_FOR_OBJ</span>(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于同一个线程来说，有两种缓存方式：</span></span><br><span class="line"><span class="comment">//第一种：快速缓存（fastCache），适用于一个线程一次只对一个对象加锁的情况，用宏SUPPORT_DIRECT_THREAD_KEYS来标识</span></span><br><span class="line"><span class="comment">//这种情况意味着同一时间内，线程缓存中只有一个SyncCacheItem对象，键值SYNC_DATA_DIRECT_KEY和SYNC_COUNT_DIRECT_KEY分别对应SyncCacheItem结构体中的SyncData对象和lockCount.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="comment">//用于标识当前线程的是否已使用fastCache</span></span><br><span class="line">    <span class="type">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    <span class="comment">//直接调用tls_get_direct函数获取SyncData对象</span></span><br><span class="line">    SyncData *data = (SyncData *)<span class="built_in">tls_get_direct</span>(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) {</span><br><span class="line">     <span class="comment">//标识fastCache已被使用</span></span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line"> <span class="comment">//比较fastCache中的SyncData对象中的object与当前同步对象object是否为同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) {</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">     <span class="comment">//fastCache中的对象恰好是当前同步对象object，则后续处理直接使用fastCache中SyncData对象</span></span><br><span class="line">            <span class="type">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            <span class="comment">//获取当前线程对应当前SyncData对象已经加锁的次数</span></span><br><span class="line">            lockCount = (<span class="type">uintptr_t</span>)<span class="built_in">tls_get_direct</span>(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data fastcache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">  <span class="comment">//判断当前操作的加锁还是解锁</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: {</span><br><span class="line">                <span class="comment">//加锁一次</span></span><br><span class="line">                lockCount++;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                <span class="comment">//解锁一次</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="comment">//更新已加锁次数</span></span><br><span class="line">                <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)lockCount);</span><br><span class="line">                <span class="comment">//已加锁次数为0，表示当前线程对当前同步对象object达到锁平衡，因此不需要再持有当前同步对象。</span></span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    <span class="comment">//将对应的SyncData对象从线程缓存中移除</span></span><br><span class="line">                    <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="comment">//此函数为原子操作函数，用于对32位的threadCount整形变量执行减一操作，且确保线程安全。因为可能存在同一时间多个线程对一个threadCount进行加减操作，避免出现多线程竞争。不同于lockCount，threadCount是多个线程共享的一个变量，用于记录对一个对象加锁的线程个数，threadCount对应的SyncData对象除了线程缓存中持有之外，还存在于全局哈希表sDataLists中，sDataLists哈希表是多个线程共享的数据结构，因此存在多线程访问的可能。而lockCount则与线程一一对应且存储在线程的缓存区中，不存在多线性读写问题，因此不需要加锁。</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    <span class="comment">//这是第二章缓存方式：使用SyncCache结构体来维护一个SyncCacheItem数组，这样一个线程就可以处理对多个同步对象。值得注意的是SyncCache与线程也是一对一的关系。</span></span><br><span class="line">    <span class="comment">//获取当前线程缓存区中的SyncCache对象</span></span><br><span class="line">    SyncCache *cache = <span class="built_in">fetch_cache</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) {</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">//遍历SyncCache对象中的SyncCacheItem数组，匹配当前同步对象object</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) {</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="comment">//当前同步对象object已存在的SyncCache中</span></span><br><span class="line">            <span class="comment">//获取对应的SyncData对象</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="comment">//无效的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) {</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//后续操作同fastCache一样，参考fastCache的注释</span></span><br><span class="line">            <span class="keyword">switch</span>(why) {</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    <span class="built_in">OSAtomicDecrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前线程中的缓存中没有找到当前同步对象对应的SyncData对象，则在全局哈希表中查找</span></span><br><span class="line">    <span class="comment">//因为全局哈希表是多个线程共享的数据结构，因此需要进行加锁处理</span></span><br><span class="line">    lockp-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//遍历当前同步对象obejct在全局哈希表中的SyncData链表。这里之所以使用链表，是因为哈希表的hash算法不能确保hash的唯一性，存在多个对象对应一个hash值的情况。</span></span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) {</span><br><span class="line">          <span class="comment">//哈希表中存在对应的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) {</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                <span class="comment">//此函数为原子操作函数，确保线程安全，用于对32位的threadCount整形变量执行加一操作，表示占用当前同步对象的线程数加1。</span></span><br><span class="line">                <span class="built_in">OSAtomicIncrement32Barrier</span>(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//用于标记一个空闲的SyncData对象</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="comment">//由于此时同步对象object没有对应的SyncData对象，因此RELEASE与CHECK都属于无效操作</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="comment">//如果没有找到匹配的SyncData对象且存在空闲的SyncData对象，则直接使用，不需要创建新的SyncData，以提高效率。</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) {</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="comment">//关联当前同步对象</span></span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            <span class="comment">//重置占用线程为1</span></span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到这一步说明需要新建一个SyncData对象</span></span><br><span class="line">    result = (SyncData*)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(SyncData), <span class="number">1</span>);</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建递归互斥锁</span></span><br><span class="line">    <span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="built_in">recursive_mutex_t</span>();</span><br><span class="line">    <span class="comment">//以“入栈”的方式加入当前同步对象object对应的SyncData链表</span></span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">  <span class="comment">//对全局哈希表的操作结束，解锁</span></span><br><span class="line">    lockp-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="comment">//只有ACQUIRE才需要新建SyncData对象</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) {</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//fastCache缓存模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) {</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            <span class="comment">//直接缓存新建的SyncData对象</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            <span class="comment">//设置加锁次数为1</span></span><br><span class="line">            <span class="built_in">tls_set_direct</span>(SYNC_COUNT_DIRECT_KEY, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="comment">//SyncCache缓存模式，则直接加入SyncCacheItem数组中</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = <span class="built_in">fetch_cache</span>(YES);</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上述代码的注释，id2data函数的功能已经大致清晰。id2data函数主要是用于管理同步对象object与线程之间的关联。不论是ACQUIRE、RELEASE还是CHECK操作，都会先从当前线程的缓存中去获取对应的SyncData对象。如果当前线程的缓存区中不存在，那么再从全局的哈希数组中查找，查看其它线程是否已经占用过当前同步对象object。如果还是没有，那么就新建一个与之对应的SyncData对象，分别加入全局哈希表和当前线程缓存中。</p><p>至此，@synchronized的实现原理已经剖析结束，其有一个最大的特点是：不论是多个线性同一时间内对一个对象进行多次同步还是一个线程对同一个对象同步多次，一个对象只分配一把递归互斥锁。也就意味着对同一个对象而言，当执行某一次同步操作时，其他线程或同一线程的其他同步操作都会被阻塞，不言而喻，这种加锁方式的效率是很低的。</p><p>下面代码展示了@synchronized经典的使用案例之一：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject1:(<span class="keyword">id</span>)value {</span><br><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line"><span class="keyword">self</span>.instanceMember1 = value;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject2:(<span class="keyword">id</span>)value {</span><br><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line"><span class="keyword">self</span>.instanceMember2 = value;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setInstanceMemberObjecObject3:(<span class="keyword">id</span>)value {</span><br><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) {</span><br><span class="line"><span class="keyword">self</span>.instanceMember3 = value;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码，调用其中一个设置函数时，另外两个成员变量的设置函数在同一时间被调用都会被阻塞。这里@synchronized同步的代码很简单，所以不会效率差别不大。如果是同步的代码需要执行较长的时间，且被多个线程并发调用，那么效率变得很低。如果不清楚@synchronized的实现原理，可能很难排查出来导致效率低下的问题所在。我建议使用GCD取代@synchronized实现同步功能，GCD不仅是线程安全，且其由底层实现，效率会好很多。我们发生@synchronized的底层实现有捕获异常的功能，因此适合在需要确保发生错误时代码不会死锁，而是抛出异常时使用。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的this关键字</title>
      <link href="/2017/06/07/JavaScript%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2017/06/07/JavaScript%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>这是一篇翻译文章，原文地址*<a href="http://davidshariff.com/blog/javascript-this-keyword/#first-article">点击这里</a>*。</p><p>JavaScript中一个常用的语法特征就是this关键字，同时这也是JavaScript最容易被误解和造成困惑的特征。this关键字的含义是什么且决定其含义的依据是什么？</p><p>这篇文章试着解开这个的疑惑并给出一个简单清晰的解释。</p><p>对于有其他语言编程经验的人来说应该也使用过this关键字，且多数情况下this指向的是一个通过构造函数创建的新对象。举例来说，假设有一个Boat类，里面包含一个成员方法moveBoat()，我们可以在moveBoat()方法中通过this关键字访问当前的对象实例。</p><p>在JavaSctript中，当使用new关键字创建一个新对象后，在构造函数中可以通过this关键字访问当前对象。然而，JavaScript中的this关键字指向的对象是随着函数调用的上下文变化而变化的。如果你不是很了解关于JavaScript执行上下文的知识，我推荐你看看我的另外一篇关于这个话题的<a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/#first-article">文章</a>。好了，讲得够多了，让我们看几个代码实例：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global scope</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">'abc'</span>;</span><br><span class="line"><span class="title function_">alert</span>(foo); <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">'def'</span>;</span><br><span class="line"><span class="title function_">alert</span>(foo); <span class="comment">//def</span></span><br></pre></td></tr></tbody></table></figure><p>无论何时，只要是在全局上下文而非函数体内使用this关键字，那么this总是指向全局对象的（JavaSctript中的全局对象一般是Windows，NodeJS中是global）。接下来看看在函数中使用this关键字的情景：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boat = {</span><br><span class="line">    <span class="attr">size</span>: <span class="string">'normal'</span>,</span><br><span class="line">    <span class="attr">boatInfo</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === boat);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">size</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">boat.<span class="title function_">boatInfo</span>(); <span class="comment">// true, 'normal'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bigBoat = {</span><br><span class="line">    <span class="attr">size</span>: <span class="string">'big'</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">bigBoat.<span class="property">boatInfo</span> = boat.<span class="property">boatInfo</span>;</span><br><span class="line">bigBoat.<span class="title function_">boatInfo</span>(); <span class="comment">// false, 'big'</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码中的this关键字指向是如何判断的？上述代码中有一个boat对象，包含了一个size属性和boatInfo方法。在boatInfo方法中有两条输出语句，分别是判断this关键字是否指向boat对象和输出this关键字指向的对象的size属性。因此，当执行代码boat.boatInfo()时，输出结果分别是true和normal。</p><p>随后我们创建了另外一个对象bigBoat，里面同样有一个值为big的size属性。然而，bigBoat对象没有boatInfo方法，因此通过语句bigBoat.boatInfo = boat.boatInfo拷贝一个boatInfo方法。现在，当我们执行语句bigBoat.boatInfo()时，输出的结果分别是false和big。为什么会输出false? boatInfo方法中的this指向的对象是如何发生变化的？</p><p>首先你得明白任何函数中的this关键字指向的值都不是定值，它根据你每次调用函数前的上下文来决定，这个上下文就是函数被调用时所作的生命周期。更为重要的是函数具体的调用语句。</p><p>当一个函数被调用时，如果函数是被某个对象调用时，那么函数中this关键字指向的是调用该函数的对象，否则指向的全局对象。下面举例说明：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// global - because the method bar() belongs to the global object when invoked</span></span><br><span class="line"><span class="comment">//this指向全局对象</span></span><br><span class="line"><span class="title function_">bar</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// foo - because the method baz() belongs to the object foo when invoked</span></span><br><span class="line"><span class="comment">//this指向foo对象</span></span><br><span class="line">foo.<span class="title function_">baz</span>(); </span><br></pre></td></tr></tbody></table></figure><p>如果事情有这么简单，那么上述代码显然解决了我们的疑惑。但是还有更为复杂的情况，看似同一个的函数，调用的语句不同也会导致this关键字的指向不同。如下所示：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// foo - because baz belongs to the foo object when invoked</span></span><br><span class="line"><span class="comment">//this指向foo对象</span></span><br><span class="line">foo.<span class="title function_">baz</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherBaz = foo.<span class="property">baz</span>;</span><br><span class="line"><span class="comment">// global - because the method anotherBaz() belongs to the global object when invoked, NOT foo</span></span><br><span class="line"><span class="comment">//this指向全局对象，即使anotherBaz是由foo.baz赋值而来，但是this的指向最终还是由调用的方式决定。</span></span><br><span class="line"><span class="title function_">anotherBaz</span>(); </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过上述代码我们看到由于调用语句的不同，baz方法中的this关键字指向的对象也不一样。现在我们来看看this关键字处于内嵌时的指向是如何的：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    <span class="attr">anum</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">baz</span>: {</span><br><span class="line">        <span class="attr">anum</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">bar</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">anum</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 20 - because left side of () is bar, which belongs to baz object when invoked</span></span><br><span class="line"><span class="comment">//输出的值是20，因为bar方法是通过baz对象调用的</span></span><br><span class="line">foo.<span class="property">baz</span>.<span class="title function_">bar</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = foo.<span class="property">baz</span>.<span class="property">bar</span>;</span><br><span class="line"><span class="comment">// 0 - because left side of () is hello, which belongs to global object when invoked</span></span><br><span class="line"><span class="comment">//输出的是0，因为hello函数没有显示的调用对象，缺省调用对象为全局对象global</span></span><br><span class="line"><span class="title function_">hello</span>();</span><br></pre></td></tr></tbody></table></figure><p>另外一个被常问到的问题是：如何判断事件监听函数中的this关键字指向？答案是处于事件监听函数中的this关键字通常指向触发该事件的DOM元素。下面举例说明：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"test"</span>&gt;I am an element <span class="keyword">with</span> id #test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doAlert</span>(<span class="params"></span>) { </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>); </span><br><span class="line">} </span><br><span class="line"><span class="comment">//指向全局对象，但是因为全局对象没有相应的属性，因此输出undefined</span></span><br><span class="line"><span class="title function_">doAlert</span>(); <span class="comment">// undefined </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'test'</span>); </span><br><span class="line">myElem.<span class="property">onclick</span> = doAlert; </span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(myElem.<span class="property">onclick</span> === doAlert); <span class="comment">// true </span></span><br><span class="line"><span class="comment">//this指向myElem对象</span></span><br><span class="line">myElem.<span class="title function_">onclick</span>(); <span class="comment">// I am an element</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上述代码中，第一次调用doAlert函数，输出的是undefined，因此此时this指向的是全局对象global。当我们将doAlert函数设置为myElem元素对象的click消息监听函数时，意味着每次触发click消息时，doAlert等价于被myElem对象直接调用，因此this关键字指向的就是myElem对象。</p><p>最后，我想提醒大家的是this关键字的指向是可以通过call()和apply()函数手动修改的，这将导致我们上面讨论的内容都不再适用。另外一点是，在某个对象的构造函数中的this关键字默认是指向当前新建的对象，因为构造函数是使用new关键字调用的，系统会将构造函数中的this关键字指向即将创建的对象。</p><p><strong>总结</strong></p><p>希望今天的博客能够清除你对this关键字的疑惑，并且以后都能正确地判断this关键字的指向。现在我们知道了this关键字的指向的动态变化的且具体的值取决于this所在函数的调用方式。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSctript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocoa程序退出前发送HttpRequest请求</title>
      <link href="/2017/05/05/cocoa%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E5%89%8D%E5%8F%91%E9%80%81Request%E8%AF%B7%E6%B1%82/"/>
      <url>/2017/05/05/cocoa%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E5%89%8D%E5%8F%91%E9%80%81Request%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>最近在视频投送项目中遇到一个奇葩问题，花费了一整天时间才得以解决。这个问题比较隐晦，值得记录一下。</p><p>根据功能需要，需要在cocoa程序退出前，发送一个关闭设备的指令，本质上就是post一个Http请求，用于中止当前出于投送状态的设备。</p><p>具体代码如下：</p><p>在回调函数- (void)applicationWillTerminate:中调用停止投送API</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">NSNotification</span> *)aNotification {</span><br><span class="line">    <span class="comment">// Insert code here to tear down your application</span></span><br><span class="line">    </span><br><span class="line">    [[CastHelper sharedInstance] stopCast];</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">将stop指令集成到URL里面，加入投送队列castOperationQueue中，然后通过HttpRequest发送出去。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopCast</span><br><span class="line">{</span><br><span class="line"><span class="built_in">dispatch_async</span>(castOperationQueue, ^{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ZDCastDevice * device <span class="keyword">in</span> <span class="keyword">self</span>.connectedDeviceInfo.allValues )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//发送stop请求</span></span><br><span class="line">[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">- (<span class="keyword">void</span>)sendRequestURL:(<span class="built_in">NSURL</span> *)url HTTPMethod:(<span class="built_in">NSString</span> *)httpMethod</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] init];</span><br><span class="line">    [request setURL:url];</span><br><span class="line">    [request setHTTPMethod:httpMethod];</span><br><span class="line">    [request setValue:<span class="string">@"application/json;charset=UTF-8"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    [request setHTTPBody:<span class="literal">nil</span>];</span><br><span class="line"> </span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Error</span></span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">        {</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">NSInteger</span> statusCode = [(<span class="built_in">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class="line">         </span><br><span class="line">            <span class="comment">//successed</span></span><br><span class="line">            <span class="keyword">if</span> ( statusCode == <span class="number">200</span>)</span><br><span class="line">            {</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//failed</span></span><br><span class="line">            }<span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">    }] resume];</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在程序正常运行期间，使用上述代码能够正常的执行stop指令，并接受相应的响应。但是，如果在applicationWillTerminate这一函数中调用，通过断点调试发现Request并未成功发送出去，程序就退出了。</p><p>一开始以为是异步发送请求的原因，于是使用dispatch_semaphore_t信号量进行同步，执行结果一样，未解锁之前程序就退出了。代码如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line">- (<span class="keyword">void</span>)sendRequestURL:(<span class="built_in">NSURL</span> *)url HTTPMethod:(<span class="built_in">NSString</span> *)httpMethod</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] init];</span><br><span class="line">    [request setURL:url];</span><br><span class="line">    [request setHTTPMethod:httpMethod];</span><br><span class="line">    [request setValue:<span class="string">@"application/json;charset=UTF-8"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    [request setHTTPBody:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    dispatch_semaphore_t semp = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Error</span></span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">        {</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">NSInteger</span> statusCode = [(<span class="built_in">NSHTTPURLResponse</span> *)response statusCode];</span><br><span class="line">         </span><br><span class="line">            <span class="comment">//successed</span></span><br><span class="line">            <span class="keyword">if</span> ( statusCode == <span class="number">200</span>)</span><br><span class="line">            {</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//failed</span></span><br><span class="line">            }<span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semp);</span><br><span class="line">        </span><br><span class="line">    }] resume];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待接受到请求响应才执行后续代码</span></span><br><span class="line">    dispatch_semaphore_wait(semp, DISPATCH_TIME_FOREVER);</span><br><span class="line">   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>同步请求方式的方式也试过，结果同样达不到预期效果。代码如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSURLResponse</span>* response = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) {</span><br><span class="line">        </span><br><span class="line">        HTTPLogInfo(<span class="string">@"%s:%d - Error: %@"</span> , __func__ , __LINE__ , [error localizedDescription]);</span><br><span class="line">        </span><br><span class="line">    }<span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        HTTPLogInfo(<span class="string">@"%s:%d - response: %@"</span> , __func__ , __LINE__ , [response description]);</span><br><span class="line">    }</span><br><span class="line">   </span><br></pre></td></tr></tbody></table></figure><p>思来想去，觉得可能是程序退出去前，只有主线程有效，其他线程均被释放了。于是，把调用stop指令的代码放入主线程队列：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopCast</span><br><span class="line">{</span><br><span class="line"><span class="comment">//加入主线程队列</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">for</span> (ZDCastDevice * device <span class="keyword">in</span> <span class="keyword">self</span>.connectedDeviceInfo.allValues )</span><br><span class="line">       {</span><br><span class="line">           <span class="comment">//发送stop请求</span></span><br><span class="line">[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line">           </span><br><span class="line">       }</span><br><span class="line">      </span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行结果还是同之前一样。最后，仔细回想了一下RunLoop的执行过程，很可能是RunLoop在执行了applicationWillTerminate函数所在的任务之后就直接退出了，也就不会执行主线程队列后续的任务了。</p><p>于是，直接把调用stop指令的函数放在与applicationWillTerminate同一个任务中，代码如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopCast</span><br><span class="line">{</span><br><span class="line"><span class="comment">//发送stop请求</span></span><br><span class="line">[<span class="keyword">self</span> sendRequestURL:<span class="string">@"192.168.1.1/xxx/stop"</span> HTTPMethod:<span class="string">@"POST"</span> completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>果然不出所料，Request执行成功，并获得相应的Response。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述言论都是基于我的猜测，我暂时没有去验证。这个问题比较隐晦，有点违背习惯性的思维。改天抽空结合Apple源代码进行分析验证，此处留坑。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cocoa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于读书无用论的一些想法</title>
      <link href="/2017/04/14/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
      <url>/2017/04/14/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于最近流行的“读书无用论”观点的一些个人看法</p><p>通过反复揣摩这句话，大概可以总结为以下五点（如有歧义，欢迎指正）：</p><p>一、在需要的时候，读技能书学习相应的技能即可<br>二、选择什么样的生活，取决于性格，而非读书能够左右<br>三、读书不能弥补先天的差距</p><p>我觉得，所谓的读书无用，其中“读书”是指阅读，而非指代“寒窗苦读十余载，金榜题名望今朝”这样功利性的读书，另外“无用”是指阅读不会对一个人的生活带来太大的改变。所以，后面用“阅读”来取代“读书”。</p><p>首先，我的立场是：“阅读很有用，不仅完善人格，还能深化思想，甚至可以改变一个人的命运。”书有好书和差书之分，一本好书是作者耗费了大量精力，基于自身知识底蕴，结合个人思想，经过岁月打磨出来的。从某个角度来说，读者只需要几十块钱就能获得作者几十年甚至一生的心血，实在是再廉价不过了。当然，读者能否完全理解作者的思想那就另当别论。阅读一本好书，读过就会留下印象，并且受其影响，只是深浅之分罢了。至于差书，确实没有阅读的必要，不仅无用，浪费时间不说，可能还会造成负面影响。</p><p>以下是我的具体想法。</p><p>一、在需要的时候，读技能书学习相应的技能即可。</p><p>作为一个理科生，读技能类的书差不多是每天的日常。书分很多种，技能书则属于自然科学类。特点就是其内容是依据人类目前已经公认或者证实的客观事实提炼或者推导出来的。同一个主题，不同的作者可能表述方式不一样，但是阐述的观点或者得出结论总是一样的。这样的书，讲究实用性，尊重客观事实，不会随着个人意志改变，主要功能在于传授一种技能，对人的三观（人生观，价值观，世界观）不会有太大的影响。</p><p>我想你认可读技能书就是因为它的实用性，能解决实际问题。这也是你认为阅读还算有价值的地方。这一点我同意你的观点。对于不是专业的技能，需要的时候，能解决问题就行。</p><p>二、选择什么样的生活，取决于性格，而非读书能够左右</p><p>首先，现实生活中，大多数人都没有选择自己想要的生活的资本，而是迫于生计和负担，过着不如意的生活。所以，选择什么样的生活与物质条件也有关系。所以，应该是选择什么样的生活态度更为准确。</p><p>都说“内心是怎样的，你看到的世界就是怎样的。”我们看到的或者听到的，都不一定是真实客观的，而是经过大脑过滤，在主观思想的作用下，变成我们愿意相信的“事实”。至少，我们大多数时候都会信以为真。</p><p>那么你的思考问题的角度是否足够全面，思维方式是否是辩证的，以及你大脑的知识储量是否足够充实，就确定了过滤后的结果与真相偏离度的大小。能够影响上述三个方面的因素大致两个，一是外界环境影响，包括家庭环境，成长环境，教育环境。在我们还没有独立学习能力之前，我们对世界的认知都是被动地接受外界影响，最终构成了性格的一部分，这属于先天条件差异造成的个体差异，即所谓的天赋。另外一个因素就是主动学习，这也是人类特有的能力。而最有效也是最廉价的途径莫非就是阅读。一个人成年之后并非不可以改变自己的性格，只是会比较难，这一点已经有科学依据。阅读，既然能改变你的主观思想，也就会影响你对于这个世界的认知，对人生的理解，对自身价值的认可。阅读也许不能改变一个人的物质生活，但是改变一个人看待生活的方式。因此，阅读至少可以改善我们的精神生活。</p><p>因为性格是先天性的，所以会在最开始影响我们的生活方式。但是阅读可以改变一个人看待生活的态度，进而去追求自己想要的生活。</p><p>三、阅读不能弥补先天的差距</p><p>你说有人毕生的追求也许就是别人与生俱来的。没错，确实普遍存在这样的情况。就拿阅读这个习惯来说吧，有些“书香门第”出身的孩子，从小就养成了阅读的习惯，而且从小就阅读很多的书籍，从而比一般的同龄人有更渊博的知识和更出色的思维方式。这些天赋在他们看来都是自然而然的事情，先天的优势不言而喻。对比出身贫穷的孩子，很多人都没有阅读的习惯，思考问题也很浅显和片面。而且，一旦成年，即便有条件和时间来重新塑造自己，也需要付出很大代价，需要将推翻原有的思维方式和改正不良的习惯。</p><p>从这个角度来说，阅读确实很难弥补先天的差距。人生本就是不公平的，坦然接受这个事实是树立正确地人生观的前提。另外，即便如此也不能因为这个原因就否定阅读的作用。</p><p>每个人都有自己的局限性。而人生的意义就在于突破自己的局限性，给自己的生活带来更多可能性，这是每一个精彩人生的主旋律。而阅读无非就是这样的一把利刃。</p><p>最后，我上面叽里呱啦说这些并不是想改变你对阅读的看法。而是，我想和你交流一下我对阅读的看法。我从小在农村长大，身边的人几乎没有看书的习惯，除了干活就是看电视聊家常，童年的记忆根本没有书的影子。我们村很多同龄人都是初中毕业就去广东打工。我是整个村子为数不多的大学生。即便如此，我直到上大学都没有真正明白为什么要读书，意义是什么？难道就是为了找一份谋生的工作？阅读的习惯是我大二之后开始培养的，因为我意识到了自己的局限性以及和别人的先天性差距。从那时候起，我就开始培养自己的阅读习惯，一开始确实很难，因为应试教育的原因很排斥读书。后面反反复复折腾，慢慢对阅读有了一点感觉，也尝到了阅读带来的一点甜头。就我个人经历来说，阅读给我生活带来的改变还是挺大的，不管是精神上还是物质上都有改变，让我更好地把握机遇，更好的去对待生活中的困境。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原生JS代码模拟鼠标点击消息</title>
      <link href="/2017/02/23/JS-%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%B6%88%E6%81%AF/"/>
      <url>/2017/02/23/JS-%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>近两天都忙于更新之前做的一个关于国外某知名音乐网站项目，因为自己一直做iOS开发并没有系统的学习过JS，所以属于半吊子水平。</p><p>由于该音乐网站对网页进行了全新的改版，导致之前注入的JS代码全部失效，且原网站中使用的第三方JQuery库也被去掉了。意味着只能使用原生JS重写注入代码。</p><p>期间遇到了一个“棘手”的问题：使用原生JS代码模拟鼠标点击消息来改变音量，不同于普通的鼠标点击的是消息里面需要附带鼠标坐标。在各种尝试之后，耗费了大半天时间才得以解决，个人觉得有点价值，记录下解决思路以供参考。</p><p>以下是解决思路流程：</p><p>ps：以下调试和代码均在Chrome浏览器的控制台执行。</p><h4 id="分析DOM元素结构"><a href="#分析DOM元素结构" class="headerlink" title="分析DOM元素结构"></a>分析DOM元素结构</h4><p>页面样式</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-1.png" alt="页面样式"></p><p>DOM结构</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-2.png" alt="DOM结构"></p><p>由上图可知，DIV元素VolumeSlider作为父元素，其下有四个子元素，分,包括显示音量的slider和控制音量的handle元素。</p><p>对音量相关的DOM结构有一个大致了解，便于后面消息派发时选择触发的目标元素。如果说网站将响应鼠标消息的js绑定在父元素，那么选择任意一个子元素或者父元素本身作为触发对象都可以，因为消息会自动传递，最终会作用于父元素VolumeSlider。但是如果响应鼠标消息的js是绑定在四个子元素中的其中一个，则需要一一尝试。这个例子中只有4个子元素，所以很快就能有结果，但是如果需要测试的元素很多，那就效率太低下了。文章后面会介绍一种方法，快速定位响应鼠标消息的元素。</p><h4 id="模拟鼠标点击消息"><a href="#模拟鼠标点击消息" class="headerlink" title="模拟鼠标点击消息"></a>模拟鼠标点击消息</h4><p>该音乐网站改版之前，因为支持jQuery，借助于jQuery库提供的API很方便获取元素坐标和模拟鼠标点击消息。而新的版本只能用原生js编写相关代码。</p><p>第一步：获取元素的坐标位置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//递归获取元素的纵坐标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">e</span>){</span><br><span class="line">    <span class="keyword">var</span> offset=e.<span class="property">offsetTop</span>;</span><br><span class="line">    ／／累加父元素的坐标值</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">offsetParent</span>!=<span class="literal">null</span>) </span><br><span class="line">    ／／递归</span><br><span class="line">    offset+=<span class="title function_">getTop</span>(e.<span class="property">offsetParent</span>);</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//递归获取元素的横坐标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLeft</span>(<span class="params">e</span>){</span><br><span class="line">    <span class="keyword">var</span> offset=e.<span class="property">offsetLeft</span>;</span><br><span class="line">    ／／累加父元素的坐标值</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">offsetParent</span>!=<span class="literal">null</span>) </span><br><span class="line">    ／／递归</span><br><span class="line">    offset+=<span class="title function_">getLeft</span>(e.<span class="property">offsetParent</span>);</span><br><span class="line">    <span class="keyword">return</span> offset; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>第二步：模拟鼠标消息</p><p>原生js的Event对象有很多属性，但是创建Event的时并不是每一个属性都需要赋值。在网上找到了一篇博客<a href="http://marcgrabanski.com/simulating-mouse-click-events-in-javascript/">Simulating Mouse Events in JavaScript</a>讲的比较详细。以下是我使用的示例代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">／／offset是通过音量值转换过来的：音量level（<span class="number">0</span>-<span class="number">1</span>）* targetElement的长度</span><br><span class="line"><span class="keyword">var</span> clientX = <span class="title function_">getLeft</span>(targetElement) + offset;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> clientY = <span class="title function_">getTop</span>(targetElement);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">MouseEvent</span>(<span class="string">'click'</span>, {</span><br><span class="line"><span class="string">'view'</span>: <span class="variable language_">window</span>,</span><br><span class="line"><span class="string">'bubbles'</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">'cancelable'</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">'clientX'</span>:clientX,</span><br><span class="line"><span class="string">'clientY'</span>:clientY</span><br><span class="line">                                       });</span><br><span class="line">            </span><br><span class="line">targetElement.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>第三步：获取响应鼠标消息的元素</p><p>如果是普通的鼠标消息，比如点击按钮消息或者不带坐标值的消息，一般很容易触发成功。但是如果是带来坐标位置的鼠标消息则很可能触发成功之后但是达不到预期效果。在这个问题上我困惑了蛮久，明明代码执行之后，返回触发消息成功，但是音量值并没有改变。</p><p>我在想有没有办法将真实的鼠标点击消息内容输出到终端，这样通过对比真实的鼠标消息就能找到模拟的鼠标消息的差异所在。</p><p>于是，在控制台输入了以下代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> windowClickEvent = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">ev</span>){</span><br><span class="line"><span class="keyword">var</span> oEvent = ev||event;</span><br><span class="line">／／获取当前鼠标消息对象</span><br><span class="line">windowClickEvent = oEvent;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上述代码能获得当前鼠标消息对象。使用鼠标点击音量条，在控制台获得如下结果：</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/originality/js-simulate-mouse-click-3.png" alt="DOM结构"></p><p>对比真实的鼠标消息，确定模拟的鼠标消息中的坐标值是吻合的。但是二者的target元素不同，这也正是原因所在。修改了target元素之后，代码执行结果达到了预期的结果。通过这个方法可以快速定位响应鼠标消息的目标元素。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在刚开始要使用原生js模拟鼠标消息的时候，感觉一片茫然。在网上查了很多资料，没有找到满足需求的代码。最后只能硬着头皮自己写，期间各种不确定性都需要一一测试，折腾了大半天，好在最终达到预期的结果。与此同时，对模拟鼠标消息也有了新的体会，至少以后能够比较轻松的完成类似的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解除NSTimer潜在的“保留环”问题</title>
      <link href="/2017/02/12/%E8%A7%A3%E9%99%A4NSTimer%E6%BD%9C%E5%9C%A8%E7%9A%84%E2%80%9C%E4%BF%9D%E7%95%99%E7%8E%AF%E2%80%9D%E9%97%AE%E9%A2%98/"/>
      <url>/2017/02/12/%E8%A7%A3%E9%99%A4NSTimer%E6%BD%9C%E5%9C%A8%E7%9A%84%E2%80%9C%E4%BF%9D%E7%95%99%E7%8E%AF%E2%80%9D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>NSTimer是Foundation框架中的一个使用频率很高的类，然而其调用过程中很容易引入潜在的“保留环“问题。可能是因为NSTimer的提供的API足够便利与顺手，以至于这个问题不容易被察觉到。这篇博客旨在阐述这个问题并提供解决方法。</p><p>以下的NSTimer提供的三个常用的创建或者初始化的API：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFireDate:(<span class="built_in">NSDate</span> *)date interval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)t selector:(SEL)s userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)ui repeats:(<span class="built_in">BOOL</span>)rep <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这三个API有一个共同的点，即都需要提供一个target参数。这个target参数会被创建的NSTimer实例对象强引用一次，直到NSTimer实例对象调用invalidate方法后失效才释放。API文档原文如下：</p><blockquote><p>target: The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. </p></blockquote><p>多数情况，我们都会将创建后NSTimer实例对象保存为当前类的实例变量，然后NSTimer的target参数设置为self指针。我写代码的习惯就是这样的。实例代码如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>{</span><br><span class="line">    <span class="built_in">NSTimer</span> *mTimer;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init {</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) {</span><br><span class="line">      <span class="comment">//此处参数repeats = YES;</span></span><br><span class="line">        mTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFiredFun) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        [mTimer setFireDate:[<span class="built_in">NSDate</span> distantPast]];</span><br><span class="line">     </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc {</span><br><span class="line">    [mTimer invalidate];</span><br><span class="line">    mTimer = <span class="literal">nil</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerFiredFun{</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span> , __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc , <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    </span><br><span class="line">    MyObject *myObjcet = [MyObject new];</span><br><span class="line">    <span class="comment">//self只是一个空消息，避免编译器发出myObjcet未使用的警告</span></span><br><span class="line">    [myObjcet <span class="keyword">self</span>];</span><br><span class="line">  <span class="comment">//NSTimer依赖于RunLoop而存活，手动激活RunLoop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码就是典型的计时器使用情景之一。如果计时器只是一次执行而非反复触发，那么计时器会在执行后自动失效，也就不会有“保留环”的问题。但是如果是设置反复触发的计时器类型，那么NSTimer对象会强引用MyObject对象，而当前类也一直持有NSTimer对象，因此，如果NSTimer不调用invalidate设置无效，MyObject对象不会背释放，其dealloc函数也一直被调用，然而NSTimer的invalidate恰好是MyObject对象的dealloc函数中调用。这样两个对象都不会释放。</p><p>出现“保留环”的根本原因在于NSTimer对象在创建的API隐性地强引用一次target，因此，解除“保留环”的关键在于避开NSTimer对象对self指针的强引用。以下是提供的一种解决方案：</p><p><strong>NSTimer+BlockSupported分类</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ICETimerScheduleBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">"NSTimer+BlockSupported.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlockSupported</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)ice_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                         block:(ICETimerScheduleBlock)block</span><br><span class="line">                                       repeats:(<span class="built_in">BOOL</span>)yesOrNo {</span><br><span class="line">    <span class="comment">//Timer会对target强引用，但是此处target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:ti target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(ice_timerFiredFun:) userInfo:block repeats:yesOrNo];</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)ice_timerFiredFun:(<span class="built_in">NSTimer</span> *)timer {</span><br><span class="line">    ICETimerScheduleBlock block = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span> (block) {</span><br><span class="line">        block();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><p><strong>使用方式</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">mTimer = [<span class="built_in">NSTimer</span> zd_scheduledTimerWithTimeInterval:<span class="number">1.0</span>f block:^{</span><br><span class="line">    <span class="comment">//添加一次局部强引用，确保即使在block执行过程中外部的self被释放了也能顺利完成。局部变量strongSelf的生命周期只限于当前block，不会一直持有self，所以不影响外部self对象的引用计数平衡。</span></span><br><span class="line">    <span class="comment">//如果局部强引用，weakSelf可能会在block执行过程中因为外部self释放而被设置为nil。</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf timerFiredFun];</span><br><span class="line">} repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></tbody></table></figure><p>上述解决方案使用了NSTimer+BlockSupported分类对NSTimer原生函数进行了二次封装，将调用方需要的执行的函数转移到block中执行，再结合__weak指针解除NSTimer对self的强引用。NSTimer原生API调用照样会对target强引用，但是此时的target变成Timer类对象。因为类对象生命周期与应用程序一置的，不受引用计数限制，所以没关系。</p><p>这种类型的“保留环”问题很隐蔽，因此很有分析与记录价值，与君共享。</p><p><a href="https://github.com/icebergcwp1990/ICBTimerWithoutRetainCycle">GitHub Demo</a></p><p><em>注：这个解决方案参考了Effective Objective-C 2.0一书中第52条，有兴趣的同学可以自行查阅。</em></p>]]></content>
      
      
      <categories>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于爱的一点想法</title>
      <link href="/2017/01/08/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1/"/>
      <url>/2017/01/08/%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前不久又翻读了《少有人走得路》这本书，并将其置于枕边，每天晚上睡觉之前或是蹲马桶的时候看上几个章节，那种感觉妙不可言。这本书从来没有让我失望过，每看一次都收获不少，确实是一本值得读一辈子的好书。</p><h3 id="爱的定义"><a href="#爱的定义" class="headerlink" title="爱的定义"></a>爱的定义</h3><p>这次的阅读有一个论点让我深以为然，就是关于爱的定义。作者斯科特·派克是这样定义的：“爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。“ 爱，是一种神秘的现象，我个人觉得很难言明爱是什么，如何定义。如果有人问我：”你觉得爱是什么？“ 我很可能回答：”它是一个很奇妙的东西。“ 然而，当我在书中看到作者给出的定义时，觉得他完整的表达了我对于爱的理解。</p><p>爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。当我在付出爱的努力，不仅能让他人的心智成熟，自己也同样获益。真正意义上的爱，既是爱自己，也是爱他人。我始终坚信一个不爱自己的人是不可能爱别人的。一个缺乏自律的父母，不可能让孩子懂得什么是自我完善；一个自私的伴侣，不可能察觉另一半情绪细微变化和顾忌另一半的心理感受。显然，自私和缺乏自律就是一种心智不成熟的表现，换言之就是不自爱的结果。这也许和大多数人理解的爱不太一样，以为爱就只是给予和付出。殊不知，真正的爱是自我完善，也是帮助他人完善。它意味着持续地努力，超越自我界限。</p><p>对于爱最大的误解，莫过于将男女恋爱理解为爱。我以前也是这样理解，其实我错了。</p><h3 id="坠入情网"><a href="#坠入情网" class="headerlink" title="坠入情网"></a>坠入情网</h3><p>提及爱这个字眼，相信很多人都会想到男女恋爱，尤其是把坠入情网当成爱。坠入情网的人，时常会把”我爱你“这样的句子挂在嘴边，以此表达爱意。然而，这只是一种主观愿望罢了。要了解坠入情网的本质，首先理解心理学上的”自我界限“。</p><p>何为”自我界限“？在新生婴儿的眼里，一切移动或静止的事物之间，他和周围的人之间，在单个个体和整个世界之间，没有任何界限和区别。随之年龄和认识的增长，他会发现他和世界不是一回事。他感觉饥饿，母亲不见得立刻出现；他想玩耍的时候，母亲未必能及时配合。他渐渐地意识到自己的意愿和母亲的行为完全是截然不同的两回事，这也就是自我意识的形成。通常，婴儿的自我意识能否健康发展，取决于同母亲的关系是否融洽。当婴儿意识到自己是一厢情愿的，不能主宰其他人的意愿，于是开始在自己和周围世界之间做出区分。慢慢地我们能区分出自己和外在世界更多的不同，认识到自己的局限性。这样的认知就是”自我界限“。</p><p>永远活在”自我界限“中，只会给人带来孤寂。对他们而已，世界充满险恶，自我界限是保护伞，孤独和寂寞反而能带来安全感。但是大部分人还是渴望摆脱寂寞，冲出自我界限的牢笼。坠入情网，就是表现之一，暂时性地摆脱寂寞。坠入情网意味着”自我界限“的某部分崩溃，使我们的自我与他人的自我合二为一。情感就像决堤的洪流，声势浩大地涌向所爱的人，于是寂寞消失了，取而代之的是难以言喻的狂喜。</p><p>显然，坠入情网是情感和心灵退化现象。与心爱的人在一起，跟童年时和父母相伴的记忆彼此呼应，让我们体会到幼年时无所不能的快感，似乎没有什么能够阻止我们实现愿望。然而，残酷的现实会像击溃两岁小孩的幻想一样击溃我们的爱情之梦。日常琐事和难题，容易让双方产生矛盾和冲突，对这种”爱“造成威胁甚至击溃。我们必须面对现实，学会真正的相知和相爱，以此来避免上述这种虚幻的爱。</p><p>坠入情网是自我界限暂时性崩溃的现象，只要客观条件允许，就会发生。而真正的爱是需要彼此付出努力的，是一种主观意愿。坠入情网的经历终结，自我界限会恢复原样。而真正的爱是对自我界限的扩充，而不是使其恢复原状。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>真正的爱不是过度依赖，也不是自我牺牲，更不是一种感觉，而是实际行动，是心智上地成长。在爱一个人之前，首先成为一个自爱的人，一个有趣的人，再和另外一半一起有趣下去。</p><p>如何成为一个有趣的人？还在努力中…</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StartFucks Coffee - 操蛋的咖啡</title>
      <link href="/2016/11/23/StartFucks%20Coffee%20-%20%E6%93%8D%E8%9B%8B%E7%9A%84%E5%92%96%E5%95%A1/"/>
      <url>/2016/11/23/StartFucks%20Coffee%20-%20%E6%93%8D%E8%9B%8B%E7%9A%84%E5%92%96%E5%95%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写了一天的代码，看着桌上冒着热气的白开水，想到第一次去星巴克的情景：傻傻地在柜台面子，看着各种咖啡名词，踌躇许久，最终点了一份中杯柠檬茶。那位服务员小胖妞无语中掺杂点鄙视的眼神，至今记忆犹新…</p></blockquote><p>身边的朋友喝咖啡的不少，咖啡这个词汇也经常萦绕耳旁：美剧中，喝咖啡已是日常；朋友聚会，问及他（她）们最爱的饮料，也是拿铁和卡布奇诺居多；特别的大学期间的坐我对面的师姐，感觉她对于喝咖啡跟喝水已经没多大区别，每一次浓浓的咖啡香从她的书桌散发出来，很难说我没有一丝要来一杯的冲动，不过，最终还是忍住了。</p><p>究其原因，一是我个人对咖啡的印象并不好，普遍观点认为长期喝咖啡对于身体健康和健身有不良影响，这种观点是否属实尚不能下定论。在此之前，我选择敬而远之。二是我狭隘的以为咖啡只有一种：苦咖啡，殊不知咖啡也是大有学问。其实我早该想到西方的咖啡应该和东方的茶一样，种类繁多，口味各异。只是先入为主的观念让我对咖啡已经失去了进一步了解的兴趣。</p><p>如今，终究是因为自尊心受到了伤害，决定整理一下关于咖啡的基本知识。更何况即便是不喝咖啡，也至少对它有一个基本的认识，这样才算得上公平。</p><p>网上已经有很多接受咖啡种类的文章，我只是顺手牵羊，秉着拿来主义，自己总结一下，加深印象。</p><p>咖啡大体上可以分为12种，其中浓缩咖啡（Espresso）最为根本，其他11种都是在Espresso的基础上添加其他的配料演变而成的花式咖啡。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-0.jpg" alt="12种咖啡的恩怨情仇"></p><p>通过上图，可以比较直观地感受这12种咖啡直接的关联。以下分别介绍：</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-1.jpg" alt="浓缩咖啡-玛奇朵-美式咖啡"></p><h3 id="浓缩咖啡（Espresso）"><a href="#浓缩咖啡（Espresso）" class="headerlink" title="浓缩咖啡（Espresso）"></a>浓缩咖啡（Espresso）</h3><p>浓缩咖啡，英文名为Espresso，Espresso是一个意大利单词，所以也叫意式浓缩咖啡，指的是一种用咖啡机在短时间内急速萃取的浓烈咖啡，几乎称得上是所有花式咖啡的基础，也是全世界咖啡馆的必备。Espresso很小杯，通常只有30毫升左右，味道很苦，表面浮着一层厚厚的油脂，会与一杯清水同上，可以选择加糖。这款是真正的咖啡爱好者和急需提神者的首选。</p><h3 id="玛奇朵（Espresso-Macchiato）"><a href="#玛奇朵（Espresso-Macchiato）" class="headerlink" title="玛奇朵（Espresso Macchiato）"></a>玛奇朵（Espresso Macchiato）</h3><p>Macchiato原文为意大利语，代表“印记、烙印”的意思，发音为“玛奇雅朵”，习惯称呼为玛奇朵。玛奇朵是在浓咖啡上加上薄薄一层热奶泡以保持咖啡温度，细腻香甜的奶泡能缓冲浓缩咖啡带来的苦涩冲击，想喝咖啡但又无法舍弃甜味的你，可以选择玛奇朵。经常会听到“焦糖玛奇朵”，据说这是星巴克的独创，其做法是在牛奶中加入香草糖浆，与Espresso咖啡混合，再于奶泡上覆盖一层焦糖，口味层次很丰富。</p><h3 id="美式咖啡（Americano）"><a href="#美式咖啡（Americano）" class="headerlink" title="美式咖啡（Americano）"></a>美式咖啡（Americano）</h3><p>很多咖啡馆的“当日咖啡”其实就是美式咖啡，这通常也是咖啡馆菜单上最便宜的一种。美式咖啡说白了，就是小半杯Esprssso兑上大半杯白开水，也有咖啡馆会使用滴滤式咖啡壶冲泡。美式咖啡味道淡、颜色浅，微酸微苦，但因为萃取时间长，所以咖啡因含量高。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-2.jpg" alt="拿铁-白咖啡-康宝蓝"></p><h3 id="拿铁（Caffe-Latte）"><a href="#拿铁（Caffe-Latte）" class="headerlink" title="拿铁（Caffè Latte）"></a>拿铁（Caffè Latte）</h3><p>拿铁是Espresso与牛奶的经典混合，杯底先倒入少量Espresso，然后加入大量牛奶，顶端是浓密的一层泡沫，可以在奶泡上拉出各种各样的图案。经典的拿铁是70%牛奶+20%奶沫+10%咖啡，受法国人喜爱的欧蕾咖啡，是将牛奶和咖啡同时倒入杯中，两者在第一时间碰撞、混合，上加两勺打成泡沫的奶油，这在法国人的早餐中十分常见，几乎是国民饮料。</p><h3 id="白咖啡（Flat-White）"><a href="#白咖啡（Flat-White）" class="headerlink" title="白咖啡（Flat White）"></a>白咖啡（Flat White）</h3><p>关于白咖啡网上有两种说法：</p><ol><li><p>白咖啡并不是马来西亚的那个特产，而是没有奶泡的拿铁。</p></li><li><p>马来西亚土特产，约有100多年的历史。白咖啡并不是指咖啡的颜色是白色的，而是采用特等咖啡豆及特级脱脂奶精原料，经特殊工艺加工后得到的咖啡，甘醇芳香不伤肠胃，保留了咖啡原有的色泽和香味，颜色比普通咖啡更清淡柔和，故得名为白咖啡。</p></li></ol><h3 id="康宝蓝（Espresso-Con-Panna）"><a href="#康宝蓝（Espresso-Con-Panna）" class="headerlink" title="康宝蓝（Espresso Con Panna）"></a>康宝蓝（Espresso Con Panna）</h3><p>意大利语中，Con是搅拌，Panna是生奶油，康宝蓝即意式浓缩咖啡加上鲜奶油。有一种说法是，正宗的康宝蓝要配一颗巧克力或太妃糖，先将巧克力或太妃糖含在嘴里，再喝咖啡，让美味一起在口中绽放。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-3.jpg" alt="布雷维-卡布奇诺-摩卡"></p><h3 id="布雷维-x2F-半拿铁（Cafe-Breve）"><a href="#布雷维-x2F-半拿铁（Cafe-Breve）" class="headerlink" title="布雷维/半拿铁（Cafe Breve）"></a>布雷维/半拿铁（Cafe Breve）</h3><p>很像拿铁，不同是加入了的不是牛奶，而是半牛奶、半奶油的混合物，有时会再加少许奶泡。公认的配方是：1份浓缩咖啡+0.75份热牛奶+0.75份鲜奶油+0.5份奶泡。</p><h3 id="卡布奇诺（Cappuccino）"><a href="#卡布奇诺（Cappuccino）" class="headerlink" title="卡布奇诺（Cappuccino）"></a>卡布奇诺（Cappuccino）</h3><p>卡布奇诺和拿铁咖啡的成分一样，都是Espresso+牛奶+奶泡，不同之处仅在于卡布奇诺奶泡比牛奶多，拿铁则是牛奶比奶泡多。传统的卡布奇诺咖啡是三分之一浓缩咖啡，三分之一蒸汽牛奶和三分之一泡沫牛奶。同等价位的卡布奇诺，通常比拿铁要小杯，但咖啡味更浓郁。<br>卡布奇诺是意大利咖啡与牛奶的经典之作，咖啡的颜色就像卡布奇诺教会修士深褐色外衣上覆的头巾一样，咖啡因此得名。可根据自己口味调整牛奶与咖啡的比例，牛奶味重称为湿卡布奇诺，咖啡味重称为干卡布奇诺。</p><h3 id="摩卡（Caffe-Mocha）"><a href="#摩卡（Caffe-Mocha）" class="headerlink" title="摩卡（Caffè Mocha）"></a>摩卡（Caffè Mocha）</h3><p>一种最古老的咖啡，得名于著名的摩卡港。摩卡的配方成分就相对比较复杂，在Espresso和牛奶的基础上，还有巧克力酱，顶端不是奶泡，而是打发的鲜奶油，还往往会挤上巧克力酱，或者撒上可可粉、肉桂粉，别有一番风味。由于“内容丰富”，通常售价较高，也比较大杯。巧克力和奶油都有甜味，因此摩卡咖啡是苦甜结合的典范。</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/daily/coffee-4.jpg" alt="焦糖玛奇朵-爱尔兰咖啡-维也纳咖啡"></p><h3 id="焦糖玛奇朵（Caramel-Macchiato）"><a href="#焦糖玛奇朵（Caramel-Macchiato）" class="headerlink" title="焦糖玛奇朵（Caramel Macchiato）"></a>焦糖玛奇朵（Caramel Macchiato）</h3><p>即加了焦糖的玛奇朵，是在香浓热牛奶上加入浓缩咖啡、香草，最后淋上纯正焦糖而制成的饮品，特点是在一杯饮品里可以喝到三种不同的口味。</p><h3 id="爱尔兰咖啡（Irish-Coffee）"><a href="#爱尔兰咖啡（Irish-Coffee）" class="headerlink" title="爱尔兰咖啡（Irish Coffee）"></a>爱尔兰咖啡（Irish Coffee）</h3><p>爱尔兰咖啡（Irish Coffee）是一款鸡尾酒，是以爱尔兰威士忌为基酒，配以咖啡为辅料，调制而成的一款鸡尾酒。据说爱尔兰咖啡背后还有一段浪漫的爱情故事，不过我觉得就像卡农背后的爱情故事一样，不必较真。</p><h3 id="维也纳咖啡（Viennese-Coffee）"><a href="#维也纳咖啡（Viennese-Coffee）" class="headerlink" title="维也纳咖啡（Viennese Coffee）"></a>维也纳咖啡（Viennese Coffee）</h3><p>奥地利最著名的咖啡，是一个名叫爱因·舒伯纳的马车夫发明的，也许是由于这个原因，今天，人们偶尔也会称维也纳咖啡为“单头马车”。在温热的咖啡杯底部撒上薄薄一层砂糖或细冰糖，接着向杯中倒入滚烫而且偏浓的黑咖啡，最后在咖啡表面装饰两勺冷的新鲜奶油，一杯维也纳咖啡就做好了。</p><p>综上，发现除了浓缩咖啡和美式咖啡之外，其他咖啡的含糖量都不低。公司附近就有一家星巴克，实践是检验真理的唯一标准。一个星期上一种咖啡，也够我玩三个月了。</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coffee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C中布尔类型</title>
      <link href="/2016/10/15/Objective-C%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
      <url>/2016/10/15/Objective-C%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p> Objective-C中的BOOL类型在iWatch和64位iOS上的原始类型为bool，而在其它情况下是signed char。</p><p>用@encode去看看BOOL的类型串：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 64位iOS系统："B"</span></span><br><span class="line"><span class="keyword">@encode</span>(<span class="built_in">BOOL</span>) <span class="comment">// 32位iOS系统，32/64位OS X："c"</span></span><br></pre></td></tr></tbody></table></figure><p>众所周知，在C\C++语言中bool类型中的两个常量false为0，true为1，且非0值都被认为true。Objective-C是建立在C++基础的面相对象的语言，因此bool的定义应该也是如此。</p><p>下面对两种情况分别讨论：</p><p><strong>typeof BOOL bool</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：This is YES。说明变量被赋值为1，而非数字7。</p><p><strong>typeof BOOL signed char</strong></p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == <span class="literal">YES</span> )</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"This is YES."</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"This is NO."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：This is NO。说明变量被赋值为数字7。</p><p>综上所述，在Objective-C中进行布尔比较时，不建议直接将布尔变量和YES或者true做比较，即：if( a == YES )。但是可以和NO或者false做比较，即：if( a != NO )，也可以写成if( a )或者if( !a )的形式。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用PlistBuddy命令动态修改APP名称</title>
      <link href="/2016/10/15/%E4%BD%BF%E7%94%A8PlistBuddy%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9APP%E5%90%8D%E7%A7%B0/"/>
      <url>/2016/10/15/%E4%BD%BF%E7%94%A8PlistBuddy%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9APP%E5%90%8D%E7%A7%B0/</url>
      
        <content type="html"><![CDATA[<p>当一个工程里面包含多个target且每个target都有本地化的名称，一般做法是为每个target配备一个InfoList.strings文件。随着target数量和支持的语种增多，InfoList.strings文件数量也增加，更改和管理target名称也会变得复杂。</p><p>我们可以在工程里面只保留一个InfoList.strings文件用于显示当前编译的target本地化名称，并且将所有target的本地化名称用一个plist文件统一管理，然后使用shell脚本和PlistBuddy命令在编译阶段动态修改target名称。以下是具体实现：</p><p>假设工程中有4个target，本地化需求为英语（en）和西班牙语言（es）。</p><p>1、在Xcode中创建一个名为ProductName.plist文件，并保存至工程根目录。注意：这个文件不需要和任何target关联。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_1<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_1_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_1_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_2<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_2_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_2_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_3<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_3_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_3_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>ProductId_4<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>en<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_4_EnglistName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>es<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ProductId_4_SpanishName<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、Info.plist中有个叫CFBundleDisplayName的key决定APP的名称，创建一个InfoList.string文件并关联所有的target。在InfoList.string文件修改CFBundleDisplayName即可更改APP名称,格式如下所示：</p><p>CFBundleDisplayName=”xxxxxxxxxx”;</p><p>3、在project的“Build Settings”中新建一个“Use_Defined Setting”命名为MY_PRODUCTID，然后为每一个target设置对应的ID。此处分别为四个target命名为：ProductId_1、ProductId_2、ProductId_3、ProductId_4。</p><p>4、在工程的“build Phases”界面中新建一个脚本块，脚本内容如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#PRODUCT_NAEMS_FILE_PATH的路径</span></span><br><span class="line">PRODUCT_NAEMS_FILE_PATH=<span class="string">"<span class="variable">${SRCROOT}</span>/PRODUCT_NAEMS_FILE_PATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取对应ProductId的plist</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"print <span class="variable">${MY_PRODUCTID}</span>"</span> -x <span class="string">"<span class="variable">${PRODUCT_NAEMS_FILE_PATH}</span>"</span> &gt; <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取ProductId.plist对应的本地化名称</span></span><br><span class="line">EN_NAME=$(/usr/libexec/PlistBuddy -c <span class="string">"print en"</span> <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span> )</span><br><span class="line">ES_NAME=$(/usr/libexec/PlistBuddy -c <span class="string">"print es"</span> <span class="string">"/var/tmp/<span class="variable">${MY_PRODUCTID}</span>.plist"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置InfoPlist.strings对应的本地化文件中的CFBundleDisplayName字段值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CFBundleDisplayName=\"<span class="variable">${EN_NAME}</span>\";"</span> &gt; <span class="string">"<span class="variable">${SRCROOT}</span>/en.lproj/InfoPlist.strings"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CFBundleDisplayName=\"<span class="variable">${ES_NAME}</span>\";"</span> &gt; <span class="string">"<span class="variable">${SRCROOT}</span>/es.lproj/InfoPlist.strings"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>5、编译target，即可在InfoPlist.strings看到对应的本地化名称。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PlistBuddy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>副词能否修辞名词？</title>
      <link href="/2016/09/24/%E5%89%AF%E8%AF%8D%E8%83%BD%E5%90%A6%E4%BF%AE%E8%BE%9E%E5%90%8D%E8%AF%8D/"/>
      <url>/2016/09/24/%E5%89%AF%E8%AF%8D%E8%83%BD%E5%90%A6%E4%BF%AE%E8%BE%9E%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前知乎上看到一提问，大意是：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？最近恰好在旋元佑先生的《文法俱乐部》一书中找到了合理的解释，借此机会梳理一下这个知识点。</p></blockquote><p>结合上述问题：The Lamb Astray中的Astray是形容词还是副词？副词是否能修辞名词？，可以从两个方面进行解答：</p><ol><li><p>The Lamb Astray中的Astray是形容词词性，属于形容词后置的情况</p></li><li><p>副词可以修辞名词</p></li></ol><h3 id="形容词后置"><a href="#形容词后置" class="headerlink" title="形容词后置"></a>形容词后置</h3><p>形容词常见的所处位置包括名词片语、表语、主【宾】语补语，此外还有一个位置：名词后面，属于形容词后置的情况。</p><p>在以下三种情况，形容词需要后置：</p><ol><li><p>复合名词后面：</p><p> 类似someone这样的符合名词，因为限定词 some 和 名词 one 组合成一个词，原本名词片语中在限定词和名词之间存放形容的位置被挤压掉了，因此只能把形容词置于名词之后。</p><p> 比如：</p><ul><li>someone else //其他人</li><li>someone important //某些重要的人</li></ul></li><li><p>一部分a-开头的形容词：</p><p> 有一部分a-开头的形容词通常放在补语或者表语的位置，也可以放在名词片语后面。</p><p> 比如：</p><ul><li>Jane and her mother alike are teather. //珍和她妈妈一样是老师</li><li>Tom alone is coming. //只有汤姆要来</li><li>wood adrift //漂流的木头</li></ul></li><li><p>外来词或者惯用法：</p><p> 英语中习惯把形容词放在名词前面，但是有些语言中例如法文，形容词是放在名词后面的。因此一些外来语或者惯用语，都要把形容词放在名词后面。</p><p> 比如：</p><ul><li>Secretary General //秘书长</li><li>Poet Laureate //桂冠诗人</li><li>Aisa Minor //小亚细亚</li><li>heir apparent //合法继承人</li></ul></li></ol><h3 id="副词修辞名词"><a href="#副词修辞名词" class="headerlink" title="副词修辞名词"></a>副词修辞名词</h3><p>正如一般文法书上所说，一般情况下形容词修辞名词而副词则用于修辞除了名词以外的其他词类，包括形容词、动词和副词。这种说法基本上成立，但是也有特殊情况。</p><p>存在一类表示强调功能的副词，可以修辞名词、动词、形容词和副词，修辞范围很广。也正因为如此，所以这类副词只能放在修饰词前面，确保修辞对象在其后面，以免出现歧义。</p><p>这一类副词又可以细分为三种：</p><ol><li><p>强调范围的副词</p><p> 典型代表：only, merely, also, especially, particularly, even等</p><p> 以Only举例：</p><ul><li>I heard about the accident yesterday.  //我昨天听说了这件意外</li><li>Only I heard about the accident yesterday. //只有我听说了…</li><li>I only herad about the accident yesterday. //只是听说，并没有看到</li><li>I heard about only the accident yesterday. //昨天全在听人在谈论这件意外</li><li>I heard about the accident only yesterday. //直到昨天才听说</li></ul><p> 这几个句子里only分别修饰了代名词I、动词heard、名词the accident和时间副词yesterday，都是当副词使用。</p></li><li><p>强调语气的副词</p><p> 这是最典型的副词，同样也可以修饰名词在内的四种主要词类。</p><p> 举例如下：</p><ul><li>He is very much his father’s son.  //他和他爸爸一个调调</li><li>You’re utterly insane! //你是完完全全疯了</li><li>I badly need a drink.  //我急需来一杯</li></ul></li><li><p>程度副词</p><p> 这一类副词和加强语气的副词很像，但是程度副词是用来做有几成的表示，而非加强语气。所以，如果把加强语气的副词，只是语气变弱，意思不会变。但是如果拿掉程度副词，意思就可能发生改变。</p><p> 举例：</p><ul><li>The project is almost finished. //项目已经完成的差不多了。<br> ps:上面的句子如果去掉almost，这句话的意思完全变了</li></ul></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>旋元佑先生的《文法俱乐部》是一本不可多得的文法书，它区别于传统文法书的教条式+填鸭式的讲解方式，而是追本溯源，从理解本质和语言使用的角度为读者拨开文法的迷雾。    </p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘dispatch_once的内部实现</title>
      <link href="/2016/08/08/%E6%8F%AD%E7%A7%98dispatch_once/"/>
      <url>/2016/08/08/%E6%8F%AD%E7%A7%98dispatch_once/</url>
      
        <content type="html"><![CDATA[<p>这是一篇译文，原文<a href="https://www.mikeash.com/pyblog/friday-qa-2014-06-06-secrets-of-dispatch_once.html">Secrets of dispatch</a>的作者是Mike Ash大神。在拜读这篇文章之后，颇有收获，不得不感叹Mike Ash专业知识的深度与广度。因此，我想试着进行翻译以加深理解。</p><p><strong>以下是原文</strong></p><p>一位名为Paul Kim的读者向我推荐了Micheal Tsai的一篇关于“让dispatch_once执行更快”的博客。虽然dispatch_once源代码中的注释精彩且详实，但是它并没有深入剖析那些让人着迷的细节。因为这是我最喜欢研究的方面之一，所以今天的文章我将进行深入地探究dispatch_once内部逻辑和实现原理。</p><h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><p>dispatch_once函数顾名思义，它只执行一次且唯一的一次。函数接收两个参数，第一个参数是一个predicate，用于跟踪和保证函数的“一次性”；第二个参数是一个block，在函数第一次被调用时执行。调用方式如下所示：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate , ^{</span><br><span class="line"><span class="comment">//执行一次性的任务</span></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个函数很适用于共享状态的“懒初始化”，适用范围包括全局字典、单例实体、缓存或者其他任何需要在第一次执行时进行配置的地方。</p><p>在只有单线程的环境中，这种调用方式显得有些繁琐，用一个简单的if语句就能取而代之。然而，我们现在面临的都是多线程的运行环境，且diaspatch_once是线程安全的。这就保证了即使多个线程同时调用dispatch_once函数，函数也只执行一个block，并且所有线程直到block中的任务执行结束且dispatch_once退出之前都会处于阻塞状态。尽管你自己实现一个类似的函数不是很难，但是dispatch_once函数执行速度相当之快，并且实现的难度很大。</p><h4 id="单线程版本"><a href="#单线程版本" class="headerlink" title="单线程版本"></a>单线程版本</h4><p>让我们先看一个这个函数精简后的单线程版本。虽然这个版本没有实用性，但是让我们对这个函数有一个具体的视觉感官。注意到dispatch_once_t只是一个long整型，且初始化为0，根据实现被赋予不同的含义。以下是实现：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SimpleOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!*predicate)</span><br><span class="line">{</span><br><span class="line">block();</span><br><span class="line">*predicate = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现很简单：如果predicate是0，执行block且更新predicate的值为1。后续的函数调用会发现predicate未非0值便不会重复执行block。如果不是因为在多线程环境是不安全的，这完全就是我们想要的结果。糟糕的是，如果两个线程可能同时访问if语句，会导致block被调用两次。很不幸，这种情况时有发生，因此，让这份代码变成线程安全意味着一次实质性的成功。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>当谈及dispatch_once的性能时，主要有以下三种不同的情景：</p><p>1、第一次调用dispatch_once时，指定一个predicate，并执行block.<br>2、在第一次调用dispatch_once之后且block未执行完之前，后续调用线程必须等待直到block执行完成。<br>3、在第一次调用dispatch_once且执行完成之后，后续调用不需要等待而是立即执行。</p><p>情景1基本上不影响性能，毕竟只执行一次，只要block执行速度不是太慢。</p><p>情景2同样不太影响性能。这个情况可能潜在地发生好几次，但是只有在block未执行完才会发生。大多数情况，这种情况几乎不会发生。如果发生了也可能是仅仅出现一次。甚至在极端测试下：很多线程同时调用dispatch_once并且block执行时间很长，后续处于等待的调用也局限在几千个以内。这些后续调用线程全都必须等待block执行完成，所以即使这些线程在等待过程中耗费了一些不必要的CPU时间也是无关紧要的。</p><p>情景3则是性能高低的关键所在。这种性质的调用可能在程序中潜在发生成千上万次。我们想通过dispatch_once来保护那些一次性运算，运算结果被作为调用的返回值。理想情况下，dispatch_once的性能应该可以与直接读取一个提前初始化好的全局变量的性能媲美。换言之，一旦你面临情景3，我们想让下面两个代码块执行的效率是一样的。</p><p>代码段1：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> gObject;</span><br><span class="line"><span class="keyword">void</span> Compute(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">gObject = ....;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> Fetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> gObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码段2：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> DispatchFetch(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate, ^{</span><br><span class="line">            object = ...;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在被编译器内联处理和优化之后，SimpleOnce函数的执行效率接近DispatchFetch函数。在我电脑上测试，DispatchFetch函数执行时间为0.5纳秒。这无疑是线程安全版本中的黄金标准。</p><p>如何自己实现一个的dispatch_once版本，关键在于确保线程安全，以下列出几种方式：</p><h4 id="使用线程锁"><a href="#使用线程锁" class="headerlink" title="使用线程锁"></a>使用线程锁</h4><p>常规的线程安全的做法是在共享数据访问前后添加锁。因为是示例代码，我决定只用一个单一的全局锁变量来做。代码中使用一个静态线程锁变量pthread_mutex_t来保护predicate的线程安全。在实际的项目中，随着函数被多个不同的类调用，伴随着很多不同的predicate变量，这将会是一个糟糕的设计。因为每一个互不关联的predicate变量必须一直等待当前被保护的predicate解锁才能获得执行机会。作为一个快速测试，这里我仅仅只测试一个predicate的情况。这份代码除了加了锁之外与前面的SimpleOnce函数没有区别：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LockedOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">            block();</span><br><span class="line">            *predicate = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这段代码是线程安全的，但不幸的是执行速度太慢。在我的电脑上测试结果为每次调用需要30纳秒，相较于上述0.5纳秒的版本实在差太远。线程锁已经算很快的了，但不属于纳秒级别的。</p><h4 id="使用自旋锁"><a href="#使用自旋锁" class="headerlink" title="使用自旋锁"></a>使用自旋锁</h4><p>自旋锁是一种试图将额外的开销降到最低的锁。顾名思义，自旋锁在处于需要等待的时候拥有“自旋”的功能，不断地轮询临锁的状态查看是否已经解锁。一般的锁都会配合操作系统休眠正在等待的线程，等解锁之后再唤醒所在的线程。这种锁虽然节省了CPU时间，但是这种协调休眠的机制也是有代价的。自旋锁不会休眠等待线程，因此在处于等待解锁的情况下节省了很多时间，付出的代价则是当多个线程试图获得自旋锁时效率会比较低。</p><p>MacOS X提供了<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/spinlock.3.html">一套便利的自旋锁API</a>名为OSSpinLock.使用OSSinLock实现LockedOnce只需要在原有的基础修改几个名称：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SpinlockOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">       <span class="keyword">static</span> OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line">       OSSpinLockLock(&amp;lock);</span><br><span class="line">       <span class="keyword">if</span>(!*predicate) {</span><br><span class="line">           block();</span><br><span class="line">           *predicate = <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">       OSSpinLockUnlock(&amp;lock);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>这次有了相当大的提升。在我电脑上测试结果为每次调用需要6.5纳秒，远好于pthread_mutex版本的每次调用30纳秒。然而于dispatch_once比起来还是太慢了。</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作是底层CPU级别的操作且即使没有锁也一直都是线程安全。从技术层面来说，它们使用的硬件锁。使用锁会带来额外的开销，直接使用原子操作可以带来性能上的提升。多线程编程没有锁可能会显得很别捏，所以除非你真的需要原子操作，否则这不是明智的选择。我们现在讨论的是一个可能会被频繁使用的系统库，因此也许值得添加原子操作。</p><p>原子操作创建锁的过程是“比较并交换”。这是一个类似于下面代码的简单操作：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> CompareAndSwap(<span class="keyword">long</span> *ptr, <span class="keyword">long</span> testValue, <span class="keyword">long</span> newValue) {</span><br><span class="line"><span class="keyword">if</span>(*ptr ==  testValue) {</span><br><span class="line">*ptr = newValue;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总而言之，函数CompareAndSwap的功能用来测试内存的一个地址是否存储着一个特定的值，如果是则用新的值替换原有的值，返回结果表示匹配成功与否。因为“比较并交换”是一个CPU级的原子指令，所以即使有多个线程都试着对同一个内存区域进行“比较并交换”的操作都能确保其中只有一个操作能够成功。</p><p>LockedOnce的这个版本的实现策略是对predicate赋予三个不同的值。0表示函数还未被调用过；1表示函数block正处于执行状态，后续调用线程则处于等待状态；2表示block执行完成且释放阻塞的等待线程并返回结果。</p><p>“比较并交换”原子操作将被用于检测predicate的值是否为0，如果是则自动更新predicate为1。一旦原子操作返回的是YES，意味着当前线程是第一个调用线程，并开始唯一一次地block执行。在block执行完成后更新predicate的值为2作为标识.</p><p>如果“比较并交换”原子操作执行失败意味着当前线程不是第一个调用者，然后线程进入一个循环，不断地检测predicate的值是否更新为2，直到predicate更新为2才退出循环。这将导致线程在block执行结束之前一直处于等待状态。</p><p>以下是这个版本的函数的具体：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line"><span class="comment">//将predicate指针转换成volatile指针，</span></span><br><span class="line"><span class="comment">//以告知编译器这个变量的值可能在函数执行过程中被其他线程更改，</span></span><br><span class="line"><span class="comment">//必须每次从内存地址取值，而非寄存器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用“比较并交换”原子操作。</span></span><br><span class="line"><span class="comment">//Gcc编译器和clang编译器均提供了各种以_sync开头的内置函数以实现原子操作。</span></span><br><span class="line"><span class="comment">//下面的函数对predicate执行了“比较并交换”的原子操作，</span></span><br><span class="line"><span class="comment">//检测predicate的值是否为0，如果是则更新为1</span></span><br><span class="line"><span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line"><span class="comment">//执行block</span></span><br><span class="line">block();</span><br><span class="line"><span class="comment">//一旦block执行完成，更新predicate的值为2用以告知当前正在等待的调用线程以及未来的调用者block已经执行完成。</span></span><br><span class="line"><span class="comment">//然而，考虑到CPU的优化机制，我们使用内存屏障以确保volatilePredicate值的读书顺序是正确的。</span></span><br><span class="line"><span class="comment">//使用内置函数__sync_synchronize在此出设置内存屏障，</span></span><br><span class="line"><span class="comment">//确保volatilePredicate在block执行完后立即更新为2，且在此之前不可读。</span></span><br><span class="line">__sync_synchronize();</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">*volatilePredicate = <span class="number">2</span>;</span><br><span class="line">}<span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//等待线程循环检测</span></span><br><span class="line"><span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>);</span><br><span class="line"><span class="comment">//线程返回之前设置内存屏障，匹配if语句中的内存屏障设置，保证volatilePredicate读取一致性</span></span><br><span class="line">__sync_synchronize();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码满足需求且是线程安全的，但是性能一般。在我电脑上每次调用时间为20纳秒，明显高于自旋锁版本。</p><h4 id="提前预判"><a href="#提前预判" class="headerlink" title="提前预判"></a>提前预判</h4><p>这里有一个显而易见的优化可以添加到原子操作的版本中。因为通常情况下都是predicate的值已经是2，在函数最开始的地方加一个判断语句，可以在大多数情况下加快函数执行速度：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>) {</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">            __sync_synchronize();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这个版本的执行效率有相当大的提升，大约是调用一次11.5纳秒。然而，对比与dispatch_once版本还是相去甚远，甚至不如自旋锁版本。</p><p>设置内存屏障有额外的开销，这也是为什么这个版本的执行速度比dispatch_once慢的原因所在。至于为什么会比自旋锁版本慢，是因为代码中设置了不同类型的内存屏障。__sync_synchronize函数会产生一个mfence的指令，这个指令是可能是最耗费资源的指令之一，然而OSSpinLock使用的是一个效率更高的指令。我们可以尝试不同的内存屏障以到达更好的效果，但是很明显代码最终的执行速度未达到我们预期结果，因为我打算弃用这种方法。</p><h4 id="非线程安全的提前预判"><a href="#非线程安全的提前预判" class="headerlink" title="非线程安全的提前预判"></a>非线程安全的提前预判</h4><p>这个版本与上面的版本很类似，只不过将内存屏障移除了：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UnsafeEarlyBailoutAtomicBuiltinsOnce(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block) {</span><br><span class="line">        <span class="keyword">if</span>(*predicate == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="built_in">dispatch_once_t</span> *volatilePredicate = predicate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(__sync_bool_compare_and_swap(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            block();</span><br><span class="line">            *volatilePredicate = <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span>(*volatilePredicate != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>不出意外，这个版本的执行速度与SimpleOnce一样都是0.5纳秒。因为*predicate == 2的适用于大多数情况，差不多每次调用都是检测predicate的值并返回。这个版本除了第一次执行block之外，几乎与SimpleOnce函数一样。</p><p>正如函数名所示，这是一个非线程安全版本，缺少了内存屏障导致线程不安全。原因何在？</p><h4 id="CPU流水线执行方式"><a href="#CPU流水线执行方式" class="headerlink" title="CPU流水线执行方式"></a>CPU流水线执行方式</h4><p>我们可以将CPU想象成一个简单的机器，我们告诉它做什么，它就做什么。如此反复直到天荒地老。</p><p>曾经有一段时间确实如此。老版的CPU的工作方式很简单，一眼一板。不幸的是，这种方式简单，容易且成本低，但是执行效率低。根据摩尔定律，CPU内置的晶体管成指数增长。8086CPU内置了大约29000个晶体管。一个英特尔处理器CPU集成了超过十亿的晶体管。</p><p>根据市场需求决定了CPU拥有更好的效率，现在的CPU集成了越来越多的晶体管旨在让电脑运行速度更快。</p><p>这里面有很多技巧让CPU执行的更快。其中一种就是流水线。执行单一的CPU指令，分成多个小步骤：</p><ol><li>从内存加载指令</li><li>指令解码（分析指令解析包含哪些运算操作）</li><li>加载输入数据</li><li>结合输入执行运算</li><li>保存输出数据</li></ol><p>在一个早期的CPU，上述流程执行步骤如下所示：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加载指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">加载下一个指令</span><br><span class="line">解码</span><br><span class="line">加载数据</span><br><span class="line">运算</span><br><span class="line">保存输出</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在一个流水线型的CPU，执行步骤则如下所示：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加载指令  </span><br><span class="line">解码加载指令</span><br><span class="line">加载数据解码加载指令</span><br><span class="line">运算加载数据解码</span><br><span class="line">保存输出运算加载数据</span><br><span class="line">保存输出运算</span><br><span class="line">保存输出</span><br></pre></td></tr></tbody></table></figure><p>这种方式执行速度快很多。随着CPU中的晶体管数量越来越多，CPU内部结构也越来越复杂，同步执行的指令也越来越多。<br>更有甚者，如果可以让速度更快，指令的执行顺序会被完全打乱。不同于上述简单的例子，真实情况下，指令更为复杂以及变量更多。</p><p>代码执行的顺序并不以总是与代码本身的顺序一致的，比如下面的代码：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p>CPU可能会先写入Y变量的值。有些情况下编译器也会对语法重新排序，即便你屏蔽了编译器的行为，CPU仍然会乱序执行。如果是多核CPU，在其他的CPU看了写入的顺序是乱序的。即使是按代码顺序写入的，其他的CPU也会乱序读取。综合考虑，其它的线程在读取x和y的值时会发现y的值已经改变而x还是原来的值。</p><p>在你需要这些值必须按照既定的顺序写入的时候，内存屏障就派上用场了。设置内存屏障以确保上述代码中x的值先被更新：</p><ul><li>x = 1;</li><li>memory_barrier();</li><li>y = 2;</li></ul><p>同样地，内存屏障可以确保读的顺序：</p><ul><li>use(x);</li><li>memory_barrier();</li><li>use(y);</li></ul><p>然而，因为内存屏障的主要功能导致CPU的执行速度，所以自然而然影响性能。</p><p>对于dispatch_once来说，代码必须按照既定的顺序执行，因此必须设置内存屏障。但是，内存屏障会导致代码效率低下，所以为了避免额外的开销，我们想办法避免设置内存屏障。</p><h4 id="CPU的分支预测和推测性执行"><a href="#CPU的分支预测和推测性执行" class="headerlink" title="CPU的分支预测和推测性执行"></a>CPU的分支预测和推测性执行</h4><p>流水线和乱序工作模式适用于一系列线性执行的指令，但是对于添加分支语句则变得麻烦。CPU在分支语句执行完之前不知道下一步该执行什么指令，因此不得不停止运行等待前面的分支语句结束再重新运行。这就是所谓的pipeline stall，在一定程度上影响CPU性能。</p><p>为了弥补pipeline stall带了的性能损失，CPU加入了推测性执行。当CPU遇到一个分支语句则会进行分支预测判断哪一个分支可能被执行。现在的CPU配置精密的分支预判硬件，准确率在90%以上。在做出预判之后，CPU开始执行假设的分支中的代码块，而不是等待分支语句的结果。如果分支预判是正确的则继续后续执行。如果预判错误则清空推测执行结果重新执行另外一个分支代码块。</p><p>这种情况被用在了dispatch_once的读取端，这也是我们期望执行速度越快越好的地方。dispatch_once中有一个判断predicate的值得分支语句。CPU应该会预判并执行else分支，因为这个大多数情况下会执行的分支，即绕过block执行然后立即返回结果。在推测性执行过程中，CPU可能会从内存中加载那些后续需要但是还未被其他线程初始化的变量。如果分支预判是正确的，CPU会使用未初始化的值进行推测性执行。</p><h4 id="非对称屏障"><a href="#非对称屏障" class="headerlink" title="非对称屏障"></a>非对称屏障</h4><p>内存屏障一般都是需要对称的：在写的一端确保按照正确的顺序写入，在读的一端确保按照正确的顺序读取。然而，我们需要非对称屏障来满足我们的性能需求：我们可以容忍写入端的速度缓慢，但是让读的速度越快越好。</p><p>这个技巧用来防范推测性执行导致的问题。当分支预判是错误的，推测性执行的结果会被弃用。如果dispatch_once可以在初始化完成之后强制确定CPU的分支预判，这个问题则可以被避免。</p><p>此处有一个间隔时间，即最初的推测性执行到条件语句执行结束之间的间隔时间。间隔具体的时间因CPU而异，但是最多几十个CPU周期的时间。</p><p>在英特尔CPU中，dispatch_once使用spuid指令到达上述目的。cpuid指令主要是用于获取CPU的ID和功能等信息，但是也可以强行序列化指令流并需要耗费几百个CPU周期的时间。</p><p>在dispatch_once的源代码中，你会发现在读的一端没有使用内存屏障：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_<span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate, dispatch_block_t block)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) {</span><br><span class="line">        <span class="built_in">dispatch_once</span>(predicate, block);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></tbody></table></figure><p>这段代码位于头文件中，并内联只调用者的代码块。DISPATCH_EXPECT宏告诉编译器去告知CPU：*predicate = ~0l是更有可能发生的分支。这可以提高分支预判的准确性，继而提升执行效率。基本上，这里只有一个普通的if语句，没有设置任何屏障。调用dispatch_once的执行速度接近0.5纳秒的黄金标准。</p><p>在dispatch_once实现文件中可以看到写入端的实现，在block执行后立即执行了下面的宏：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_atomic_maximally_synchronizing_barrier();</span><br></pre></td></tr></tbody></table></figure><p>在英特尔的CPU中，这个宏使用了cpuid指令，在其他的CPU框架中也会产生类似的指令。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>多线程是最奇怪和复杂的地方，现代的CPU在背后做了很多不为认知的事情。内存屏障允许你告知硬件按照你需要的顺序执行代码，但是相应的需要在性能上做出牺牲。dispatch_once有着独一无二的需求，让CPU不走寻常路：在相关的内存写入完成之前牺牲足够多的等待时间，但是确保每一次读取都是高效安全的且不需要额外的内存屏障。            </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVO的缺陷</title>
      <link href="/2015/05/10/KVO%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
      <url>/2015/05/10/KVO%E7%9A%84%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习和研究Cocoa库的KVO特性，期间发现大神Mike Ash的一篇关于讲述KVO缺陷的博客，觉得很有学习价值，遂想试着翻译以加深理解。</p></blockquote><p><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html">原文地址</a></p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>Cocoa的KVO特性强大和实用。可惜它的API真的有点糟糕，一些实现方式存在着固有的缺陷。我想探讨一下缺陷所在以及提供一套完善的方案。</p><h5 id="缺陷何在？"><a href="#缺陷何在？" class="headerlink" title="缺陷何在？"></a>缺陷何在？</h5><p>KVO的API中存在三个主要的问题，全部都与类的多重继承结构注册监听器相关。这很重要，因为即便是基类NSObject（通过实现函数-bind:toObject:withKeyPath:options:）也会创建监听。</p><p>1、-addObserver:forKeyPath:options:context:函数不接受一个自定义的回调函数</p><p>如果你查阅过相似的APIs，比如NSNotificationCenter，你会发现在为一个指定的消息注册监听器时通常涉及到传入一个回调函数作为注册函数的参数。这样可以很容易将当前类的监听事件与父类进行区分，因为你可以直接将消息导向你自己的回调方法。然而，你使用KVO则不得不重载-observeValueForKeyPath:ofObject:change:context:函数，然后在其中处理你监听的事件或者调用父类实现。判断是否需要处理一个消息或是传递给继承链的上一层处理是个复杂的问题，事实上父类也有可能监听了同样的键值路径或者对象。</p><p>2、上下文指针变成鸡肋</p><p>这个是上一个问题的推论。因为你不能自定义监听的回调函数，也无法通过检测键值路径或者对象来判断父类是否也监听了某个消息。你需要采取其他途径来区分一个消息对象是否属于当前类或是其父类。上下文指针就是为此而生的。你必须创建一个唯一的指针且不会被父类使用，然后做完上下文参数传入函数-addObserver:forKeyPath:options:context:中。随后，你必须在回调函数-observeValueForKeyPath:ofObject:change:context:中检测参数context是否属于当前类。因此，你不能用上下文指针指向一个上下文，也意味着失去了其本该有的功能。</p><p>3、-removeObserver:forKeyPath:接受的参数不完善</p><p>这个函数不能传入上下文指针。这意味着如果当前类和父类在不同时期都监听了同样的对象或是键值路径，你没办法移除你自己的监听。调用这个函数可能注销你的监听，也可能是注销父类的，或是甚至同时注销两者。</p><p>很可惜一个如此强大的工具会有这么严重的缺陷。尤其Apple开始在新的APIs中弱化NSNotification和代理回调的功能，取而代之的是KVO。一个典型的例子是NSOperation：获知一个NSOperation任务完成的唯一途径是通过使用KVO监听它的“isFinished”属性。</p><h5 id="完善方案"><a href="#完善方案" class="headerlink" title="完善方案"></a>完善方案</h5><p>那么我们能为此做点什么？我不想一味地抱怨，所以我写了一个类来解决这个问题。你可以从我的<a href="https://github.com/mikeash/mikeash.com-svn/tree/master/">public svn repository</a>获取它，使用如下方式：</p><p>svn co <a href="http://www.mikeash.com/svn/MAKVONotificationCenter/">http://www.mikeash.com/svn/MAKVONotificationCenter/</a></p><p>你也可以点击上面的链接查看源代码。</p><p>那么这个类具体实现是怎么样的？它利用了一个可以保证唯一性的指针：self指针。它不再直接使用目标对象注册某个监听通知（键值路径或者对象），取而代之的是为每个通知创建一个唯一的helper对象并且注册消息监听。随后，这个helper对象接收消息并派发给原有的监听者。因为helper对象对每一个监听者而言是唯一的，所以它可以以实例变量的方式持有关于监听者的元数据，而不需要依赖于上下文指针，至此上下文指针也完全作为函数所需的唯一指针。由于helper对象的职责就是监听KVO通知，监听者持有helper对象的生命周期，我们可以假设父类，NSObject，要么没有注册任何监听，要么监听同样持有一个helper作为监听助手。</p><p>MAKVONotificationCenter避开了上述的三个缺陷：</p><p>1、函数-addObserver:…中接受自定义回调函数作为参数，当被监听的键值路径发生变化时，自定义的回调函数会被调用。由于父类的回调函数是另外一个不同的函数，所以确保二者的监听不会互相干扰。</p><p>2、注册监听的函数中提供一个userinfo参数。可以是一个包含监听者任意信息的对象。</p><p>3、函数-removeObserver:…不再仅仅接受监听者和键值路径，还可以接受一个回调函数。这样即便子类和父类注册了同一键值路径或者同样的对象，二者都可以通过指定的回调函数注销监听，而不会影响彼此。</p><p>代码中一些值得注意的特征：</p><p>函数+defaultCenter中使用了<a href="https://www.mikeash.com/pyblog/late-night-cocoa.html">a simple lockless atomic call</a>保证了单例模式的线程安全，不需要每次访问时进行加锁处理。这是一个不错的技术，创建一个安全的单例对象，不需要在每次被访问时提前初始化或是进行加解锁处理。</p><p>以NSObjct分类的方式提供一组更为轻便和更优的API。这是一个相比于直接访问MAKVONotificationCenter类的单例更好的方式。在一个极端的情况，MAKVONotificationCenter类可能会从头文件移除，留下的只有NSObject的分类实现。</p><p>这份代码压根没有被测试过。我所做过的测试都在代码Tester.m中。在你使用之前不要轻易相信这份代码。150行代码并不算多，但是使用的后果自负。</p><p>如果你希望在你的项目里使用它，你也许只要注明代码出处就可以了。如果发现了代码的不足欢迎提供补丁。</p>]]></content>
      
      
      <categories>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个特殊函数+load和+initialize</title>
      <link href="/2015/04/01/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0+load%E5%92%8C+initialize/"/>
      <url>/2015/04/01/%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0+load%E5%92%8C+initialize/</url>
      
        <content type="html"><![CDATA[<p>记得还在上一家公司任职的时候，在研发部的探讨会会上就“+load的加载过程”这一议题有过激烈的讨论，大家各执一词，争得面红耳赤。最终是部门老大专门做了一期讲解，才平息了这场争执。但是那时候的讲解并未涉及到源代码分析，而是基于测试代码做的分析，故我并没有完全理解。</p><p>在苹果开发文档中提及到：+load是在类或者分类被添加到runtime的时候被调用，而+initialize则是在类的用实例方法或者类方法第一次被调用之前调用。</p><p>上面的说明只是说明了这两个函数调用时机，但是并没有涉及父类、子类和分类之间的调用顺序和相互影响，于是试着结合<a href="https://opensource.apple.com/tarballs/objc4/">apple公司的开源代码</a>objc4-532.2试着分析这两个函数的加载过程，以加深理解。</p><h4 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h4><p>首先在objc-os.mm文件中找到函数_objc_load_image_objc_load_image：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> _objc_load_image(HMODULE image, header_info *hinfo)</span><br><span class="line">{</span><br><span class="line">    prepare_load_methods(hinfo);</span><br><span class="line">    call_load_methods();</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p>根据参数判断，这个函数应该是在加载镜像文件的时候由系统直接调用，且里面就两行代码，分别是对+load函数的预处理与加载</p><p>接着在objc-runtime-new.mm文件找查看prepare_load_methods的函数实现：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> prepare_load_methods(header_info *hi)</span><br><span class="line">{</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"><span class="comment">//获取头文件中所有的类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="comment">//先处理类中的+load方法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="comment">//处理类与父类中的+load函数    schedule_class_load(remapClass(classlist[i]));</span></span><br><span class="line">    }</span><br><span class="line"> <span class="comment">//再处理分类中的+load方法</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">     <span class="comment">//初始化分类</span></span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(isRealized(cls-&gt;isa));</span><br><span class="line">        <span class="comment">//将可加载的（存在+load函数）分类归类</span></span><br><span class="line">        add_category_to_loadable_list((Category)cat);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(isRealized(cls));  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//递归调用，优先处理父类</span></span><br><span class="line">    schedule_class_load(getSuperclass(cls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也就意味着父类中的+load方法先被加入列表</span></span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, <span class="number">0</span>); </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>由上述函数可以推断出：父类的+load方法先于子类被加入待处理列表，分类与类中的+load方法是区分对待的。</p><p>接着，在objc-loadmethod.mm文件中查看call_class_loads函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> more_categories;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_assert_locked(&amp;loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先调用类中的+load方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">//先入先出处理+load函数列表</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">//再调用分类中的+load函数</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    } <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = <span class="literal">NULL</span>;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="comment">//先入先出的遍历顺序，调用父类函数先于子类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">//获得+load的函数指针</span></span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">     <span class="comment">//注意：是通过函数指针直接调用，而非使用objc_msgSend，因此不会走runtime调用过程。</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) _free_internal(classes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> call_category_loads(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  _class_isLoadable(cls)) {</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             _class_getName(cls), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//直接通过函数指针进行调用，而非通过objc_msgSend调用</span></span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在上述函数中，先调用了类的+load函数列表，再处理分类中的+load函数，且都是直接通过函数指针调用。又因为父类的+load函数先于子类加入列表，因此+load函数的调用顺序是：父类-&gt;子类-&gt;分类</p><p>在上一篇博客<a href="http://icebergcwp.com/2015/03/25/Objective-C%20Category%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Objective-C Category 深入浅出系列之实现原理</a>中结合源代码分析了Category的实现原理。其中有一个重要的知识点就是分类Category中函数会覆盖主类中同名的函数。然而这种情况发生的前提是函数必须是通过runtime机制（使用objc_msgSend发送消息）调用，因为这样才会通过遍历类的方法列表去获得方法对应的实现。</p><h4 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h4><p>既然+initialize函数是在类的实例方法或者类方法第一次被调用之前触发，而类的实例方法或者类方法正常的调用方式是通过objc_msgSend函数。那么+initialize很有可能是在objc_msgSend函数中进行判断和触发，于是，在objc-msg-x86_64.s文件找到了objc_msgSend的汇编实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL_cmd,...);</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************/</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.align 3</span><br><span class="line">.private_extern __objc_tagged_isa_table</span><br><span class="line">__objc_tagged_isa_table:</span><br><span class="line">.fill 16, 8, 0</span><br><span class="line"></span><br><span class="line">ENTRY_objc_msgSend</span><br><span class="line">DW_START _objc_msgSend</span><br><span class="line"></span><br><span class="line">NilTestNORMAL</span><br><span class="line"></span><br><span class="line">GetIsaFast NORMAL// r11 = self-&gt;isa</span><br><span class="line">CacheLookup NORMAL, _objc_msgSend  // r11=method, eq set (nonstret fwd)</span><br><span class="line">jmp*method_imp(%r11)// goto *imp</span><br><span class="line"></span><br><span class="line">NilTestSupportNORMAL</span><br><span class="line"></span><br><span class="line">GetIsaSupportNORMAL</span><br><span class="line"></span><br><span class="line">// cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">DW_MISS _objc_msgSend</span><br><span class="line">GetIsaNORMAL// r11 = self-&gt;isa</span><br><span class="line">MethodTableLookup %a1, %a2, _objc_msgSend// r11 = IMP</span><br><span class="line">cmp%r11, %r11// set eq (nonstret) for forwarding</span><br><span class="line">jmp*%r11// goto *imp</span><br><span class="line"></span><br><span class="line">DW_END _objc_msgSend, 1, 1</span><br><span class="line">END_ENTRY_objc_msgSend</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">ENTRY _objc_msgSend_fixup</span><br><span class="line">DW_START _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">NilTestNORMAL</span><br><span class="line"></span><br><span class="line">SaveRegisters _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">// Dereference obj/isa/cache to crash before _objc_fixupMessageRef</span><br><span class="line">movq8(%a2), %a6// selector</span><br><span class="line">GetIsaNORMAL// r11 = isa = *receiver</span><br><span class="line">movqcache(%r11), %a5// cache = *isa</span><br><span class="line">movqmask(%a5), %a4// *cache</span><br><span class="line"></span><br><span class="line">// a1 = receiver</span><br><span class="line">// a2 = address of message ref</span><br><span class="line">movq%a2, %a3</span><br><span class="line">xorl%a2d, %a2d</span><br><span class="line">// __objc_fixupMessageRef(receiver, 0, ref)</span><br><span class="line">call__objc_fixupMessageRef</span><br><span class="line">movq%rax, %r11</span><br><span class="line"></span><br><span class="line">RestoreRegisters _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">// imp is in r11</span><br><span class="line">// Load _cmd from the message_ref</span><br><span class="line">movq8(%a2), %a2</span><br><span class="line">cmp%r11, %r11// set nonstret (eq) for forwarding</span><br><span class="line">jmp *%r11</span><br><span class="line"></span><br><span class="line">NilTestSupportNORMAL</span><br><span class="line"></span><br><span class="line">DW_END _objc_msgSend_fixup, 0, 1</span><br><span class="line">END_ENTRY _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">// Load _cmd from the message_ref</span><br><span class="line">movq8(%a2), %a2</span><br><span class="line">jmp_objc_msgSend</span><br><span class="line">END_ENTRY _objc_msgSend_fixedup</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>汇编基本就是大一水平，很有限。初略发现在调用指令_objc_msgSend之前，先调用了_objc_fixupMessageRef函数。</p><p>接着在objc-runtime-new.mm文件中找到_objc_fixupMessageRef函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OBJC_EXTERN IMP </span><br><span class="line">_objc_fixupMessageRef(<span class="keyword">id</span> obj, <span class="keyword">struct</span> objc_super2 *supr, message_ref_t *msg)</span><br><span class="line">{</span><br><span class="line">    IMP imp;</span><br><span class="line">    class_t *isa;</span><br><span class="line">    </span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">    msg-&gt;sel = sel_registerName((<span class="keyword">const</span> <span class="keyword">char</span> *)msg-&gt;sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(msg-&gt;sel)) {</span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        msg-&gt;imp = (IMP)&amp;vtable_ignored;</span><br><span class="line">        imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_VTABLE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;imp == (IMP)&amp;objc_msgSend_fixup  &amp;&amp;  </span><br><span class="line">        (vtableIndex = vtable_getIndex(msg-&gt;sel)) &gt;= <span class="number">0</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// vtable dispatch</span></span><br><span class="line">        msg-&gt;imp = vtableTrampolines[vtableIndex];</span><br><span class="line">        imp = isa-&gt;vtable[vtableIndex];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// ordinary dispatch</span></span><br><span class="line">        <span class="comment">//常规的消息派发，遍历类的函数列表</span></span><br><span class="line">        imp = lookUpMethod((Class)isa, msg-&gt;sel, <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, obj);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在上述函数中调用了lookUpMethod函数，其中调用了prepareForMethodLookup函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IMP prepareForMethodLookup(Class cls, SEL sel, <span class="built_in">BOOL</span> init, <span class="keyword">id</span> obj)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_unlocked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRealized(newcls(cls))) {</span><br><span class="line">        rwlock_write(&amp;runtimeLock);</span><br><span class="line">        realizeClass(newcls(cls));</span><br><span class="line">        rwlock_unlock_write(&amp;runtimeLock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用_class_initialize对类进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init  &amp;&amp;  !_class_isInitialized(cls)) {</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, obj));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在objc-initialize.mm函数中，找到_class_initialize函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">{</span><br><span class="line">    assert(!_class_isMetaClass(cls));</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="built_in">BOOL</span> reallyInitialize = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    <span class="comment">//递归，保证父类先于子类初始化</span></span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) {</span><br><span class="line">        <span class="comment">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Record that we're initializing this class so we can message it.</span></span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Send the +initialize message.</span></span><br><span class="line">        <span class="comment">// Note that +initialize is sent to the superclass (again) if </span></span><br><span class="line">        <span class="comment">// this class doesn't implement +initialize. 2157218</span></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: calling +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过objc_msgSend调用+initialize函数</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintInitializing) {</span><br><span class="line">            _objc_inform(<span class="string">"INITIALIZE: finished +[%s initialize]"</span>,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        }        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Done initializing. </span></span><br><span class="line">        <span class="comment">// If the superclass is also done initializing, then update </span></span><br><span class="line">        <span class="comment">//   the info bits and notify waiting threads.</span></span><br><span class="line">        <span class="comment">// If not, update them later. (This can happen if this +initialize </span></span><br><span class="line">        <span class="comment">//   was itself triggered from inside a superclass +initialize.)</span></span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过上述函数可知两点：一是父类的+initialize函数先于子类调用，二是+initialize不同于+load函数的采用函数指针调用，而是通过objc_msgSend函数调用，如果分类实现了+initialize函数，那么类（包括子类和父类）的+initialize函数就会被覆盖。</p><p>因此，+initialize的调用顺序是父类-&gt;子类，且分类的实现覆盖类的实现，因此分类中的+initialize可能会被多次调用。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，对于+load和+initialize的调用规则和方式有了进一步的认识。在日后的编程过程中也可以根据二者的特点，更好的使用它们的功能。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C Category 深入浅出系列-第1话</title>
      <link href="/2015/03/25/Objective-C%20Category%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2015/03/25/Objective-C%20Category%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Objective-C Category（分类）之于我而言有种神秘感，虽然自己已经在实际开发过程中已经多次使用它，且感受到了它带来的便利与高效。但是我却仅仅是停留在对它的基本使用层面，除此之外一无所知。我能感觉它的强大，心中也一直有种对它内部实现一探究竟的冲动，奈何迟迟没有行动。时间愈久，这种情绪愈发浓烈，今天终究是按耐不住了…</p><h3 id="知其然"><a href="#知其然" class="headerlink" title="知其然"></a>知其然</h3><p>对于苹果应用开发者来说，开发者想要快速地了解或是回顾某个知识点，<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">Apple开发者文档</a>往往是不二首选。</p><p>文档上如是说：你可以使用Category为一个已经存在的类添加额外的方法，比如Cocoa库中的类，即便是这个类的源代码是不可见的-不能子类化。使用Category给类添加的方法能被其子类继承，且在Runtime下其与类原有的方法是无差别的。</p><p>分类的使用场景：</p><ul><li>在不改变某个类源文件和不使用继承的前提下，为该类添加先的方法</li><li>声明类的私有方法</li><li>将一个类的实现拆分为多个独立的源文件</li></ul><p>很明显，Category其实就是设计模式之一的装饰者模式的具体实现。</p><p> <em>注意，Category是一个类的拓展，为不是一个新类。</em></p><p>借助Apple开发者文档了解到Category的“知其然”，然后就是基于<a href="https://opensource.apple.com/tarballs/objc4/">Apple Opensource</a>来解决“知其所以然”的问题？</p><h3 id="知其然所以然"><a href="#知其然所以然" class="headerlink" title="知其然所以然"></a>知其然所以然</h3><p> 此处使用的源码版本是objc4-532.2。与本文相关的代码都在源文件objc-runtime-new.mm中，接下来就结合关键的代码与注释进行分析。</p><p> Catrgory的定义</p> <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> category_t {</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">} category_t;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> 通过Category的定义可以看出，Category与Class存在很相似。不过Category没有isa指针，这也说明Category不是一个类，只能作为一个类的拓展存在。</p><p> 关键Method-1: _read_images()</p> <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACH_HEADER \</span></span><br><span class="line"><span class="meta">hIndex = 0;         \</span></span><br><span class="line"><span class="meta">crashlog_header_name(NULL) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); \</span></span><br><span class="line"><span class="meta">hIndex++</span></span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Discover categories.</span></span><br><span class="line">    <span class="comment">//遍历工程中所有的头文件</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) {</span><br><span class="line">        <span class="comment">//Category列表</span></span><br><span class="line">        category_t **catlist =</span><br><span class="line">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//遍历Category列表</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="comment">//Category拓展的类的指针</span></span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!cls) {</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line">            <span class="comment">// the class is realized.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//检测目标类是否已实现</span></span><br><span class="line">            <span class="built_in">BOOL</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            {</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls)) {</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = <span class="literal">YES</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Categoty存在方法列表或者协议列表</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                <span class="comment">/* ||  cat-&gt;classProperties */</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//关键函数块</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//添加Category到目标类</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//重构目标类的方法列表</span></span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls-&gt;isa)) {</span><br><span class="line">                <span class="comment">//关键函数！</span></span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Category discovery MUST BE LAST to avoid potential races</span></span><br><span class="line">    <span class="comment">// when other threads call the new category code before</span></span><br><span class="line">    <span class="comment">// this thread finishes its fixups.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> EACH_HEADER</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> _read_images()是赋值读取镜像文件的函数，函数末尾就是处理Category的代码块。其中将工程中所有的Category分别与其目标类建立关联，然后调用了remethodizeClass()对目标类的进行重构。</p><p> 关键Method-2: remethodizeClass()</p> <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> remethodizeClass(class_t *cls)</span><br><span class="line">{</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="built_in">BOOL</span> isMeta;</span><br><span class="line">    </span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//识别目标类是否为元类</span></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="comment">//重构目标类的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls))) {</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        <span class="keyword">const</span> protocol_list_t **newprotos;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>,</span><br><span class="line">                         getName(cls), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Update methods, properties, protocols</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> vtableAffected = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加Category中的方法到目标类</span></span><br><span class="line">        <span class="comment">//关键函数！</span></span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Category中的属性插入属性链表的头部，只有匿名Category才能额外添加属性</span></span><br><span class="line">        newproperties = buildPropertyList(<span class="literal">NULL</span>, cats, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (newproperties) {</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Category中的协议加入目标类</span></span><br><span class="line">        <span class="comment">//查看buildProtocolList函数得知，新的协议的加入目标类原有协议的尾部</span></span><br><span class="line">        newprotos = buildProtocolList(cats, <span class="literal">NULL</span>, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) {</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        }</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line">        </span><br><span class="line">        _free_internal(cats);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Update method caches and vtables</span></span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        <span class="keyword">if</span> (vtableAffected) flushVtables(cls);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> remethodizeClass()函数的功能比较简单，进一步细化了对Category中的方法列表、协议列表和属性列表的处理。其中，属性列表的处理则是直接插入原属性链表头部，协议列表则是附加到原协议列表的尾部。接下来，重点分析处理Category方法列表的attachCategoryMethods函数。</p><p>关键Method-3: attachCategoryMethods()</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                      <span class="built_in">BOOL</span> *inoutVtablesAffected)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> isMeta = isMetaClass(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为每个Category分配函数列表</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">    _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="built_in">BOOL</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//汇总所有Category的拓展方法</span></span><br><span class="line">    <span class="keyword">while</span> (i--) {</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) {</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键函数!</span></span><br><span class="line">    <span class="comment">//将Category中的拓展方法加入到目标类</span></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle, inoutVtablesAffected);</span><br><span class="line">    </span><br><span class="line">    _free_internal(mlists);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>attachCategoryMethods()函数的功能也比较简单，对与目标类的Category中所有方法进行汇总，然后调用attachMethodLists函数进行处理。</p><p>关键Method-4: attachMethodLists()</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> attachMethodLists(class_t *cls, method_list_t **addedLists, <span class="keyword">int</span> addedCount,</span><br><span class="line">                  <span class="built_in">BOOL</span> baseMethods, <span class="built_in">BOOL</span> methodsFromBundle,</span><br><span class="line">                  <span class="built_in">BOOL</span> *inoutVtablesAffected)</span><br><span class="line">{</span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method list array is NULL-terminated.</span></span><br><span class="line">    <span class="comment">// Some elements of lists are NULL; we must filter them out.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法列表以NULL作为结束符，因此需要过滤掉目标类中的NULL函数</span></span><br><span class="line">    method_list_t *oldBuf[<span class="number">2</span>];</span><br><span class="line">    method_list_t **oldLists;</span><br><span class="line">    <span class="keyword">int</span> oldCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY) {</span><br><span class="line">        oldLists = cls-&gt;data()-&gt;method_lists;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        oldBuf[<span class="number">0</span>] = cls-&gt;data()-&gt;method_list;</span><br><span class="line">        oldBuf[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        oldLists = oldBuf;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (oldLists) {</span><br><span class="line">        <span class="keyword">while</span> (oldLists[oldCount]) oldCount++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> newCount = oldCount;</span><br><span class="line">    <span class="comment">//同上，过滤掉Category方法列表中的NULL函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addedCount; i++) {</span><br><span class="line">        <span class="keyword">if</span> (addedLists[i]) newCount++;  <span class="comment">// only non-NULL entries get added</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新的方法列表</span></span><br><span class="line">    method_list_t *newBuf[<span class="number">2</span>];</span><br><span class="line">    method_list_t **newLists;</span><br><span class="line">    <span class="keyword">if</span> (newCount &gt; <span class="number">1</span>) {</span><br><span class="line">        newLists = (method_list_t **)</span><br><span class="line">        _malloc_internal((<span class="number">1</span> + newCount) * <span class="keyword">sizeof</span>(*newLists));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        newLists = newBuf;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add method lists to array.</span></span><br><span class="line">    <span class="comment">// Reallocate un-fixed method lists.</span></span><br><span class="line">    <span class="comment">// The new methods are PREPENDED to the method list array.</span></span><br><span class="line">    </span><br><span class="line">    newCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先将Category加入到新的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addedCount; i++) {</span><br><span class="line">        method_list_t *mlist = addedLists[i];</span><br><span class="line">        <span class="keyword">if</span> (!mlist) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Fixup selectors if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (!isMethodListFixedUp(mlist)) {</span><br><span class="line">            mlist = fixupMethodList(mlist, methodsFromBundle, <span class="literal">true</span><span class="comment">/*sort*/</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Fill method list array</span></span><br><span class="line">        newLists[newCount++] = mlist;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Copy old methods to the method list array、</span></span><br><span class="line">    <span class="comment">//再将目标类原方法加入新的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; oldCount; i++) {</span><br><span class="line">        newLists[newCount++] = oldLists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NULL-terminate</span></span><br><span class="line">    newLists[newCount] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新目标类的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> (newCount &gt; <span class="number">1</span>) {</span><br><span class="line">        assert(newLists != newBuf);</span><br><span class="line">        cls-&gt;data()-&gt;method_lists = newLists;</span><br><span class="line">        changeInfo(cls, RW_METHOD_ARRAY, <span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        assert(newLists == newBuf);</span><br><span class="line">        cls-&gt;data()-&gt;method_list = newLists[<span class="number">0</span>];</span><br><span class="line">        assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>attachMethodLists才是最关键的函数。函数中为目标类分配了一个新的函数列表，先加入Category中的方法，再加入目标类原有方法。这也就是为什么如果Category中的函数与目标类中的函数重名，那么目标类的函数会被覆盖的原因。因为Runtime在遍历方法列表时会先发现Category中的函数。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇博客基于源代码对Category与目标类的组合过程进行了分析，明白了Category中的方法、协议和属性的处理流程。因此，我们可以更加高效和准确地使用Category，甚至利用其中存在的“漏洞”实现一些小魔法。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开ARC的神秘面纱系列-第3话</title>
      <link href="/2015/02/25/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC3%E8%AF%9D/"/>
      <url>/2015/02/25/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC3%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.galloway.me.uk/2012/02/a-look-under-arcs-hood-episode-3/">原文地址</a></p><p>“揭开ARC的神秘面纱系列”的这篇续集全都是关于@autoreleasepool这一新指令的。<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#autoreleasepool">LLVM提及到</a>autorelease pools（自动释放池）的语义已经在LLVM3.0版本中发生变化，尤其是，我觉得探究ARC模式更新之后是如何实现的会很有意思。</p><p>因此，思考一下下面的函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> foo() {</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>显然，这完全是不和谐的代码段，但是它能让我看到发生什么。在非ARC模式下，我们可能会假设：number将会在numberWithInt:函数中被分配内存，并返回的是一个自动释放的对象。因此当自动释放池随后被销毁时，number对象将会被释放。所以让我们看看是否如上所述（一如往常，使用的是ARMv7指令集）：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>不错，答案是肯定的。正是这样的。我们可以看到函数先将自动释放池入栈，然后调用numberWithInt:函数，然后将自动释放池出栈。正如我们所预料的。现在我们看看完全相同的代码在ARC模式编译出来是怎么样的：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _foo</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _foo</span><br><span class="line"><span class="symbol">_foo:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#8</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L__unnamed_cfstring_-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>留意上述代码中objc_retainAutoreleasedReturnValue函数和objc_release的调用。ARC已经为我们做了决定，完全不必担心自动释放池，因为ARC可以直接不然自动释放池生效，通过调用objc_retainAutoreleasedReturnValue函数对number对象进行retain一次，然后在后面在调用objc_release函数释放它。这意味着自动释放池的逻辑不一定执行，让人满意的结果。</p><p>注意到自动释放池一直需要入栈和出栈，是因为ARC无法知晓numberWithInt函数和NSLog函数中会发生什么，不知道在函数中是否有对象会被加入释放池。如果说ARC知道这两个函数不会自动释放任何东西则实际上可以移除自动释放池的入栈和出栈操作。也许这种逻辑在ARC未来的版本中出现，尽管我不是很确定那时候ARC的语义会如何实现。</p><p>现在让我思考另外一个例子，在这个例子中我们想要在自动释放池的作用域之外使用number对象。这应该告诉我们为什么ARC是一个神奇的工具。思考下面的代码：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> bar() {</span><br><span class="line">    <span class="built_in">NSNumber</span> *number;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">        number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number = %p"</span>, number);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>你可能会认为上述这段看似很和谐的代码会出问题。问题在于number对象将在自动释放池中创建，在自动释放池初衷时被释放，但是却在释放之后继续使用。噢！让我们通过在非ARC模式下编译上述代码来看看我们的猜想是否是正确的：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>很明显，正如我们所期望的那样没有调用retain,release或者autorelease，因为我们没有显式调用这些函数以及使用ARC。编译的结果也正如我们之前推理的那样。接下来让我们在ARC的帮助下会是什么样：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.globl</span>  _bar</span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     _bar</span><br><span class="line"><span class="symbol">_bar:</span></span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPush</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC1_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(L__unnamed_cfstring_-(LPC1_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleasePoolPop</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r6</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _NSLog</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_release</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>此处应该有掌声！ARC识别出我们在自动释放池作用域之外使用了number对象，因此它如上一段代码一样对numberWithInt:函数的返回值进行了retain，但是这一次它将release操作放在了bar函数末尾而不是自动释放池出栈的时候。这一举措避免在一些代码中出现崩溃，我们可能会认为这些代码是正确的，但实际上却潜在着内存管理的bug。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开ARC的神秘面纱系列-第2话</title>
      <link href="/2015/02/20/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC2%E8%AF%9D/"/>
      <url>/2015/02/20/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC2%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-2/">原文地址</a></p><p>以下是正文：</p><p>写完第一篇关于<a href="http://icebergcwp.com/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/">揭开ARC神秘面纱</a>的博客，我想和大家分享另外一些有趣的片段。这一次我好奇当你通过函数返回一个存在数组中的对象时会发生什么。非ARC模式，你可能会对这个对象retain一次再返回一个自动释放的对象。ARC模式下，我们虽然可以免去这些内存管理的操作，但还是不放心，觉得别扭。因此，我决定检测一下ARC是否做到位了。</p><p>考虑一下这个类：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> array;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)popObject {</span><br><span class="line">    <span class="keyword">id</span> lastObject = [array lastObject];</span><br><span class="line">    <span class="keyword">if</span> (lastObject) {</span><br><span class="line">        [array removeLastObject];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lastObject;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在非ARC模式下，调用函数removeLastObject将会释放数组对对象的持有，如果这是对象的最后一个引用则对象的内存将会被释放，意味着返回的对象是一个已经被回收的对象。所以，我们应当retain一次lastObject并在返回前添加autorelease属性（加入自动释放池）。</p><p>尽管我完全明白ARC应该会完成这些工作，但是我还是担忧没有自己添加这些操作。我天真地以为ARC会一行行地解析函数中的代码。如果是这样，我觉得ARC也许没必要在我们引用lastObject对象的时候为它添加一次引用计数，此时ARC并不知道lastObject需要进行retain，所以ARC没必要非得做这些操作。</p><p>这就是我错误所在。显然，ARC在我们引用lastObject对象的时候为其添加一次引用计数，并在对象立刻作用域的时候进行了一次release操作，在我们这个例子中，由于我们是通过函数返回这个对象且函数名不是已关键字new或者copy开头，因此需要将对象加入自动释放池。</p><p>让我们看看上述代码编译之后的样子：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.thumb_func</span>     <span class="string">"-[ClassA popObject]"</span></span><br><span class="line"><span class="string">"-[ClassA popObject]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r6</span>, :lower16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r4</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r6</span>, :upper16:(_OBJC_IVAR_$_ClassA.array-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r6</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC0_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span>, <span class="number">#12</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="comment">@ InlineAsm Start</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">r7</span>          <span class="comment">@ marker for objc_retainAutoreleaseReturnValue</span></span><br><span class="line">    <span class="comment">@ InlineAsm End</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r5</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">cbz</span>     <span class="built_in">r5</span>, LBB0_2</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC0_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r6</span>]</span><br><span class="line"><span class="symbol">LPC0_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r4</span>, <span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line"><span class="symbol">LBB0_2:</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_autoreleaseReturnValue</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>好吧，事实如此。ARC已经为我们考虑周全了。ARC在代码中插入了objc_retainAutoreleaseReturnValue调用，这意味着ARC已经觉察到需要给一个已经加入自动释放池的返回值增加引用计数，这个操作属于ARC的一种优化处理，它仅仅是把对象从自动释放池中移除而并非真的添加一次引用计数。接下来在函数结尾处，ARC调用了objc_autoreleaseReturnValue，这个函数将即将返回的对象加入自动释放池。</p><p>这仅仅是关于揭开ARC神秘面纱系列的另外一个例子。随着使用ARC的次数增多，我愈发意识它的实用性。ARC减少代码中内存管理相关的错误，并将上述的代码片段进行最佳优化处理。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开ARC的神秘面纱系列-第1话</title>
      <link href="/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/"/>
      <url>/2015/02/05/%E6%8F%AD%E5%BC%80ARC%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%E7%B3%BB%E5%88%97-%E7%AC%AC1%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>这个系列一共有四篇博客，是Matt Galloway大神关于ARC的内部实现的一些探索，看完之后觉得收获不少。因此尝试着翻译出来和大家分享，一定会翻译不当之处，希望大家及时指正。<br><a href="http://www.galloway.me.uk/2012/01/a-look-under-arcs-hood-episode-1/">原文地址</a></p><p>以下是正文：</p><p>在Twitter上和<a href="https://twitter.com/jacobrelkin">@jacobrelkin</a>进行了一次<a href="https://twitter.com/mattjgalloway/status/154478264537194496">交流</a>之后，我决定写几篇博客关于ARC在神秘的面纱之下是如何运转和如何窥视其内部机制的方法。这篇博客我将解释ARC如何处理retain、release和autorelease这三个关键字对应的内部实现。</p><p>我们通过定义一个类作为开始，如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSNumber</span> *foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> foo;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)changeFooDirect:(<span class="built_in">NSNumber</span>*)inFoo {</span><br><span class="line">    foo = inFoo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)changeFooSetter:(<span class="built_in">NSNumber</span>*)inFoo {</span><br><span class="line">    <span class="keyword">self</span>.foo = inFoo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span>*)newNumber {</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span>*)getNumber {</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述代码覆盖了ARC的几个重要的方面，包括直接访问成员变量与通过setter访问这两种方式的比较，以及当不同的函数名的函数返回某个对象时ARC将会如何添加autorelease属性。</span><br><span class="line"></span><br><span class="line">让我们首先关注直接访问成员变量与通过setter访问这两种方式的比较。如果我们编译上述代码并查看其汇编代码将会洞悉其中的奥秘。我决定使用ARMv7指令集而非x86指令集是因为前者更容易理解（纯属个人见解！）。我们可以使用编译参数-fobjc-arc和-fno-objc-arc来开启或关闭ARC。在这些实例中我使用的是优化等级是第3级，也就意味着编译器将会移除多余的代码，这些代码我们既不感兴趣同时还会阻碍我们理解核心代码（读者做一个练习，在不设置优化等级的前提下编译上述代码，看看结果是怎样的）。</span><br><span class="line"></span><br><span class="line">在非ARC的模式下采用如下指令进行编译上述代码：</span><br><span class="line"></span><br><span class="line">$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fno-objc-arc -O3 -S -o - test-arc.m</span><br><span class="line"></span><br><span class="line">然后，查看changeFooDirect:和changeFooDirect:这个两个函数的汇编码：</span><br><span class="line"></span><br><span class="line">``` arm</span><br><span class="line"></span><br><span class="line">.align  2</span><br><span class="line">    .code   16</span><br><span class="line">    .thumb_func     "-[ClassA changeFooDirect:]"</span><br><span class="line">"-[ClassA changeFooDirect:]":</span><br><span class="line">    movw    r1, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))</span><br><span class="line">    movt    r1, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+4))</span><br><span class="line">LPC0_0:</span><br><span class="line">    add     r1, pc</span><br><span class="line">    ldr     r1, [r1]</span><br><span class="line">    str     r2, [r0, r1]</span><br><span class="line">    bx      lr</span><br><span class="line"></span><br><span class="line">    .align  2</span><br><span class="line">    .code   16</span><br><span class="line">    .thumb_func     "-[ClassA changeFooSetter:]"</span><br><span class="line">"-[ClassA changeFooSetter:]":</span><br><span class="line">    push    {r7, lr}</span><br><span class="line">    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))</span><br><span class="line">    mov     r7, sp</span><br><span class="line">    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))</span><br><span class="line">LPC1_0:</span><br><span class="line">    add     r1, pc</span><br><span class="line">    ldr     r1, [r1]</span><br><span class="line">    blx     _objc_msgSend</span><br><span class="line">    pop     {r7, pc}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>继续向前，看看在ARC模式下又是怎样的一副景象。采用如下所示的指令进行编译：</p><pre><code>$ /Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/clang -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk -arch armv7 -fobjc-arc -O3 -S -o - test-arc.m</code></pre><p>同样，此刻我们只关注changeFooDirect:和changeFooDirect:这两个函数：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA changeFooDirect:]"</span></span><br><span class="line"><span class="string">"-[ClassA changeFooDirect:]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(_OBJC_IVAR_$_ClassA.foo-(LPC0_0+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC0_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r1</span>, <span class="built_in">r2</span></span><br><span class="line">    <span class="keyword">blx</span>     _objc_storeStrong</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA changeFooSetter:]"</span></span><br><span class="line"><span class="string">"-[ClassA changeFooSetter:]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC1_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们可以一目了然地看到两段汇编代码的不同之处。函数changeFooSetter:完全一样，而函数changeFooDirect:已经发生了变化：调用了一次objc_storeStrong函数。有意思的地方就是这里。如果我们查阅<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#runtime.objc_storeStrong">LLVM文档中objc_storeStrong函数的说明</a>将会看到objc_storeStrong函数里完成一个典型的变量交换，释放旧变量然后持有新变量。然而在非ARC模式下，这个变量仅仅是赋值，并没有任何释放或者持有操作。这就是我们期望的结果，感谢ARC！</p><p>接下来是更有趣的地方，newNumber函数对比getNumber函数。这两个函数在非ARC模式下都返回一个引用计数为1的NSNumber对象，也就是说函数调用者持有返回对象。根据Cocoa的命名约定，这个结果似乎符合函数newNumber而不符合函数getNumber。我们期望看到函数getNumber中有调用autorelease。因此，让我们查看非ARC模式下的代码是怎样的：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA newNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA newNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC2_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA getNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA getNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC3_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后是ARC模式下：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA newNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA newNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC2_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC2_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC2_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC2_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC2_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br><span class="line">    <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">    <span class="meta">.code</span>   <span class="number">16</span></span><br><span class="line">    <span class="meta">.thumb_func</span>     <span class="string">"-[ClassA getNumber]"</span></span><br><span class="line"><span class="string">"-[ClassA getNumber]"</span>:</span><br><span class="line">    <span class="keyword">push</span>    {<span class="built_in">r7</span>, <span class="built_in">lr</span>}</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">mov</span>     <span class="built_in">r7</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_2-(LPC3_0+<span class="number">4</span>))</span><br><span class="line">    movw    <span class="built_in">r0</span>, :lower16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r0</span>, :upper16:(L_OBJC_CLASSLIST_REFERENCES_$_-(LPC3_1+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_0:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line"><span class="symbol">LPC3_1:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r0</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r0</span>, [<span class="built_in">r0</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    movw    <span class="built_in">r1</span>, :lower16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">movs</span>    <span class="built_in">r2</span>, <span class="number">#10</span></span><br><span class="line">    <span class="keyword">movt</span>    <span class="built_in">r1</span>, :upper16:(L_OBJC_SELECTOR_REFERENCES_4-(LPC3_2+<span class="number">4</span>))</span><br><span class="line"><span class="symbol">LPC3_2:</span></span><br><span class="line">    <span class="keyword">add</span>     <span class="built_in">r1</span>, <span class="built_in">pc</span></span><br><span class="line">    <span class="keyword">ldr</span>     <span class="built_in">r1</span>, [<span class="built_in">r1</span>]</span><br><span class="line">    <span class="keyword">blx</span>     _objc_msgSend</span><br><span class="line">    <span class="keyword">blx</span>     _objc_autorelease</span><br><span class="line">    <span class="keyword">pop</span>     {<span class="built_in">r7</span>, <span class="built_in">pc</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>查看上述两段代码唯一不同点：ARC模式下getNumber:函数中调用了objc_autorelease。这也是我们所期望的，因为ARC模式能自动觉察到函数名是以关键字new还是关键字copy开头的，并为不属于这两种的情况的Get类函数的返回对象自动添加一次autorelease调用。棒极了！</p><p>这里仅仅只展示了关于ARC在两种模式下如何工作的一小部分奥秘，与此同时，我希望这能激励读者能自己去探索ARC的内部实现而不是理所当然的接受现有的知识点。作为一个程序员，理解自己使用的工具的内部实现是很重要的。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocoa RunLoop 系列之Configure Custom InputSource</title>
      <link href="/2015/01/10/Cocoa%20RunLoop%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90/"/>
      <url>/2015/01/10/Cocoa%20RunLoop%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客<a href="http://icebergcwp.com/2015/01/05/Cocoa%20RunLoop%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Cocoa RunLoop 系列之基础知识</a>介绍了RunLoop的InpuSource有两种：一种是基于Mach端口且由内核触发的source1，另外一种就是自定义且需要手动触发的source0。</p><p>其中source0包括两种自定义形式：一种是Apple实现的自定义InputSource，提供了一系列接口，直接调用即可；另外一种就是由用户根据开发需要完全自定义实现。本文要介绍的就是后者。</p><p>自定义InputSource在实际开发过程的中，可用于在子线程实现周期性且长时间的任务，通过自定义InputSource控制任务的执行。</p><p>然而，实际开发中，大部分需要处理的InputSource都属于source1,少数需要自定义InputSource的情况也可以借助Apple的自定义InputSource函数接口来满足需求。因此，实际开发中几乎不需要用户配置自定义InputSource。既然如此，是否还有探索配置自定义InputSource的必要？我个人的答案是肯定的。通过配置自定InputSource可以窥探RunLoop的整个Routine的具体流程，而不是只停留在理论层面，有助于更深刻地理解RunLoop运行机制。</p><p>下面进入正文，结合理论和源代码阐述配置自定义InputSource的全过程。</p><h3 id="理论概述"><a href="#理论概述" class="headerlink" title="理论概述"></a>理论概述</h3><p>下图是Apple开发文档中介绍自定义InputSource运行流程图：</p><p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="自定义InputSource流程图"></p><p>结合上图，总结一下几点：</p><ol><li>在工作线程创建一个自定义InputSource并部署到RunLoop中</li><li>主线程中对线程的InputSource和RunLoop进行引用，用于后续操作</li><li>主线程与工作线程共享一个指令集合，以保证指令同步</li><li>通过主线程向InputSource中添加指令和数据</li><li>指令添加结束后，主线程发送一个通知给InputSource，随后唤醒工作线程中的RunLoop</li><li>工作线程的InputSource在接受到通知后，传送指令到RunLoop中等待处理</li><li>RunLoop处理完成，进入休眠，等待下一次唤醒</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以上述理论为基础，结合Apple文档提供的代码片段，实现了一个配置自定义InputSource的Demo,完整实例可以查看<a href="https://github.com/icebergcwp1990/CustomRunLoopInputSourceDemo">GitHub源码</a>。</p><h4 id="创建并配置InputSource对象"><a href="#创建并配置InputSource对象" class="headerlink" title="创建并配置InputSource对象"></a>创建并配置InputSource对象</h4><p>IBRunLoopInputSource类用于管理和配置CFRunLoopSourceRef对象，以及包含一个指令集合。</p><p>以下是初始化函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IBRunLoopInputSource</span> ()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//InputSource对象</span></span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> _runLoopSource;</span><br><span class="line">    <span class="comment">//当前指令</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _currCommand;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//指令集合</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> * commandInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IBRunLoopInputSource</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Init</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//InputSource上下文 ，共有8个回调函数，目前只实现3个</span></span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext</span> context = {<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">            &amp;RunLoopSourceCancelRoutine,</span><br><span class="line">            &amp;RunLoopSourcePerformRoutine};</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化自定义InputSource</span></span><br><span class="line">        _runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上述代码中可看的一共有8个与InputSource相关的回调函数，此处只配置了3个，分别是RunLoopSourceScheduleRoutine、RunLoopSourceCancelRoutine和RunLoopSourcePerformRoutine。这3个回调函数的实现会在后面进行介绍。</p><p>对InputSource的基本操作：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加自定义InputSource到当前RunLoop</span></span><br><span class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="comment">//添加到当前RunLoop的kCFRunLoopDefaultMode模式下</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(runLoop, _runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定RunLoop移除自定义InputSource</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateFromRunLoop:(<span class="built_in">CFRunLoopRef</span> )runLoop</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">CFRunLoopRemoveSource</span>(runLoop, _runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对指令集合的基本操作：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加指令到InputSource</span></span><br><span class="line">- (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    {</span><br><span class="line">        [<span class="keyword">self</span>.commandInfo setObject:data forKey:@(command)];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发InputSource指令</span></span><br><span class="line">- (<span class="keyword">void</span>)fireCommand:(<span class="built_in">NSInteger</span>)command onRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop</span><br><span class="line">{</span><br><span class="line">    _currCommand = command;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知InputSource准备触发指令</span></span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(_runLoopSource);</span><br><span class="line">    <span class="comment">//唤醒InputSource所在的RunLoop，该RunLoop必须有的InputSource所在的RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopWakeUp</span>(runloop);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>从上面的代码可看的，正如之前理论概述总讲的顺序：发出指令之后，先通知InputSource，再唤醒其所在的RunLoop。</p><p>指令通过RunLoop循环，触发相关的回调函数，最终派发给IBRunLoopInputSource对象，然后再处理。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//执行InputSource指令</span></span><br><span class="line">- (<span class="keyword">void</span>)performSourceCommands</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//根据指令获得对应的数据</span></span><br><span class="line">    <span class="keyword">id</span> data = [<span class="keyword">self</span>.commandInfo objectForKey:@(_currCommand)];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!data) {</span><br><span class="line">        data = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Empty data for command : %ld"</span> , _currCommand ];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过代理进行指令数据处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(inputSourceForTest:)]) {</span><br><span class="line">        [<span class="keyword">self</span>.delegate inputSourceForTest:data];</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这里，也许有同学感到困惑：为什么绕了一大圈，最终指令执行的代码还是由IBRunLoopInputSource对象来处理，不如直接把指令处理的函数接口公开，直接调用好了？我之前也有类似的困惑，后面仔细一想才想通。可以从两个角度来解答这个困惑：</p><ol><li>自定义InputSource的一个主要目的在于在子线程中进行周期性的任务</li><li>假设在主线程中直接调用，那么执行的代码也是在主线程，背离了初衷。而通过子线程的RunLoop派发之后，指令对应的处理执行是在子线程</li><li>RunLoop的智能休眠配合自定义InputSource能将子线程长时间执行的情况下的资源开销降到最低</li></ol><p>上述3点恰恰的自定义InputSource的精华所在。</p><h4 id="创建并配置InputSourceContext对象"><a href="#创建并配置InputSourceContext对象" class="headerlink" title="创建并配置InputSourceContext对象"></a>创建并配置InputSourceContext对象</h4><p>IBRunLoopContext类是一个容器类，用于管理InputSource与RunLoop之间的关系。Demo中的代码实现的最简单的一对一的关系，也可以实现一对多的关系，即一个InputSource关联多个RunLoop。</p><p>初始化如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithSource:(IBRunLoopInputSource *)runLoopSource andLoop:(<span class="built_in">CFRunLoopRef</span> )runLoop</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//强引用InputSource和InputSource所在的RunLoop</span></span><br><span class="line">        _runLoopInputSource = runLoopSource;</span><br><span class="line">        </span><br><span class="line">        _runLoop = runLoop;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当InputSource加入RunLoop中之后，会触发相关的回调函数。在前文中提到，在创建InputSource的时候Demo中配置了3个与InputSource相关的回调函数，具体实现如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//inputsource部署回调</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode)</span><br><span class="line">{</span><br><span class="line">    IBRunLoopInputSource* inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class="line">    <span class="comment">//创建一个context，包含当前输入源和RunLoop</span></span><br><span class="line">    IBRunLoopContext * theContext = [[IBRunLoopContext alloc] initWithSource:inputSource andLoop:rl];</span><br><span class="line">    <span class="comment">//将context传入主线程建立强引用，用于后续操作</span></span><br><span class="line">    [(AppDelegate *)[<span class="built_in">NSApp</span> delegate] performSelectorOnMainThread:<span class="keyword">@selector</span>(registerSource:)</span><br><span class="line">                          withObject:theContext waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//InputSource弱引用context，因为context已经强引用InputSource，避免循环引用，用于后续移除操作</span></span><br><span class="line">    inputSource.context = theContext;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//inputsource执行任务回调</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info)</span><br><span class="line">{</span><br><span class="line">    IBRunLoopInputSource*  inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class="line">    <span class="comment">//执行InputSource相关的处理</span></span><br><span class="line">    [inputSource performSourceCommands];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//inputsource移除回调</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode)</span><br><span class="line">{</span><br><span class="line">    IBRunLoopInputSource* inputSource = (__bridge IBRunLoopInputSource*)info;</span><br><span class="line">    <span class="comment">//移除主线程中InputSource对应的Context引用</span></span><br><span class="line">    <span class="keyword">if</span> (inputSource.context)</span><br><span class="line">    {</span><br><span class="line">        [(AppDelegate *)[<span class="built_in">NSApp</span> delegate] performSelectorOnMainThread:<span class="keyword">@selector</span>(removeSource:)</span><br><span class="line">                                                          withObject:inputSource.context waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上述代码分别是InputSource部署、执行和移除相关的回调函数：</p><ol><li>部署：在InputSource部署到RunLoop之后，触发回调函数RunLoopSourceScheduleRoutine，将inputSource对象和RunLoop打包成一个context，通过Apple实现的自定义InputSource函数，发送给主线程，用于发送指令</li><li>执行：执行对应的指令</li><li>移除：在主线程中的context引用</li></ol><h4 id="创建并配置工作线程"><a href="#创建并配置工作线程" class="headerlink" title="创建并配置工作线程"></a>创建并配置工作线程</h4><p>IBRunLoopInputSourceThread类用于配置RunLoop和InputSource。</p><p>线程入口函数实现如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> {</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//创建InputSource</span></span><br><span class="line">        <span class="keyword">self</span>.inputSource = [[IBRunLoopInputSource alloc] init];</span><br><span class="line">        [<span class="keyword">self</span>.inputSource setDelegate:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">//添加InputSource到当前线程RunLoop</span></span><br><span class="line">        [<span class="keyword">self</span>.inputSource addToCurrentRunLoop];</span><br><span class="line">        <span class="comment">//配置RunLoop监听器</span></span><br><span class="line">        [<span class="keyword">self</span> configureRunLoopObserver];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">self</span>.cancelled) {</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//作为对照，执行线程其他非InputSource任务</span></span><br><span class="line">            [<span class="keyword">self</span> doOtherTask];</span><br><span class="line">            <span class="comment">//切入指定模式RunLoop，且只执行一次</span></span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在子线程中的入口函数中，创建InputSource并加入RunLoop，随后启动RunLoop。这里一定要在while循环中切换RunLoop，否则RunLoop只会执行一次便退出。原因在于[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]函数只会执行一次RunLoop，如果InputSource未添加或者已处理完或者超时会立即退出RunLoop。</p><h4 id="完善主线程配置"><a href="#完善主线程配置" class="headerlink" title="完善主线程配置"></a>完善主线程配置</h4><p>主线程的配置在AppDelegate类中实现，包括创建工作线程、管理InputSource引用以及添加指令和发送通知。</p><p>管理InputSource引用：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//注册子线程中InputSource对应的context,用于后续通信</span></span><br><span class="line">- (<span class="keyword">void</span>)registerSource:(IBRunLoopContext*)sourceInfo</span><br><span class="line">{</span><br><span class="line">    [<span class="keyword">self</span>.sourcesToPing addObject:sourceInfo];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除子线程中InputSource对应的context</span></span><br><span class="line">- (<span class="keyword">void</span>)removeSource:(IBRunLoopContext*)sourceInfo</span><br><span class="line">{</span><br><span class="line">    [<span class="keyword">self</span>.sourcesToPing enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([obj isEqual:sourceInfo])</span><br><span class="line">        {</span><br><span class="line">           [<span class="keyword">self</span>.sourcesToPing removeObject:obj];</span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }];</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>添加指令和发送通知</p> <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span>.sourcesToPing count] !=  <span class="number">0</span>, <span class="string">@"Empty Input Source..."</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sourcesToPing.count &gt; <span class="number">0</span>) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此处默认取第一个用于测试，可优化</span></span><br><span class="line">        IBRunLoopContext *runLoopContext = [<span class="keyword">self</span>.sourcesToPing objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        IBRunLoopInputSource *inputSource = runLoopContext.runLoopInputSource;</span><br><span class="line">        <span class="comment">//向数据源添加指令</span></span><br><span class="line">        [inputSource addCommand:command withData:data];</span><br><span class="line">        <span class="comment">//添加后并非要立刻触发，此处仅用于测试</span></span><br><span class="line">        [inputSource fireCommand:command onRunLoop:runLoopContext.runLoop];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写上一篇博客的时候，对与配置自定义InputSource还尚不了解。利用碎片时间和工作间隙仔细阅读了Apple开发文档的相关资料，并且在网上查阅了同行的一些博客之后，决定自己动手写了一个Demo。写Demo的过程的遇到一些新的困惑，随着Demo的完成，大部分困惑也随之而解。</p>]]></content>
      
      
      <categories>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocoa RunLoop 系列之基础知识</title>
      <link href="/2015/01/05/Cocoa%20RunLoop%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2015/01/05/Cocoa%20RunLoop%20%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要结合Apple开发者文档和个人的理解，写的一篇关于Cocoa RunLoop基本知识点的文章。在文档的基础上，概况和梳理了RunLoop相关的知识点。</p><h3 id="一、Event-Loop-amp-Cocoa-RunLoop"><a href="#一、Event-Loop-amp-Cocoa-RunLoop" class="headerlink" title="一、Event Loop &amp; Cocoa RunLoop"></a>一、Event Loop &amp; Cocoa RunLoop</h3><h4 id="宏观上：Event-Loop"><a href="#宏观上：Event-Loop" class="headerlink" title="宏观上：Event Loop"></a>宏观上：Event Loop</h4><ol><li>RunLoop是一个用于循环监听和处理事件或者消息的模型，接收请求，然后派发给相关的处理模块，wikipedia上有更为全面的介绍：<a href="https://en.wikipedia.org/wiki/Event_loop">Event_loop</a></li><li>Cocoa RunLoop属于Event Loop模型在Mac平台的具体实现</li><li><a href="https://en.wikipedia.org/wiki/Event_loop#Implementations">其他平台的类似实现</a>：X Window程序，Windows程序 ，Glib库等</li></ol><h4 id="微观上-Cocoa-RunLoop"><a href="#微观上-Cocoa-RunLoop" class="headerlink" title="微观上: Cocoa RunLoop"></a>微观上: Cocoa RunLoop</h4><ol><li>Cocoa RunLoop本质上就是一个对象，提供一个入口函数启动事件循环，在满足特点条件后才会退出。</li><li>Cocoa RunLoop与普通while/for循环不同的是它能监听处理事件和消息，能智能休眠和被唤醒，这些功能的其实现依赖于Mac Port。</li></ol><h3 id="二、-Cocoa-RunLoop的内部结构"><a href="#二、-Cocoa-RunLoop的内部结构" class="headerlink" title="二、 Cocoa RunLoop的内部结构"></a>二、 Cocoa RunLoop的内部结构</h3><p>但凡说到Cocoa RunLoop内部结构，都离不开下面这张图，来源于Apple开发者文档</p><p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="图1-1 RunLoop结构图"></p><p>结合上图，可将RunLoop架构划分为四个部分：</p><ol><li>事件源</li><li>运行模式</li><li>循环机制</li><li>执行反馈</li></ol><h4 id="1-事件源"><a href="#1-事件源" class="headerlink" title="1. 事件源"></a>1. 事件源</h4><p>Cocoa RunLoop接受的事件源分为两种类型：Input Sources 和 Timer Sources</p><h5 id="1-1-Input-Sources"><a href="#1-1-Input-Sources" class="headerlink" title="1.1. Input Sources"></a>1.1. Input Sources</h5><p>Input Sources通过异步派发的方式将事件转送到目标线程，事件类别分为两大块：</p><ul><li><p>Port-Based Sources ：</p><p>  基于Mach端口的事件源，Cocoa和Core Foundation这两个框架已经提供了内部支持，只需要调用端口相关的对象或者函数就能提供端口进行通信。比如：将NSPort对象部署到RunLoop中，实现两个线程的循环通信。</p></li><li><p>Custom Input Sources ：</p><ul><li><p>用户自定义的输入源：使用Core Foundation框架中CFRunLoopSourceRef对象的相关函数实现。具体实现可以查看另外一篇博客：<a href="http://icebergcwp.com/2015/01/10/Cocoa%20RunLoop%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90/">Cocoa RunLoop 系列之Configure Custom InputSource</a></p></li><li><p>Cocoa Perform Selector Sources：Cocoa框架内部实现的自定义输入源，可以跨线程调用，实现线程见通信，有点类似于Port-Based事件源，不同的是这种事件源只在RunLoop上部署一次，执行结束后便会自动移除。如果目标线程中没有启动RunLoop也就意味着无法部署这类事件源，因此不会得到预期的结果。</p><p>  使用Cocoa自定义事件源的函数接口，如下：</p></li></ul></li></ul> <figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//部署在主线程</span></span><br><span class="line"><span class="comment">//参数列表：Selector:事件源处理函数,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">//部署在指定线程</span></span><br><span class="line"><span class="comment">//参数列表：Selector:事件源处理函数,指定线程,Selector参数,是否阻塞当前线程,指定RunLoop模式</span></span><br><span class="line">permSelector:onThread:withObject:waitUntilDone:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line"><span class="comment">//部署在当前线程</span></span><br><span class="line"><span class="comment">//参数列表：Selector:事件源处理函数,Selector参数,延时执行时间,指定RunLoop模式</span></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"> </span><br><span class="line"><span class="comment">//撤销某个对象通过函数performSelector:withObject:afterDelay:部署在当前线程的全部或者指定事件源</span></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:</span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p> 综上，Input Sources包括基于Mach端口的事件源和自定义的事件源，二者的唯一区别在于被触发的方式：前者是由内核自动触发，后者则需要在其他线程中手动触发。</p><h5 id="1-2-Timer-Sources"><a href="#1-2-Timer-Sources" class="headerlink" title="1.2. Timer Sources"></a>1.2. Timer Sources</h5><p> 不同于Input Sources的异步派发，Timer Source是通过同步派发的方式，在预设时间到达时将事件转送到目标线程。这种事件源可用于线程的自我提醒功能，实现周期性的任务。</p><ul><li>如果RunLoop当前运行模式没有添加Time Sources，则在RunLoop中部署的定时器不会被执行。</li><li>设定的间隔时间与真实的触发时间之间没有必然联系，定时器会根据设定的间隔时间周期性的派发消息到RunLoop，但是真实的触发时间由RunLoop决定，假设RunLoop当前正在处理其一个长时间的任务，则触发时间会被延迟，如果在最终触发之前Timer已经派发了N个消息，RunLoop也只会当做一次派发对待，触发一次对应的处理函数。</li></ul><h4 id="2-运行模式"><a href="#2-运行模式" class="headerlink" title="2. 运行模式"></a>2. 运行模式</h4><p>运行模式类似于一个过滤器，用于屏蔽那些不关心的事件源，让RunLoop专注于监听和处理指定的事件源和RunLoop Observer。</p><p>CFRunLoopMode 和 CFRunLoop 的数据结构大致如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop {</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode {</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>结合以上源码，总结以下几点：</p><ul><li>每种模式通过name属性作为标识。</li><li>一种运行模式（Run Loop Mode）就是一个集合，包含需要监听的事件源Input Sources和Timer Soueces以及需要触发的RunLoop observers。</li><li>Cocoa RunLoop包含若干个Mode，调用RunLoop是指定的Mode称之为CurrentMode。RunLoop可以在不同的Mode下切换，切换时退出CurrentMode,并保存相关上下文，再进入新的Mode。</li><li>在启动Cocoa RunLoop是必须指定一种的运行模式，且如果指定的运行模式没有包含事件源或者observers，RunLoop会立刻退出。</li><li>CFRunLoop结构中的commonModes是Mode集合,将某个Mode的name添加到commonModes集合中，表示这个Mode具有“common”属性。</li><li>CFRunLoop结构中的commonModeItems则是共用源的集合，包括事件源和执行反馈。这些共用源会被自动添加到具有“common”属性的Mode中。</li></ul><p>** Note ** : 不同的运行模式区别在于事件源的不同，比如来源于不同端口的事件和端口事件与Timer事件。不能用于区分不同的事件类型，比如鼠标消息事件和键盘消息事件，因为这两种事件都属于基于端口的事件源。</p><p>以下是苹果预定义好的一些运行模式：</p><ul><li>NSDefaultRunLoopMode //默认的运行模式，适用于大部分情况</li><li>NSConnectionReplyMode //Cocoa库用于监听NSConnection对象响应，开发者很少使用</li><li>NSModalPanelRunLoopMode //模态窗口相关事件源</li><li>NSEventTrackingRunLoopMode  //鼠标拖拽或者屏幕滚动时的事件源</li><li>NSRunLoopCommonModes //用于操作RunLoop结构中commonModes和commonModeItems两个属性</li></ul><h4 id="3-循环机制"><a href="#3-循环机制" class="headerlink" title="3. 循环机制"></a>3. 循环机制</h4><p>循环机制涉及两方面：</p><h5 id="3-1-RunLoop与线程之间的关系"><a href="#3-1-RunLoop与线程之间的关系" class="headerlink" title="3.1. RunLoop与线程之间的关系"></a>3.1. RunLoop与线程之间的关系</h5><p>Apple文档中提到:开发者不需要手动创建RunLoop对象，每个线程包括主线程都关联了一个RunLoop对象。除了主线程的RunLoop在程序启动时被开启，其他线程的RunLoop都需要手动开启。</p><p>待解决的疑问：</p><ul><li>线程中的RunLoop是一直存在还是需要时再创建？</li><li>线程与RunLoop的是如何建立联系的？</li><li>线程与RunLoop对象是否是一一对应的关系？</li></ul><h5 id="3-2-RunLoop事件处理流程"><a href="#3-2-RunLoop事件处理流程" class="headerlink" title="3.2. RunLoop事件处理流程"></a>3.2. RunLoop事件处理流程</h5><p>弄清楚RunLoop内部处理逻辑是理解RunLoop的关键，将单独写一篇博客进行分析。</p><p>待解决的疑问：</p><ul><li>RunLoop如何处理不同事件源？</li><li>RunLoop不同模式切换是如何实现的？</li></ul><p>以上两方面，将在下一篇博客<a href="">Cocoa RunLoop 系列之源码解析</a>中结合源代码来找到答案。</p><h4 id="4-执行反馈"><a href="#4-执行反馈" class="headerlink" title="4. 执行反馈"></a>4. 执行反馈</h4><p>RunLoop Observers机制属于RunLoop一个反馈机制，将RunLoop一次循环划分成若干个节点，当执行到对应的节点调用相应的回调函数，将RunLoop当前的执行状态反馈给用户。</p><ul><li><p>用户可以通过Core Foundation框架中的CFRunLoopObserverRef注册 observers。</p></li><li><p>监听节点：</p><ul><li>The entrance to the run loop. //RunLoop启动</li><li>When the run loop is about to process a timer. //即将处理Timer事件源</li><li>When the run loop is about to process an input source. //即将处理Input事件源</li><li>When the run loop is about to go to sleep. //即将进入休眠</li><li>When the run loop has woken up, but before it has processed the event that woke it up. //重新被唤醒，且在处理唤醒事件之前</li><li>The exit from the run loop. //退出RunLoop</li></ul></li><li><p>监听类别分为两种：一次性和重复监听。</p></li></ul><h3 id="三、何时使用RunLoop"><a href="#三、何时使用RunLoop" class="headerlink" title="三、何时使用RunLoop"></a>三、何时使用RunLoop</h3><p>由于主线程的RunLoop在程序启动时被自动创建并执行，因此只有在其他线程中才需要手动启动RunLoop。很多情况下，对于RunLoop的使用多数情况是在主线程中，包括进行RunLoop模式切换，设置RunLoop Observer等。</p><p>在非主线程中，以下几种情况适用于RunLoop:</p><ul><li>使用基于端口或者自定义的事件源与其他线程进行通信。</li><li>需要在当前线程中使用Timer，必须部署才RunLoop中才有效。</li><li>在目标线程中调用performSelector… 函数，因为本质上使用了Cocoa自定义的事件源，依赖于RunLoop才能被触发。</li><li>线程需要进行周期性的任务，需要长时间存在，而非执行一次。</li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>一直以来，RunLoop对我来说都属于一个比较模糊的概念，在实际编程中也有用到RunLoop的一些功能，确实感觉到很强大，但是仅仅停留在应用层面，并不是很理解具体含义。因此，为了更好的使用RunLoop，有必要研究和梳理RunLoop相关的知识点。</p>]]></content>
      
      
      <categories>
          
          <category> Cocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C Runtime 解析</title>
      <link href="/2015/01/01/objective-c_runtime_%E8%A7%A3%E6%9E%90/"/>
      <url>/2015/01/01/objective-c_runtime_%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这是一篇译文，作为一个英语水平处于半吊子的理科男，因此一定存在不尽原意的地方，翻译此文纯属个人喜好，希望能得到大家的指点和反馈，读者如有兴趣的话可以<a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html">查看原文</a>。</p><p><strong>以下是正文：</strong></p><p>一般而言，当人们刚接触Cocoa/Objective-C的时候，运行时机制（Objective-C Runtime）是最容易被忽视的特征之一。究其原因在于Objective-C是一门简单的语言，花费几个小时便能入门，此后，新手们通常会将大部分的时间和精力用于研究Cocoa Framework以及如何使用它。然而，每一个人至少应该清楚运行时是如何运转的，而不仅仅停留在编译方式的认知层面，如：[target doMethodWith:var];编译之后变成object_msgSend(target,@selector(doMethodWith:),var1)。了解运行时机制的工作原理可以帮助你进一步理解Objective-C这门语言以及你编写的App的运转流程。我相信各个水平层次的Mac/iPhone开发者都会在研究运行时机制的过程中有所收获。</p><h3 id="Objective-C-Runtime库是开源的"><a href="#Objective-C-Runtime库是开源的" class="headerlink" title="Objective-C Runtime库是开源的"></a>Objective-C Runtime库是开源的</h3><p>Objective-C Runtime库是开源的，你随时可以在<a href="http://opensource.apple.com/">源代码</a>上查阅。事实上，查阅源代码是弄清楚Objective-C原理的首选途径之一，胜过阅读苹果开发文档。下载最新版本的源代码<a href="http://opensource.apple.com/source/objc4/objc4-680/">点击我</a>。</p><h3 id="动态-amp-静态-语言"><a href="#动态-amp-静态-语言" class="headerlink" title="动态 &amp; 静态 语言"></a>动态 &amp; 静态 语言</h3><p>Objective-C是基于运行时的语言，意味着它会尽可能地将决定代码执行逻辑的操作从编译&amp;链接阶段延迟到代码被执行的阶段。这将给你带来很大的灵活性，因此如果有必要的话你可以将消息重定向到合适的对象，或者你甚至可以交换两个方法实现，等等。实现上述功能需要运行时具备审查对象可以响应哪些请求和不能响应哪些请求然后准确地派发消息的能力。如果我们将Objective-C这一特性对比C语言。C语言程序运行始于main()函数，基于至上而下的设计执行你的逻辑和调用你实现的函数。C结构体不能通过发送请求到其他的结构体来执行某个函数。很可能你会编写一段C语言代码，如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; stdio.h &gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv[])</span></span><br><span class="line">{</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码经过编译器编译、优化，然后将优化后的代码转化成汇编语言：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"> <span class="meta">.align</span> <span class="number">4</span>,<span class="number">0x90</span></span><br><span class="line"> .globl _main</span><br><span class="line"><span class="symbol">_main:</span></span><br><span class="line"><span class="symbol">Leh_func_begin1:</span></span><br><span class="line">pushq %rbp</span><br><span class="line"><span class="symbol">Llabel1:</span></span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line"><span class="symbol">Llabel2:</span></span><br><span class="line"> subq <span class="number">$16</span>, %rsp</span><br><span class="line"><span class="symbol">Llabel3:</span></span><br><span class="line"> movq %rsi, %rax</span><br><span class="line"> movl %edi, %ecx</span><br><span class="line"> movl %ecx, -<span class="number">8</span>(%rbp)</span><br><span class="line"> movq %rax, -<span class="number">16</span>(%rbp)</span><br><span class="line"> xorb %al, %al</span><br><span class="line"> leaq LC(%rip), %rcx</span><br><span class="line"> movq %rcx, %rdi</span><br><span class="line"> call _printf</span><br><span class="line"> movl <span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line"> movl -<span class="number">4</span>(%rbp), %eax</span><br><span class="line"> addq <span class="number">$16</span>, %rsp</span><br><span class="line"> popq %rbp</span><br><span class="line"> ret</span><br><span class="line"><span class="symbol">Leh_func_end1:</span></span><br><span class="line"> .cstring</span><br><span class="line"><span class="symbol">LC:</span></span><br><span class="line"> <span class="meta">.asciz</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></tbody></table></figure><p>随后链接相关的库生成一个可执行文件。对比于Objective-C，虽然代码处理过程很相似，但是编译后的代码取决于Objective-C Runtime库。当我们最初学习Objective-C时被告知中括号里面的代码是如何被处理的，如下</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></tbody></table></figure><p>被转变成</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">self</span>,<span class="keyword">@selector</span>(doSomethingWithVar:),var1);</span><br></pre></td></tr></tbody></table></figure><p>除此之外我们并不真的知道运行时机制是如何工作的，也许很久以后会知道。</p><h3 id="何为Runtime-运行时"><a href="#何为Runtime-运行时" class="headerlink" title="何为Runtime(运行时)"></a>何为Runtime(运行时)</h3><p>Objective-C Runtime就是一个Runtime库，主要有C语言&amp;汇编语言编写而成，在C语言的基础上加上面向对象的功能之后就成为了Objective-C语言。这意味着运行时机制负责加载类，方法派发，方法传达等操作。本质上而言，运行时机制提供了所有的需要的结构用以支持Objective-C的面向对象编程。</p><h3 id="Objective-C-运行时术语"><a href="#Objective-C-运行时术语" class="headerlink" title="Objective-C 运行时术语"></a>Objective-C 运行时术语</h3><p>在进一步深入之前，让我们扫清一些术语的障碍，这样使我们处于同一立场。就MacOS X App &amp; iPhone OS App开发者所关心而言，这里有两种运行时机制: Modern Runtime和Legacy Runtime。Modern Runtime适用于所有64位MacOS应用和所有iPhone应用，Legacy Runtime适用于所有的32位MacOS应用。运行时机制中有两种类型的函数：实例函数（以‘-’符号开头如-(void)doFoo）;类函数（以‘+’开头如+(id)alloc）。两种函数都与C函数很像，包含一组实现某个任务的代码，如下所示</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)movieTitle</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"Futurama: Into the Wild Green Yonder"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>选择器：在Objective-C中，选择器本质上是一个C数据结构体用以标识一个对象将要执行的函数。在运行时机制中的定义如下</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector  *SEL; </span><br></pre></td></tr></tbody></table></figure><p>使用方式</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL aSel = <span class="keyword">@selector</span>(movieTitle); </span><br></pre></td></tr></tbody></table></figure><p>消息调用：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></tbody></table></figure><p>Objective-C消息就是中括号[]里面的所有东西，包括消息的接受者target，调用的函数getMovieTileForObject以及所有发送的参数obj。消息调用虽然样式上类似于c函数调用但是实现却不同。实际上，当你发送一个消息给一个对象并意味着函数会被执行。对象可能会检测谁是消息的发送者，基于此再决定执行一个不同的函数或者转送消息给其他不同的目标对象。如果你查看运行时机制里的类定义，你将会看到如下所示的内容：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object {</span><br><span class="line">    Class isa;</span><br><span class="line">} *<span class="keyword">id</span>; </span><br></pre></td></tr></tbody></table></figure><p>这里有几个要点。首先是类Class和对象Object都有一个对应的结构体。所有的objc_object结构体都有一个类指针isa，这就是我们所说的“<strong>isa指针</strong>”。运行时机制需要通过检测一个对象的isa指针去查看对象的类别，然后查看该对象是否能响应你当前发送过来的消息。接下来是id指针，id指针默认不属于任何类别只表明指向的是一个Objective-C对象。对于id指针指向的对象，你可以获知对象的类别，查看对象是否能响应某个函数等等，然后当你具体了解了id指针指向的对象之后便可以更好的使用该对象。你同样可以查看LLVM/Clang文档中Blocks的定义：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 {</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 {</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved; <span class="comment">// NULL</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line"> <span class="comment">// optional helper functions</span></span><br><span class="line">     <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">     <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src); </span><br><span class="line">    } *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure><p>Block结构的设计兼容于运行时机制。因此Block被视为一个Objective-C对象，所有也就可以响应消息如-retain,-release,-copy等等。</p><p>IMP:Method Implementations</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,...); </span><br></pre></td></tr></tbody></table></figure><p>IMP是一个函数指针，由编译器生成且指向函数的实现内容。如果你目前是一个Objective-C新手则浅尝辄止，但是我们随后会了解运行时机制是如何调用你的函数的。</p><p>Objective-C类：类里面是什么？在Objective-C中，类实现基本上类似于：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>{</span><br><span class="line"><span class="comment">//vars</span></span><br><span class="line"><span class="built_in">NSInteger</span> counter;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//methods</span></span><br><span class="line">-(<span class="keyword">void</span>)doFoo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><p>但是类在运行时机制中定义远不如此，如下</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></tbody></table></figure><p>我们可以看到一个类中声明了一个父类的引用，类名，实例变量列表，方法列表，缓存以及协议列表。当响应发送给类或对象的消息时，运行时机制需要用到这些信息。</p><h3 id="类定义对象同时类本身也是对象？何解？"><a href="#类定义对象同时类本身也是对象？何解？" class="headerlink" title="类定义对象同时类本身也是对象？何解？"></a>类定义对象同时类本身也是对象？何解？</h3><p>之前我提到过在Objective-C中类本身也是对象，运行时机制通过引入元类（Meta Class）来处理类对象。当你发送一个类似于[NSObject alloc]消息的时候，实际上是发送一个消息给类对象，此时将类对象视为元类的实例对待，而元类本身也是一个根元类（Root Meta Class）的实例。While if you say subclass from NSObject, your class points to NSObject as it’s superclass. However all meta classes point to the root metaclass as their superclass. (原文似乎表达观点有误，暂不翻译)。所有的元类仅有一个类函数列表（不同于类处理实例函数列表，还有变量列表和协议列表等等）。因此，当你发送一个消息给类对象时，如[NSObject alloc]，objc_megSend()实际上是搜索元类的函数列表查看是否有响应的函数，如果存在则在该类对象上执行该函数。</p><h3 id="为什么继承Apple的原生类？"><a href="#为什么继承Apple的原生类？" class="headerlink" title="为什么继承Apple的原生类？"></a>为什么继承Apple的原生类？</h3><p>在你刚开始Cocoa编程时，相关教程都是说创建一个类继承于NSObject然后开始编写自己的代码，简单地继承Apple的原生类会让你获益匪浅。其中一个你甚至意识不到的好处就是让你创建的类运行于运行时机制之上。当我们新建一个实例对象，如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></tbody></table></figure><p>最先被执行的消息是+alloc。如果你<a href="https://developer.apple.com/library/content/#documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html">查阅这个文档</a>会发现：“isa这一实例变量被初始化指向一个描述对于类的数据结构体，其他所有的实例变量都被初始化为0”。所以，通过继承Apple原始类不仅仅继承一些不错的属性，而且还能让我们轻易地创建符合于运行时机制要求的对象（包含一个指向类的isa指针）。</p><h3 id="类缓存机制"><a href="#类缓存机制" class="headerlink" title="类缓存机制"></a>类缓存机制</h3><p>当OC的运行时机制机制通过检视一个对象的isa指针指向的类时会发现该对象实现了很多函数。然而，你可能仅仅调用其中的一小部分也就意味没必要每一次查找某个函数时都去搜索一遍类中的函数列表。因此，类创建了缓存，将你每次搜索函数列表后找到的相应函数存入缓存中。所以，当objc_msgSend()在类中搜寻某个函数是首先会遍历缓存列表。这样做的理论依据在于如果你发送过某个消息给一个对象，你很可能回再次发送同样的消息。因此如果我们将该理论考虑在内意味着如果你有一个NSObject的子类MyObject,并运行以下代码：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyObject *obj = [[MyObject alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">-(<span class="keyword">id</span>)init {</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]){</span><br><span class="line">        [<span class="keyword">self</span> setVarA:@”blah”];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></tbody></table></figure><p>接下来发生：</p><ol><li>[MyObject alloc]最先被执行。因为MyObject类没有实现alloc函数所以在该类自然找不到对应的函数，随后进入父类指针指向的NSObject类。</li><li>询问NSObject类是否响应+alloc，发现其实现了alloc函数。+alloc检测到接收类是MyObject然后分配一块响应大小的内存并在其中初始化一个isa指针指向MyObject类。现在，我们获得了一个实例对象，随后运行时机制将NSObject类的+alloc函数指针存入NSObject对象对应的类中的缓存列表中。</li><li>截至目前，我们发送了一个类消息，现在我们发送一个实例消息：调用-init函数或者自定义的初始化函数。显然，MyObject的实例对象能响应这个消息，因此-(id)init会被存入缓存列表中。</li><li>随后self=[super init]被调用。super作为一个魔法关键字指向父类对象，因此转向NSObjct类中，调用init函数。这样做是为了确保面向对象继承体系（OOP inheritance）正常运转，因为所以的父类都将会正确地初始化它们的变量，然后作为子类对象可以正确地初始化自身的变量和必要时重载父类。</li></ol><p>在这个NSObject类的例子中，没有特别的要点出现。但是事实并不总是如此，有时候初始化很重要，如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line">{</span><br><span class="line"> <span class="built_in">NSString</span> *aString;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSString</span> *aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">id</span>)init</span><br><span class="line">{</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {</span><br><span class="line">  [<span class="keyword">self</span> setAString:<span class="literal">nil</span>];</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@synthesize</span> aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) {</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> * pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">id</span> obj1 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line"> <span class="keyword">id</span> obj2 = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">id</span> obj3 = [<span class="built_in">NSArray</span> alloc];</span><br><span class="line"> <span class="keyword">id</span> obj4 = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"Hello"</span>,<span class="literal">nil</span>];</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj1 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj1 <span class="keyword">class</span>]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj2 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj2 <span class="keyword">class</span>]));</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj3 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj3 <span class="keyword">class</span>]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj4 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj4 <span class="keyword">class</span>]));</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">id</span> obj5 = [MyObject alloc];</span><br><span class="line"> <span class="keyword">id</span> obj6 = [[MyObject alloc] init];</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj5 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj5 <span class="keyword">class</span>]));</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"obj6 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj6 <span class="keyword">class</span>]));</span><br><span class="line">  </span><br><span class="line"> [pool drain];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果你是Cocoa初学者，然后我问你上述代码的打印结果，你的回答可能如下：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> </span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line">MyObject</span><br><span class="line">MyObject</span><br></pre></td></tr></tbody></table></figure><p>但是运行结果却是：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj1 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line">obj2 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></span><br><span class="line">obj3 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line">obj4 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></span><br><span class="line">obj5 <span class="keyword">class</span> is MyObject</span><br><span class="line">obj6 <span class="keyword">class</span> is MyObject</span><br></pre></td></tr></tbody></table></figure><p>这是因为在Objective-C中，调用+alloc会隐性地返回一个类的实例对象而调用-init会返回另外一个类的实例对象。</p><h3 id="objc-msgSend的工作流程是什么？"><a href="#objc-msgSend的工作流程是什么？" class="headerlink" title="objc_msgSend的工作流程是什么？"></a>objc_msgSend的工作流程是什么？</h3><p>objc_msgSend函数实现比较复杂。比如我们写了如下代码…</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> printMessageWithString:<span class="string">@"Hello World!"</span>];</span><br></pre></td></tr></tbody></table></figure><p>上述代码实际上会被编译器转化成：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">self</span>,<span class="keyword">@selector</span>(printMessageWithString:),<span class="string">@"Hello World!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>随后，objc_msgSend函数根据目标对象的isa指针去查询对应的类（或者任一父类）看是否响应选择器@selector(printMessageWithString:)。假设在类的函数派发列表或者缓存中找到了对应的函数实现，那么执行该函数。如此看来，objc_msgSend函数没有返回值，它开始执行然后找到对应的目标函数并执行，因此目标函数的返回值被视为objc_msgSend函数的返回值。</p><p>Bill Bumgarner对于objc_msgSend的研究比我要表达的更为深入（<a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html">part 1</a>,<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/">part 2</a>,<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/">part 3</a>）。总结一下他所要表达的以及你在查阅运行时机制源代码时可能发现的内容：</p><ol><li>检测屏蔽的函数和死循环，很显然如果代码运行在垃圾回收的环境下，我们可以忽略-retain,-release的调用，诸如此类。</li><li>检测空对象。 不同于其他编程语言，在Objective-C中发送一个消息给空对象是完全合法的。[there are some valid reasons you’d want to. Assuming we have a non nil target we go on… ]</li><li>然后在一个类中查找函数指针，首先是搜索缓存列表，如果找到了对应的函数指针就跳转对其实现代码段，即执行函数。</li><li>如果在缓存列表中没有找到对应的函数指针，便搜索类中的函数派发列表。如果找到了对应的函数指针即跳转到其实现代码段。</li><li>如果在缓存列表和函数列表都没有找到对应的函数，随即跳转到消息转发机制，意味着代码会被编译成c语言代码。所以一个函数如下所示：</li></ol><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)doComputeWithNum:(<span class="keyword">int</span>)aNum </span><br></pre></td></tr></tbody></table></figure><p>将会被编译成：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aClass_doComputeWithNum(aClass *<span class="keyword">self</span>,SEL _cmd,<span class="keyword">int</span> aNum)  </span><br></pre></td></tr></tbody></table></figure><p>此时，运行时机制通过这些函数的指针来调用这些转化后的函数，现在你已经不能直接调用这些函数，但是Cocoa库提供了一个方法来获得这些函数的函数指针。。。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//declare C function pointer</span></span><br><span class="line"><span class="keyword">int</span> (computeNum *)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//methodForSelector is COCOA &amp; not ObjC Runtime</span></span><br><span class="line"><span class="comment">//gets the same function pointer objc_msgSend gets</span></span><br><span class="line">computeNum = (<span class="keyword">int</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>))[target methodForSelector:<span class="keyword">@selector</span>(doComputeWithNum:)];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//execute the C function pointer returned by the runtime</span></span><br><span class="line">computeNum(obj,<span class="keyword">@selector</span>(doComputeWithNum:),aNum); </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这样，你可以知道访问这些函数并在运行时中直接调用，甚至利用这种方法来绕开运行时的动态调用来确保一个指定的函数被执行。运行时机制同样可以调用你的函数，只不过是通过objc_msgSend()。</p><h3 id="Objective-C消息传送"><a href="#Objective-C消息传送" class="headerlink" title="Objective-C消息传送"></a>Objective-C消息传送</h3><p>在Objective-C中，发送一个消息给一个不会做出响应的对象是合法的，甚至可能是有意这样设计的。苹果在其开发文档中给出的原因之一是为了模拟Objective-C不支持的多继承，或者你只是想抽象化你的设计，隐藏能处理这些消息的实例对象或类。这是运行时机制必要的功能之一。<br>消息传送工作流程：</p><ol><li>运行时机制搜寻了对象的类和它所有父类中的缓存列表和函数列表，但是并没有找到指定的方法。</li><li>随后运行时机制将会调用你类中的 +(BOOL)resolveInstanceMethod:(SEL)aSEL方法给你一次机会为指定的函数提供函数实现，并告诉运行时机制你已经实现了这个方法。如果运行时机制再次搜索这个函数就能找到对应的函数实现。你可以如下所示，实现这个功能：</li></ol><p>定义一个函数</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd)</span><br><span class="line">{</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Doing Foo"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如下所示，使用class_addMethod()来实现</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(doFoo:)){</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>],aSEL,(IMP)fooMethod,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>class_addMethod()最后一个参数“v@:”表示函数fooMethod的返回值和参数，你可以在运行时机制指南中类型编码<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>了解你可以具体的规则。<br>3. 运行时机制随后会调用- (id)forwardingTargetForSelector:(SEL)aSelector函数，给你一次机会将运行时指向另外一个能响应目标函数的对象。这样做比触发消耗更大的函数：-(void)forwardInvocation:(NSInvocation *)anInvocation更划算。你的具体实现可能如下所示：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:)){</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很显然你不想返回self指针，否则可能导致死循环。</p><ol start="4"><li>此时，运行时机制尝试最后一次去获取消息的预期目标，并调用- (void)forwardInvocation:(NSInvocation *)anInvocation。如果你未曾了解NSInvocation<a href="https://developer.apple.com/reference/foundation/nsinvocation">点击查看</a>,这是Objective-C消息中很重要的构成部分。一旦你持有一个NSInvocation对象，你基本上可以更改消息的任何内容，包括目标对象，选择器和函数参数。你可能操作如下：</li></ol><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">{</span><br><span class="line">    SEL invSEL = invocation.selector;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>([altObject respondsToSelector:invSEL]) {</span><br><span class="line">        [invocation invokeWithTarget:altObject];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果类是继承自NSObjct，- (void)forwardInvocation:(NSInvocation *)anInvocation函数的默认实现是调用-doesNotRecognizeSelector函数，如果你还想做点什么来响应这次消息转送，重载这个函数将是最后一次机会。</p><h3 id="实例变量的无碎片化（Modern-Runtime）"><a href="#实例变量的无碎片化（Modern-Runtime）" class="headerlink" title="实例变量的无碎片化（Modern Runtime）"></a>实例变量的无碎片化（Modern Runtime）</h3><p>目前我们所了解到关于Modern Runtime的概念之一是实例变量无碎片化（Non Fragile ivars）。编译器在编译类的时候确定了实例变量的布局，决定了某个实例变量的访问位置。这属于底层细节，关乎于获得一个对象的指针，查找某个实例变量相对于对象起始位置的偏移，根据实例变量的类型读取相应数量的字节。因此，实例变量的布局可能如下所示，左侧的数字表示实例变量的字节偏移量</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-1.png"></p><p>如上所示，NSObject对象的实例变量布局以及继承NSObject后添加了自己的变量之后的布局。这样的布局在苹果发布更新之前都能正常运行，但是苹果发布了Mac OS X 10.6之后，布局就会变成如下所示：</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-2.png"></p><p>因为与父类的实例变量重叠，自定义的对象的实例变量被抹掉。防止这样的情况发生唯一的可能是苹果能保持更新之前的布局。但是如果苹果这样做的话，那么苹果的框架将不可能得到改进，因为这些框架的实例变量布局已经写死了。处于实例变量碎片化的情况下只能通过重新编译所有继承于苹果类的类来保证兼容新的框架。那么实例变量无碎片化的情况下会是如何处理？</p><p><img src="https://raw.githubusercontent.com/icebergcwp1990/MarkDownPhotos/master/cocoa/translation/runtime-f-3.png"></p><p>实例变量无碎片化的前提下，编译器创建同实例变量碎片化情况下一样的实例变量布局。但是当运行时检测到一个重叠的父类时会调整自定义变量的偏移量，因此子类中自定义的变量得以保留。</p><h3 id="Objective-C-关联对象"><a href="#Objective-C-关联对象" class="headerlink" title="Objective-C 关联对象"></a>Objective-C 关联对象</h3><p>最近Mac OS X 10.6 Snow Leopard推出了一个新特性，称之为关联引用。不同于其他一些语言，Objective-C不支持动态添加实例变量到某个对象的类中。所以在此之前你不得不耗尽脑力去构建一个特定的基础架构，营造一个可以给某个对象动态添加变量的假象。现在在Mac OS X 10.6中，运行时已经支持这一功能。如果想添加一个变量到任一个已经存在的苹果原生类中，比如NSView，我们可以做如下操作：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt; Cocoa/Cocoa.h&gt; //Cocoa</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; objc/runtime.h&gt; //objc runtime api’s</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSImage</span> *customImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> img_key; <span class="comment">//has a unique address (identifier)</span></span><br><span class="line"> </span><br><span class="line">-(<span class="built_in">NSImage</span> *)customImage</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,&amp;img_key);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">void</span>)setCustomImage:(<span class="built_in">NSImage</span> *)image</span><br><span class="line">{</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,&amp;img_key,image,</span><br><span class="line">                             OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在runtime.h头文件中可以看到存储关联对象方式的可选项，作为objc_setAssociatedObject()函数的参数传入。</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Associated Object support. */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* objc_setAssociatedObject() options */</span></span><br><span class="line"><span class="keyword">enum</span> {</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">}; </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这些可选值与@property语法的可选值相匹配。</p><h3 id="混合虚函数表派发（Hybrid-vTable-Dispatch）"><a href="#混合虚函数表派发（Hybrid-vTable-Dispatch）" class="headerlink" title="混合虚函数表派发（Hybrid vTable Dispatch）"></a>混合虚函数表派发（Hybrid vTable Dispatch）</h3><p>如果你查阅现代版运行时的源代码，你会看到以下内容（<a href="http://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m">位于objc-runtime-new.m</a>）:</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* vtable dispatch</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class="line"><span class="comment">* The selectors represented in the vtable are the same for all classes</span></span><br><span class="line"><span class="comment">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class="line"><span class="comment">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class="line"><span class="comment">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class="line"><span class="comment">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class="line"><span class="comment">*   of objc_msgSend.</span></span><br><span class="line"><span class="comment">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class="line"><span class="comment">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class="line"><span class="comment">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class="line"><span class="comment">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class="line"><span class="comment">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class="line"><span class="comment">*   the class points directly to its superclass's vtable. This means </span></span><br><span class="line"><span class="comment">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class="line"><span class="comment">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class="line"><span class="comment">*   particular, -dealloc is a bad choice.</span></span><br><span class="line"><span class="comment">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class="line"><span class="comment">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class="line"><span class="comment">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class="line"><span class="comment">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class="line"><span class="comment">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class="line"><span class="comment">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class="line"><span class="comment">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class="line"><span class="comment">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class="line"><span class="comment">*   vtable selectors are affected.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上述内容阐述的要点就是运行时会尽量存储调用最频繁的函数以达到提高软件运行速度的目的，因为通过虚函数表查找比调用objc_msgSend函数使用的指令更少。虚函数表中的16个函数调用次数远多于其他所有函数。实际上，进一步深入研究代码你会发现垃圾回收机制和无垃圾回收机制下虚函数表中默认的函数：</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtable[] = {</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"retain"</span>, </span><br><span class="line">    <span class="string">"release"</span>, </span><br><span class="line">    <span class="string">"autorelease"</span>, </span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtableGC[] = {</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"hash"</span>, </span><br><span class="line">    <span class="string">"addObject:"</span>, </span><br><span class="line">    <span class="string">"countByEnumeratingWithState:objects:count:"</span>, </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>那么你如何知道是否调用了这些函数？调试模式下，你将会在栈中看到以下函数中的某一个被调用，出于调试的目的，所有的这些方法都可以视为通过objc_msgSend函数调用的。</p><ol><li>objc_msgSend_fixup：是当运行时正在派发一个位于虚函数表的函数时触发，即用于派发虚函数表中的函数。</li><li>objc_msgSend_fixedup：是当调用一个本应存在于虚函数表的函数但是现在已经不存在的函数时触发（个人觉得应该是调用在objc_msgSend_fixup函数之后，并且由前者触发的）。</li><li>objc_msgSend_vtable[0-15]：调试模式下，也许会看到某个函数调用类似于objc_msgSend_vtable5意味着正在调用虚函数表中对应序号的某个函数。</li></ol><p>运行时可以决定是否派发这些函数，所以不要指望以下这种情况存在：objc_msgSend_vtable10在运行时的一次循环中对应的函数是-length,意味着后面任一次循环中也是同样情况。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我希望你能喜欢这些内容，这篇文章基本上覆盖了我在<a href="http://cocoaheads.org/us/DesMoinesIowa/index.html">Des Moines Cocoaheads </a>上谈及的内容。Objective-C运行时是一个了不起的杰作，它为我们的Cocoa/Objective-C应用提供了一个强大的平台，让很多我们正在受用的功能都成为可能。如果你还没有查阅关于如何使用Objective-C运行时的Apple开发文档，我希望你马上行动，谢谢。附上：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">运行时开发文档</a>，<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime">运行时介绍文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
