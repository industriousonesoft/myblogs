title: 初识汇编-知识点摘记
date: 2019-06-27 21:34:07
categories:
- 汇编

---

#### 汇编语言的由来

* 汇编语言是基于机器语言（由0或1组成）而产生的一种助记符
* 汇编语言介于机器语言和高级语言之间
* 汇编语言与机器语言是一一对应关系，每条机器指令都有对应的汇编指令
* 汇编语言通过编译得到机器语言，反之机器语言也可通过反汇编得到汇编语言
* 高级语言通过编译得到汇编语言，但是汇编语言不能反汇编成高级语言，因为高级语言与汇编之间是多对一的关系。

<!-- more -->

#### 汇编语言的特点

**优点**

* 汇编语言可直接访问或控制硬件：存储器、CPU，能最大限度的发挥硬件功能
* 目标代码少，占位内存少，执行速度快
* 不同厂商的CPU都有对应的机器指令集和汇编指令集合
* 大小写不敏感

**缺点**

* 不易于编写、维护、调试

#### 寄存器

* CPU由寄存器、运算器和控制器组成，其中最主要部件是寄存器，通过改变寄存器的内容来实现对CPU的控制
* 不同的CPU，寄存器个数和结构存在差异

##### 通用寄存器

* arm64寄存器有31个64位的通用寄存器x0-x30，这些寄存器通常用来存放一般数据
* w0-w28是32位寄存器，是x0-x28寄存器的低32位，即64位的CPU是兼容32位的
* CPU会先将内存中的数据存储到通用寄存器中，然后在对通用寄存器中的数据进行运算，原因在于寄存器的执行速度比内存快
* arm64架构下，函数参数都是保存在x0-x7（32位下即w0-w7）这8个寄存器，超过8个参数入栈
* 函数返回值是存放在x0寄存器中
* 函数的局部变量都是保存在栈中

##### PC寄存器：program counter register

* 指令指针寄存器，指向CPU当前要执行的指令地址
* 内存中指令和数据无区别，都是二进制数据。CPU将PC寄存器指向的内存单元的内容看作指令

##### sp与fp寄存器

* sp寄存器会在任意时刻保存栈顶地址
* fp寄存器即为x29寄存器，有时也用于保存栈低的地址

##### lr寄存器

* lr寄存器就是0x30通用寄存器
* 0x30寄存器存放函数返回地址，执行ret指令时会读取这个寄存器的值，实现函数返回

#### 汇编指令

##### 内存读写指令

> arm64架构中取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp；ldp/stp是ldr/str的衍生，可同时读写两个寄存器，而ldr/str只能读写一个

* str指令：store register指令，将数据从寄存器中读出，写入内存
* ldr指令：load register指令，将数据从内存读出，存入寄存器

eg：利用栈将x0和x1寄存器中的值互换

> arm64架构中，栈是16字节内存对齐的，即一次读写至少是16（0x10）个字节

```asm
	sub sp,sp,#0x10 ;栈顶指针下移0x10个字节，两个64位的寄存器共16个字节
	stp x0,x1,[sp,0x10] ;寄存器x0,x1先后的值入栈
	ldp x1,x0,[sp,0x10] ;出栈，先后写入x0,x1寄存器
	add sp,sp,0x10 ;栈还原，stp、ldp指令不会改变sp指针位置，且都是由高地址向低地址读写
```

##### bl指令

* CPU执行的指令是由PC寄存器决定的，因此可以通过修改PC寄存器的内容来控制CPU的指令执行
* 传送指令用于操作通用寄存器，比如mov指令；此外是转移指令，用于修改PC的值，最简单的就是bl指令
* bl指令跳转前将当前指令的下一条指令存放到lr(0x30)寄存器：链接寄存器




